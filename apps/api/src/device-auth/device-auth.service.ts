/*
 * Copyright 2025 Daytona Platforms Inc.
 * SPDX-License-Identifier: AGPL-3.0
 */

import { Injectable } from '@nestjs/common'
import { InjectRepository } from '@nestjs/typeorm'
import { Repository, LessThan } from 'typeorm'
import { DeviceAuthorization, DeviceAuthorizationStatus } from './device-authorization.entity'
import * as crypto from 'crypto'

@Injectable()
export class DeviceAuthService {
  private static readonly DEVICE_CODE_EXPIRATION_MINUTES = 15
  private static readonly POLLING_INTERVAL_SECONDS = 5
  private static readonly SLOW_DOWN_PENALTY_SECONDS = 10

  constructor(
    @InjectRepository(DeviceAuthorization)
    private readonly deviceAuthRepository: Repository<DeviceAuthorization>,
  ) {}

  /**
   * Generate a user-friendly code (e.g., WDJB-MJHT)
   */
  private generateUserCode(): string {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789' // Removed confusing characters
    const length = 8
    let code = ''
    const randomBytes = crypto.randomBytes(length)

    for (let i = 0; i < length; i++) {
      code += chars[randomBytes[i] % chars.length]
    }

    // Format as XXXX-XXXX
    return `${code.substring(0, 4)}-${code.substring(4, 8)}`
  }

  /**
   * Generate a secure device code
   */
  private generateDeviceCode(): string {
    return crypto.randomBytes(32).toString('base64url')
  }

  /**
   * Request a device authorization code
   */
  async requestDeviceCode(clientId: string, scope?: string) {
    const deviceCode = this.generateDeviceCode()
    const userCode = this.generateUserCode()
    const expiresAt = new Date(Date.now() + DeviceAuthService.DEVICE_CODE_EXPIRATION_MINUTES * 60 * 1000)

    const authorization = this.deviceAuthRepository.create({
      deviceCode,
      userCode,
      clientId,
      scope,
      status: DeviceAuthorizationStatus.PENDING,
      expiresAt,
    })

    await this.deviceAuthRepository.save(authorization)

    // Clean up expired authorizations
    await this.cleanupExpiredAuthorizations()

    return {
      device_code: deviceCode,
      user_code: userCode,
      verification_uri: `${process.env.DASHBOARD_URL || 'https://app.daytona.io'}/device`,
      verification_uri_complete: `${process.env.DASHBOARD_URL || 'https://app.daytona.io'}/device?user_code=${userCode}`,
      expires_in: DeviceAuthService.DEVICE_CODE_EXPIRATION_MINUTES * 60,
      interval: DeviceAuthService.POLLING_INTERVAL_SECONDS,
    }
  }

  /**
   * Poll for device authorization token
   */
  async pollForToken(deviceCode: string, clientId: string) {
    const authorization = await this.deviceAuthRepository.findOne({
      where: { deviceCode, clientId },
    })

    if (!authorization) {
      return { error: 'invalid_grant', error_description: 'Invalid device code' }
    }

    // Check if expired
    if (new Date() > authorization.expiresAt) {
      authorization.status = DeviceAuthorizationStatus.EXPIRED
      await this.deviceAuthRepository.save(authorization)
      return { error: 'expired_token', error_description: 'The device code has expired' }
    }

    // Check if polling too fast
    if (authorization.lastPollAt) {
      const secondsSinceLastPoll = (Date.now() - authorization.lastPollAt.getTime()) / 1000
      if (secondsSinceLastPoll < DeviceAuthService.POLLING_INTERVAL_SECONDS) {
        return {
          error: 'slow_down',
          error_description: `Polling too quickly, wait ${DeviceAuthService.SLOW_DOWN_PENALTY_SECONDS} seconds`,
          retry_after: DeviceAuthService.SLOW_DOWN_PENALTY_SECONDS,
        }
      }
    }

    // Update last poll time
    authorization.lastPollAt = new Date()
    await this.deviceAuthRepository.save(authorization)

    // Check status
    switch (authorization.status) {
      case DeviceAuthorizationStatus.PENDING:
        return { error: 'authorization_pending' }

      case DeviceAuthorizationStatus.DENIED:
        return { error: 'access_denied', error_description: 'The user denied the request' }

      case DeviceAuthorizationStatus.EXPIRED:
        return { error: 'expired_token', error_description: 'The device code has expired' }

      case DeviceAuthorizationStatus.APPROVED:
        // Return the authorization details (API key will be generated by the controller)
        return {
          authorized: true,
          userId: authorization.userId,
          organizationId: authorization.organizationId,
          scope: authorization.scope,
        }

      default:
        return { error: 'invalid_grant', error_description: 'Unknown status' }
    }
  }

  /**
   * Get authorization by user code (for dashboard)
   */
  async getByUserCode(userCode: string) {
    const authorization = await this.deviceAuthRepository.findOne({
      where: { userCode },
    })

    if (!authorization) {
      return null
    }

    // Check if expired
    if (new Date() > authorization.expiresAt) {
      authorization.status = DeviceAuthorizationStatus.EXPIRED
      await this.deviceAuthRepository.save(authorization)
      return null
    }

    // Don't return already processed authorizations
    if (authorization.status !== DeviceAuthorizationStatus.PENDING) {
      return null
    }

    return authorization
  }

  /**
   * Approve device authorization
   */
  async approve(userCode: string, userId: string, organizationId: string) {
    const authorization = await this.getByUserCode(userCode)

    if (!authorization) {
      throw new Error('Invalid or expired user code')
    }

    authorization.status = DeviceAuthorizationStatus.APPROVED
    authorization.userId = userId
    authorization.organizationId = organizationId
    authorization.approvedAt = new Date()

    await this.deviceAuthRepository.save(authorization)

    return authorization
  }

  /**
   * Deny device authorization
   */
  async deny(userCode: string) {
    const authorization = await this.getByUserCode(userCode)

    if (!authorization) {
      throw new Error('Invalid or expired user code')
    }

    authorization.status = DeviceAuthorizationStatus.DENIED
    await this.deviceAuthRepository.save(authorization)

    return authorization
  }

  /**
   * Clean up expired authorizations
   */
  private async cleanupExpiredAuthorizations() {
    await this.deviceAuthRepository.delete({
      expiresAt: LessThan(new Date()),
      status: DeviceAuthorizationStatus.PENDING,
    })
  }
}
