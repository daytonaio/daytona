---
title: "AsyncCodeInterpreter"
hideTitleOnPage: true
---

## AsyncCodeInterpreter

```python
class AsyncCodeInterpreter()
```

Handles code interpretation and execution within a Sandbox. Currently supports only Python.

This class provides methods to execute code in isolated interpreter contexts,
manage contexts, and stream execution output via callbacks. If subsequent code executions
are performed in the same context, the variables, imports, and functions defined in
the previous execution will be available.

For other languages, use the `code_run` method from the `AsyncProcess` interface,
or execute the appropriate command directly in the sandbox terminal.

#### AsyncCodeInterpreter.\_\_init\_\_

```python
def __init__(api_client: InterpreterApi)
```

Initialize a new AsyncCodeInterpreter instance.

**Arguments**:

- `api_client` - API client for interpreter operations.

#### AsyncCodeInterpreter.run\_code

```python
@intercept_errors(message_prefix="Failed to run code: ")
async def run_code(code: str,
                   *,
                   context: InterpreterContext | None = None,
                   on_stdout: OutputHandler[OutputMessage] | None = None,
                   on_stderr: OutputHandler[OutputMessage] | None = None,
                   on_error: OutputHandler[ExecutionError] | None = None,
                   envs: dict[str, str] | None = None,
                   timeout: int | None = None) -> ExecutionResult
```

Execute Python code in the sandbox.

By default, code runs in the default shared context which persists variables,
imports, and functions across executions. To run in an isolated context,
create a new context with `create_context()` and pass it as `context` argument.

**Arguments**:

- `code` _str_ - Code to execute.
- `context` _InterpreterContext | None_ - Context to run code in. If not provided, uses default context.
- `on_stdout` _OutputHandler[OutputMessage] | None_ - Callback for stdout messages.
- `on_stderr` _OutputHandler[OutputMessage] | None_ - Callback for stderr messages.
- `on_error` _OutputHandler[ExecutionError] | None_ - Callback for execution errors
  (e.g., syntax errors, runtime errors).
- `envs` _dict[str, str] | None_ - Environment variables for this execution.
- `timeout` _int | None_ - Timeout in seconds. 0 means no timeout. Default is 10 minutes.
  

**Returns**:

- `ExecutionResult` - Result object containing stdout, stderr and error if any.
  

**Raises**:

- `DaytonaTimeoutError` - If execution times out.
- `DaytonaError` - If execution fails due to communication or other SDK errors.
  

**Examples**:

```python
def handle_stdout(msg: OutputMessage):
    print(f"STDOUT: {msg.output}", end="")

def handle_stderr(msg: OutputMessage):
    print(f"STDERR: {msg.output}", end="")

def handle_error(err: ExecutionError):
    print(f"ERROR: {err.name}: {err.value}")

code = '''
import sys
import time
for i in range(5):
    print(i)
    time.sleep(1)
sys.stderr.write("Counting done!")
'''
result = await sandbox.code_interpreter.run_code(
    code=code,
    on_stdout=handle_stdout,
    on_stderr=handle_stderr,
    on_error=handle_error,
    timeout=10
)
```

#### AsyncCodeInterpreter.create\_context

```python
@intercept_errors(message_prefix="Failed to create interpreter context: ")
async def create_context(cwd: str | None = None) -> InterpreterContext
```

Create a new isolated interpreter context.

Contexts provide isolated execution environments with their own global namespace.
Variables, imports, and functions defined in one context don't affect others.

**Arguments**:

- `cwd` _str | None_ - Working directory for the context. If not specified, uses sandbox working directory.
  

**Returns**:

- `InterpreterContext` - The created context with its ID and metadata.
  

**Raises**:

- `DaytonaError` - If context creation fails.
  

**Examples**:

```python
# Create isolated context
ctx = await sandbox.code_interpreter.create_context()

# Execute code in this context
await sandbox.code_interpreter.run_code("x = 100", context=ctx)

# Variable only exists in this context
result = await sandbox.code_interpreter.run_code("print(x)", context=ctx)  # OK

# Won't see the variable in default context
result = await sandbox.code_interpreter.run_code("print(x)")  # NameError

# Clean up
await sandbox.code_interpreter.delete_context(ctx)
```

#### AsyncCodeInterpreter.list\_contexts

```python
@intercept_errors(message_prefix="Failed to list interpreter contexts: ")
async def list_contexts() -> list[InterpreterContext]
```

List all user-created interpreter contexts.

The default context is not included in this list. Only contexts created
via `create_context()` are returned.

**Returns**:

- `list[InterpreterContext]` - List of context objects.
  

**Raises**:

- `DaytonaError` - If listing fails.
  

**Examples**:

```python
contexts = await sandbox.code_interpreter.list_contexts()
for ctx in contexts:
    print(f"Context {ctx.id}: {ctx.language} at {ctx.cwd}")
```

#### AsyncCodeInterpreter.delete\_context

```python
@intercept_errors(message_prefix="Failed to delete interpreter context: ")
async def delete_context(context: InterpreterContext) -> None
```

Delete an interpreter context and shut down all associated processes.

This permanently removes the context and all its state (variables, imports, etc.).
The default context cannot be deleted.

**Arguments**:

- `context` _InterpreterContext_ - Context to delete.
  

**Raises**:

- `DaytonaError` - If deletion fails or context not found.
  

**Examples**:

```python
ctx = await sandbox.code_interpreter.create_context()
# ... use context ...
await sandbox.code_interpreter.delete_context(ctx)
```


## OutputMessage

```python
class OutputMessage(BaseModel)
```

Represents stdout or stderr output from code execution.

**Attributes**:

- `output` - The output content.

## ExecutionError

```python
class ExecutionError(BaseModel)
```

Represents an error that occurred during code execution.

**Attributes**:

- `name` - The error type/class name (e.g., "ValueError", "SyntaxError").
- `value` - The error value.
- `traceback` - Full traceback of the error.

## ExecutionResult

```python
class ExecutionResult(BaseModel)
```

Result of code execution.

**Attributes**:

- `stdout` - Standard output from the code execution.
- `stderr` - Standard error output from the code execution.
- `error` - Error details if execution failed, None otherwise.

