---
title: "Sandbox"
hideTitleOnPage: true
---

## Sandbox

Sandbox class for Daytona SDK.

### Constructors

#### new Sandbox()

```ruby
def initialize(code_toolbox:, sandbox_dto:, config:, sandbox_api:, get_proxy_toolbox_url:, otel_state:)

```

**Returns**:

- `Sandbox` - a new instance of Sandbox

### Methods

#### id()

```ruby
def id()

```

**Returns**:

- `String` - The ID of the sandbox

#### organization_id()

```ruby
def organization_id()

```

**Returns**:

- `String` - The organization ID of the sandbox

#### snapshot()

```ruby
def snapshot()

```

**Returns**:

- `String` - The snapshot used for the sandbox

#### user()

```ruby
def user()

```

**Returns**:

- `String` - The user associated with the project

#### env()

```ruby
def env()

```

**Returns**:

- `Hash\<String, String\>` - Environment variables for the sandbox

#### labels()

```ruby
def labels()

```

**Returns**:

- `Hash\<String, String\>` - Labels for the sandbox

#### public()

```ruby
def public()

```

**Returns**:

- `Boolean` - Whether the sandbox http preview is public

#### network_block_all()

```ruby
def network_block_all()

```

**Returns**:

- `Boolean` - Whether to block all network access for the sandbox

#### network_allow_list()

```ruby
def network_allow_list()

```

**Returns**:

- `String` - Comma-separated list of allowed CIDR network addresses for the sandbox

#### target()

```ruby
def target()

```

**Returns**:

- `String` - The target environment for the sandbox

#### cpu()

```ruby
def cpu()

```

**Returns**:

- `Float` - The CPU quota for the sandbox

#### gpu()

```ruby
def gpu()

```

**Returns**:

- `Float` - The GPU quota for the sandbox

#### memory()

```ruby
def memory()

```

**Returns**:

- `Float` - The memory quota for the sandbox

#### disk()

```ruby
def disk()

```

**Returns**:

- `Float` - The disk quota for the sandbox

#### state()

```ruby
def state()

```

**Returns**:

- `DaytonaApiClient:SandboxState` - The state of the sandbox

#### desired_state()

```ruby
def desired_state()

```

**Returns**:

- `DaytonaApiClient:SandboxDesiredState` - The desired state of the sandbox

#### error_reason()

```ruby
def error_reason()

```

**Returns**:

- `String` - The error reason of the sandbox

#### backup_state()

```ruby
def backup_state()

```

**Returns**:

- `String` - The state of the backup

#### backup_created_at()

```ruby
def backup_created_at()

```

**Returns**:

- `String` - The creation timestamp of the last backup

#### auto_stop_interval()

```ruby
def auto_stop_interval()

```

**Returns**:

- `Float` - Auto-stop interval in minutes (0 means disabled)

#### auto_archive_interval()

```ruby
def auto_archive_interval()

```

**Returns**:

- `Float` - Auto-archive interval in minutes

#### auto_delete_interval()

```ruby
def auto_delete_interval()

```

(negative value means disabled, 0 means delete immediately upon stopping)

**Returns**:

- `Float` - Auto-delete interval in minutes

#### volumes()

```ruby
def volumes()

```

**Returns**:

- `Array\<DaytonaApiClient:SandboxVolume\>` - Array of volumes attached to the sandbox

#### build_info()

```ruby
def build_info()

```

**Returns**:

- `DaytonaApiClient:BuildInfo` - Build information for the sandbox

#### created_at()

```ruby
def created_at()

```

**Returns**:

- `String` - The creation timestamp of the sandbox

#### updated_at()

```ruby
def updated_at()

```

**Returns**:

- `String` - The last update timestamp of the sandbox

#### daemon_version()

```ruby
def daemon_version()

```

**Returns**:

- `String` - The version of the daemon running in the sandbox

#### code_toolbox()

```ruby
def code_toolbox()

```

**Returns**:

- `Daytona:SandboxPythonCodeToolbox, Daytona:SandboxTsCodeToolbox`

#### config()

```ruby
def config()

```

**Returns**:

- `Daytona:Config`

#### sandbox_api()

```ruby
def sandbox_api()

```

**Returns**:

- `DaytonaApiClient:SandboxApi`

#### process()

```ruby
def process()

```

**Returns**:

- `Daytona:Process`

#### fs()

```ruby
def fs()

```

**Returns**:

- `Daytona:FileSystem`

#### git()

```ruby
def git()

```

**Returns**:

- `Daytona:Git`

#### computer_use()

```ruby
def computer_use()

```

**Returns**:

- `Daytona:ComputerUse`

#### code_interpreter()

```ruby
def code_interpreter()

```

**Returns**:

- `Daytona:CodeInterpreter`

#### archive()

```ruby
def archive()

```

Archives the sandbox, making it inactive and preserving its state. When sandboxes are
archived, the entire filesystem state is moved to cost-effective object storage, making it
possible to keep sandboxes available for an extended period. The tradeoff between archived
and stopped states is that starting an archived sandbox takes more time, depending on its size.
Sandbox must be stopped before archiving.

**Returns**:

- `void`

#### auto_archive_interval=()

```ruby
def auto_archive_interval=(interval)

```

Sets the auto-archive interval for the Sandbox.
The Sandbox will automatically archive after being continuously stopped for the specified interval.

**Parameters**:

- `interval` _Integer_ -

**Returns**:

- `Integer`

**Raises**:

- `Daytona:Sdk:Error` -

#### auto_delete_interval=()

```ruby
def auto_delete_interval=(interval)

```

Sets the auto-delete interval for the Sandbox.
The Sandbox will automatically delete after being continuously stopped for the specified interval.

**Parameters**:

- `interval` _Integer_ -

**Returns**:

- `Integer`

**Raises**:

- `Daytona:Sdk:Error` -

#### auto_stop_interval=()

```ruby
def auto_stop_interval=(interval)

```

Sets the auto-stop interval for the Sandbox.
The Sandbox will automatically stop after being idle (no new events) for the specified interval.
Events include any state changes or interactions with the Sandbox through the SDK.
Interactions using Sandbox Previews are not included.

**Parameters**:

- `interval` _Integer_ -

**Returns**:

- `Integer`

**Raises**:

- `Daytona:Sdk:Error` -

#### create_ssh_access()

```ruby
def create_ssh_access(expires_in_minutes)

```

Creates an SSH access token for the sandbox.

**Parameters**:

- `expires_in_minutes` _Integer_ - TThe number of minutes the SSH access token will be valid for

**Returns**:

- `DaytonaApiClient:SshAccessDto`

#### delete()

```ruby
def delete()

```

**Returns**:

- `void`

#### get_user_home_dir()

```ruby
def get_user_home_dir()

```

Gets the user's home directory path for the logged in user inside the Sandbox.

**Returns**:

- `String` - The absolute path to the Sandbox user's home directory for the logged in user

**Examples:**

```ruby
user_home_dir = sandbox.get_user_home_dir
puts "Sandbox user home: #{user_home_dir}"

```

#### get_work_dir()

```ruby
def get_work_dir()

```

Gets the working directory path inside the Sandbox.

**Returns**:

- `String` - The absolute path to the Sandbox working directory. Uses the WORKDIR specified
in the Dockerfile if present, or falling back to the user's home directory if not.

**Examples:**

```ruby
work_dir = sandbox.get_work_dir
puts "Sandbox working directory: #{work_dir}"

```

#### labels=()

```ruby
def labels=(labels)

```

Sets labels for the Sandbox.

**Parameters**:

- `labels` _Hash\<String, String\>_ -

**Returns**:

- `Hash\<String, String\>`

#### preview_url()

```ruby
def preview_url(port)

```

Retrieves the preview link for the sandbox at the specified port. If the port is closed,
it will be opened automatically. For private sandboxes, a token is included to grant access
to the URL.

**Parameters**:

- `port` _Integer_ -

**Returns**:

- `DaytonaApiClient:PortPreviewUrl`

#### create_signed_preview_url()

```ruby
def create_signed_preview_url(port, expires_in_seconds)

```

Creates a signed preview URL for the sandbox at the specified port.

**Parameters**:

- `port` _Integer_ - The port to open the preview link on
- `expires_in_seconds` _Integer, nil_ - The number of seconds the signed preview URL
will be valid for. Defaults to 60 seconds.

**Returns**:

- `DaytonaApiClient:SignedPortPreviewUrl` - The signed preview URL response object

**Examples:**

```ruby
signed_url = sandbox.create_signed_preview_url(3000, 120)
puts "Signed URL: #{signed_url.url}"
puts "Token: #{signed_url.token}"

```

#### expire_signed_preview_url()

```ruby
def expire_signed_preview_url(port, token)

```

Expires a signed preview URL for the sandbox at the specified port.

**Parameters**:

- `port` _Integer_ - The port to expire the signed preview URL on
- `token` _String_ - The token to expire

**Returns**:

- `void`

**Examples:**

```ruby
sandbox.expire_signed_preview_url(3000, "token-value")

```

#### refresh()

```ruby
def refresh()

```

Refresh the Sandbox data from the API.

**Returns**:

- `void`

#### refresh_activity()

```ruby
def refresh_activity()

```

Refreshes the sandbox activity to reset the timer for automated lifecycle management actions.

This method updates the sandbox's last activity timestamp without changing its state.
It is useful for keeping long-running sessions alive while there is still user activity.

**Returns**:

- `void`

**Examples:**

```ruby
sandbox.refresh_activity

```

#### revoke_ssh_access()

```ruby
def revoke_ssh_access(token)

```

Revokes an SSH access token for the sandbox.

**Parameters**:

- `token` _String_ -

**Returns**:

- `void`

#### start()

```ruby
def start(timeout)

```

Starts the Sandbox and waits for it to be ready.

**Parameters**:

- `timeout` _Numeric_ - Maximum wait time in seconds (defaults to 60 s).

**Returns**:

- `void`

#### recover()

```ruby
def recover(timeout)

```

Recovers the Sandbox from a recoverable error and waits for it to be ready.

**Parameters**:

- `timeout` _Numeric_ - Maximum wait time in seconds (defaults to 60 s).

**Returns**:

- `void`

**Examples:**

```ruby
sandbox = daytona.get('my-sandbox-id')
sandbox.recover(timeout: 40)  # Wait up to 40 seconds
puts 'Sandbox recovered successfully'

```

#### stop()

```ruby
def stop(timeout)

```

Stops the Sandbox and waits for it to be stopped.

**Parameters**:

- `timeout` _Numeric_ - Maximum wait time in seconds (defaults to 60 s).

**Returns**:

- `void`

#### resize()

```ruby
def resize(resources, timeout)

```

Resizes the Sandbox resources.

Changes the CPU, memory, or disk allocation for the Sandbox. Resizing a started
sandbox allows increasing CPU and memory. To resize disk or decrease resources,
the sandbox must be stopped first.

**Parameters**:

- `resources` _Daytona:Resources_ - New resource configuration
- `timeout` _Numeric_ - Maximum wait time in seconds (defaults to 60 s)

**Returns**:

- `void`

**Raises**:

- `Sdk:Error` -

**Examples:**

```ruby
sandbox.resize(Daytona::Resources.new(cpu: 4, memory: 8))

```

```ruby
sandbox.stop
sandbox.resize(Daytona::Resources.new(cpu: 2, memory: 4, disk: 30))

```

#### wait_for_resize_complete()

```ruby
def wait_for_resize_complete(_timeout)

```

Waits for the Sandbox resize operation to complete.
Polls the Sandbox status until the state is no longer 'resizing'.

**Parameters**:

- `timeout` _Numeric_ - Maximum wait time in seconds (defaults to 60 s)

**Returns**:

- `void`

#### create_lsp_server()

```ruby
def create_lsp_server(language_id:, path_to_project:)

```

Creates a new Language Server Protocol (LSP) server instance.
The LSP server provides language-specific features like code completion,
diagnostics, and more.

**Parameters**:

- `language_id` _Symbol_ - The language server type (e.g., Daytona::LspServer::Language::PYTHON)
- `path_to_project` _String_ - Path to the project root directory. Relative paths are resolved
based on the sandbox working directory.

**Returns**:

- `Daytona:LspServer`

#### validate_ssh_access()

```ruby
def validate_ssh_access(token)

```

Validates an SSH access token for the sandbox.

**Parameters**:

- `token` _String_ -

**Returns**:

- `DaytonaApiClient:SshAccessValidationDto`

#### wait_for_sandbox_start()

```ruby
def wait_for_sandbox_start(_timeout)

```

Waits for the Sandbox to reach the 'started' state. Polls the Sandbox status until it
reaches the 'started' state or encounters an error.

**Parameters**:

- `timeout` _Numeric_ - Maximum wait time in seconds (defaults to 60 s).

**Returns**:

- `void`

#### wait_for_sandbox_stop()

```ruby
def wait_for_sandbox_stop(_timeout)

```

Waits for the Sandbox to reach the 'stopped' state. Polls the Sandbox status until it
reaches the 'stopped' state or encounters an error.
Treats destroyed as stopped to cover ephemeral sandboxes that are automatically deleted after stopping.

**Parameters**:

- `timeout` _Numeric_ - Maximum wait time in seconds (defaults to 60 s).

**Returns**:

- `void`
