---
title: 宣言的ビルダー
---

import { TabItem, Tabs } from '@astrojs/starlight/components'

Declarative Builder は、Daytona サンドボックス向けの依存関係を定義するための、強力なコードファースト アプローチを提供します。コンテナレジストリからイメージをインポートする代わりに、Daytona SDK を使ってプログラムからイメージを定義できます。

Declarative Builder システムは、主に次の 2 つのワークフローをサポートします。

1. [**宣言的イメージ**](#declarative-image-building): サンドボックスを作成するときに、さまざまな依存関係を持つイメージを *オンデマンドで* ビルドする
2. [**事前ビルド済みスナップショット**](#creating-pre-built-snapshots): 複数のサンドボックス間で共有できる、*すぐに使える* [スナップショット](/docs/snapshots) を作成して登録する

## 宣言的イメージをビルドする \{#build-declarative-images\}

Daytona では、サンドボックスを作成する際に、その場で宣言的イメージを作成できるオプションを用意しています。これは、個別のスナップショットを作成することなく、素早く反復開発を行いたい場合に最適です。

宣言的イメージは 24 時間キャッシュされ、同じスクリプトを実行する際に自動的に再利用されます。そのため、同じランナー上での後続の実行はほぼ瞬時に完了します。

<Tabs syncKey="language">
  <TabItem label="Python" icon="seti:python">
    ```python
    # Python パッケージを含む宣言的イメージを定義
    declarative_image = (
      Image.debian_slim("3.12")
      .pip_install(["requests", "pytest"])
      .workdir("/home/daytona")
    )

    # 宣言的イメージで新しいサンドボックスを作成し、ビルドログをストリームする
    sandbox = daytona.create(
      CreateSandboxFromImageParams(image=declarative_image),
      timeout=0,
      on_snapshot_create_logs=print,
    )
    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    // Python パッケージを含む宣言的イメージを定義
    const declarativeImage = Image.debianSlim('3.12')
      .pipInstall(['requests', 'pytest'])
      .workdir('/home/daytona')

    // 宣言的イメージで新しいサンドボックスを作成し、ビルドログをストリームする
    const sandbox = await daytona.create(
      {
        image: declarativeImage,
      },
      {
        timeout: 0,
        onSnapshotCreateLogs: console.log,
      }
    )
    ```
  </TabItem>

  <TabItem label="Ruby" icon="seti:ruby">
    ```ruby
    # Python パッケージを含むシンプルな宣言的イメージを定義
    declarative_image = Daytona::Image
      .debian_slim('3.12')
      .pip_install(['requests', 'pytest'])
      .workdir('/home/daytona')

    # 宣言的イメージで新しいサンドボックスを作成し、ビルドログをストリームする
    sandbox = daytona.create(
      Daytona::CreateSandboxFromImageParams.new(image: declarative_image),
      timeout: 0,
      on_snapshot_create_logs: proc { |chunk| puts chunk }
    )
    ```
  </TabItem>
</Tabs>

詳細については、[Python SDK](/docs/ja/python-sdk/)、[TypeScript SDK](/docs/ja/typescript-sdk/)、および [Ruby SDK](/docs/ja/ruby-sdk/) のリファレンスを参照してください。

> [**CreateSandboxFromImageParams (Python SDK)**](/docs/python-sdk/sync/daytona#createsandboxfromimageparams)
>
> [**CreateSandboxFromImageParams (TypeScript SDK)**](/docs/typescript-sdk/daytona#createsandboxfromimageparams)
>
> [**CreateSandboxFromImageParams (Ruby SDK)**](/docs/ruby-sdk/daytona#createsandboxfromimageparams)

:::note
宣言的ビルダーを使用する際は、次のベストプラクティスに従ってください。

* **レイヤー最適化**: 関連する処理をまとめて、Docker レイヤー数を最小限に抑える

* **キャッシュ活用**: 同一のビルドコマンドとコンテキストはキャッシュされ、後続のビルドはほぼ瞬時に完了する

* **セキュリティ**: アプリケーションのワークロード用に非 root ユーザーを作成する

* **リソース効率**: 適切な場合は slim ベースイメージを使用する

* **コンテキストの最小化**: ビルドコンテキストには必要なファイルのみを含める
  :::

## 事前ビルド済みスナップショットを作成する \{#create-pre-built-snapshots\}

Daytona では、複数のサンドボックスで再利用できる [事前ビルド済みスナップショットを作成](/docs/snapshots#create-snapshots)する機能を提供しています。

スナップショットは [Daytona Dashboard ↗](https://app.daytona.io/dashboard/snapshots) 上に表示され、永続的にキャッシュされるため、再ビルドなしで即時に利用できます。

<Tabs syncKey="language">
  <TabItem label="Python" icon="seti:python">
    ```python
    # Python データサイエンス用イメージを作成
    snapshot_name = "data-science-snapshot"

    image = (
      Image.debian_slim("3.12")
      .pip_install(["pandas", "numpy"])
      .workdir("/home/daytona")
    )

    # スナップショットを作成し、ビルドログをストリーミングする
    daytona.snapshot.create(
      CreateSnapshotParams(
        name=snapshot_name,
        image=image,
      ),
    on_logs=print,
    )

    # 事前ビルド済みスナップショットを使って新しいサンドボックスを作成
    sandbox = daytona.create(
    CreateSandboxFromSnapshotParams(snapshot=snapshot_name)
    )

    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    // Python データサイエンス用イメージを作成
    const snapshotName = 'data-science-snapshot'

    const image = Image.debianSlim('3.12')
      .pipInstall(['pandas', 'numpy'])
      .workdir('/home/daytona')

    // スナップショットを作成し、ビルドログをストリーミングする
    await daytona.snapshot.create(
      {
        name: snapshotName,
        image,
      },
      {
        onLogs: console.log,
      }
    )

    // 事前ビルド済みスナップショットを使って新しいサンドボックスを作成
    const sandbox = await daytona.create({
      snapshot: snapshotName,
    })
    ```
  </TabItem>

  <TabItem label="Ruby" icon="seti:ruby">
    ```ruby
    # シンプルな Python データサイエンス用イメージを作成
    snapshot_name = 'data-science-snapshot'

    image = Daytona::Image
      .debian_slim('3.12')
      .pip_install(['pandas', 'numpy'])
      .workdir('/home/daytona')

    # スナップショットを作成し、ビルドログをストリーミングする
    daytona.snapshot.create(
      Daytona::CreateSnapshotParams.new(
        name: snapshot_name,
        image: image
      ),
      on_logs: proc { |chunk| puts chunk }
    )

    # 事前ビルド済みスナップショットを使って新しいサンドボックスを作成
    sandbox = daytona.create(
      Daytona::CreateSandboxFromSnapshotParams.new(snapshot: snapshot_name)
    )
    ```
  </TabItem>
</Tabs>

詳細については、[Python SDK](/docs/ja/python-sdk/)、[TypeScript SDK](/docs/ja/typescript-sdk/)、および [Ruby SDK](/docs/ja/ruby-sdk/) のリファレンスを参照してください。

> [**CreateSnapshotParams (Python SDK)**](/docs/python-sdk/sync/snapshot#createsnapshotparams)
>
> [**CreateSnapshotParams (TypeScript SDK)**](/docs/typescript-sdk/snapshot#createsnapshotparams)
>
> [**CreateSnapshotParams (Ruby SDK)**](/docs/ruby-sdk/snapshot#createsnapshotparams)

## イメージの構成 \{#image-configuration\}

Daytona では、Daytona SDK を使用してイメージをプログラムで定義するためのオプションが提供されています。ベースイメージの指定、パッケージのインストール、ファイルの追加、環境変数の設定などを行えます。

完全な API リファレンスとメソッドシグネチャについては、[Python](/docs/python-sdk/common/image) および [TypeScript](/docs/typescript-sdk/image) の SDK リファレンスを参照してください。

### ベースイメージの選択 \{#base-image-selection\}

Daytona では、ベースイメージを選択するオプションを提供しています。次のスニペットは、ベースイメージの選択と構成方法を示します：

<Tabs syncKey="language">
  <TabItem label="Python" icon="seti:python">
    ```python
    # ベースイメージから作成
    image = Image.base("python:3.12-slim-bookworm")

    # Python 3.12 を含む Debian slim イメージを使用
    image = Image.debian_slim("3.12")
    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    // ベースイメージから作成
    const image = Image.base('python:3.12-slim-bookworm')

    // Python 3.12 を含む Debian slim イメージを使用
    const image = Image.debianSlim('3.12')
    ```
  </TabItem>

  <TabItem label="Ruby" icon="seti:ruby">
    ```ruby
    # ベースイメージから作成
    image = Daytona::Image.base('python:3.12-slim-bookworm')

    # Python 3.12 を含む Debian slim イメージを使用
    image = Daytona::Image.debian_slim('3.12')
    ```
  </TabItem>
</Tabs>

詳細については、[Python SDK](/docs/ja/python-sdk/) および [TypeScript SDK](/docs/ja/typescript-sdk/) のリファレンスを参照してください:

> [**base (Python SDK)**](/docs/python-sdk/common/image#imagebase)
>
> [**base (TypeScript SDK)**](/docs/typescript-sdk/image#base)
>
> [**debian&#95;slim (Python SDK)**](/docs/python-sdk/common/image#imagedebian_slim)
>
> [**debianSlim (TypeScript SDK)**](/docs/typescript-sdk/image#debianslim)

### パッケージ管理 \{#package-management\}

Daytona では、イメージにパッケージおよび依存関係をインストールするための機能を提供しています。
次のスニペットは、イメージにパッケージと依存関係をインストールする方法を示しています。

<Tabs syncKey="language">
  <TabItem label="Python" icon="seti:python">
    ```python
    # pip パッケージを追加
    image = Image.debian_slim("3.12").pip_install("requests", "pandas")

    # requirements.txt からインストール
    image = Image.debian_slim("3.12").pip_install_from_requirements("requirements.txt")

    # pyproject.toml からインストール（オプション依存関係あり）
    image = Image.debian_slim("3.12").pip_install_from_pyproject("pyproject.toml", optional_dependencies=["dev"])

    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    // pip パッケージを追加
    const image = Image.debianSlim('3.12').pipInstall(['requests', 'pandas'])

    // requirements.txt からインストール
    const image = Image.debianSlim('3.12').pipInstallFromRequirements('requirements.txt')

    // pyproject.toml からインストール（オプション依存関係あり）
    const image = Image.debianSlim('3.12').pipInstallFromPyproject('pyproject.toml', {
      optionalDependencies: ['dev']
    })
    ```
  </TabItem>

  <TabItem label="Ruby" icon="seti:ruby">
    ```ruby
    # pip パッケージを追加
    image = Daytona::Image.debian_slim('3.12').pip_install(['requests', 'pandas'])

    # requirements.txt からインストール
    image = Daytona::Image.debian_slim('3.12').pip_install_from_requirements('requirements.txt')

    # pyproject.toml からインストール（オプション依存関係あり）
    image = Daytona::Image.debian_slim('3.12').pip_install_from_pyproject('pyproject.toml', 
      optional_dependencies: ['dev']
    )
    ```
  </TabItem>
</Tabs>

詳しくは、[Python SDK](/docs/ja/python-sdk/) および [TypeScript SDK](/docs/ja/typescript-sdk/) のリファレンスを参照してください。

> [**pip&#95;install (Python SDK)**](/docs/python-sdk/common/image#imagepip_install)
>
> [**pipInstall (TypeScript SDK)**](/docs/typescript-sdk/image#pipinstall)
>
> [**pip&#95;install&#95;from&#95;requirements (Python SDK)**](/docs/python-sdk/common/image#imagepip_install_from_requirements)
>
> [**pipInstallFromRequirements (TypeScript SDK)**](/docs/typescript-sdk/image#pipinstallfromrequirements)
>
> [**pip&#95;install&#95;from&#95;pyproject (Python SDK)**](/docs/python-sdk/common/image#imagepip_install_from_pyproject)
>
> [**pipInstallFromPyproject (TypeScript SDK)**](/docs/typescript-sdk/image#pipinstallfrompyproject)

### ファイルシステム操作 \{#file-system-operations\}

Daytona では、イメージにファイルやディレクトリを追加するための機能を提供しています。
以下のスニペットでは、イメージにファイルやディレクトリを追加する方法を示します。

<Tabs syncKey="language">
  <TabItem label="Python" icon="seti:python">
    ```python
    # ローカルファイルを追加
    image = Image.debian_slim("3.12").add_local_file("package.json", "/home/daytona/package.json")

    # ローカルディレクトリを追加
    image = Image.debian_slim("3.12").add_local_dir("src", "/home/daytona/src")
    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    // ローカルファイルを追加
    const image = Image.debianSlim('3.12').addLocalFile('package.json', '/home/daytona/package.json')

    // ローカルディレクトリを追加
    const image = Image.debianSlim('3.12').addLocalDir('src', '/home/daytona/src')
    ```
  </TabItem>

  <TabItem label="Ruby" icon="seti:ruby">
    ```ruby
    # ローカルファイルを追加
    image = Daytona::Image.debian_slim('3.12').add_local_file('package.json', '/home/daytona/package.json')

    # ローカルディレクトリを追加
    image = Daytona::Image.debian_slim('3.12').add_local_dir('src', '/home/daytona/src')
    ```
  </TabItem>
</Tabs>

詳細については、[Python SDK](/docs/ja/python-sdk/) および [TypeScript SDK](/docs/ja/typescript-sdk/) のリファレンスを参照してください:

> [**add&#95;local&#95;file (Python SDK)**](/docs/python-sdk/common/image#imageadd_local_file)
>
> [**add&#95;local&#95;dir (Python SDK)**](/docs/python-sdk/common/image#imageadd_local_dir)
>
> [**addLocalFile (TypeScript SDK)**](/docs/typescript-sdk/image#addlocalfile)
>
> [**addLocalDir (TypeScript SDK)**](/docs/typescript-sdk/image#addlocaldir)

### 環境設定 \{#environment-configuration\}

Daytona では、環境変数と作業ディレクトリを設定するためのオプションを提供しています。以下のスニペットは、環境変数と作業ディレクトリを設定する方法を示しています。

<Tabs syncKey="language">
  <TabItem label="Python" icon="seti:python">
    ```python
    # 環境変数を設定
    image = Image.debian_slim("3.12").env({"PROJECT_ROOT": "/home/daytona"})

    # 作業ディレクトリを設定
    image = Image.debian_slim("3.12").workdir("/home/daytona")
    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    // 環境変数を設定
    const image = Image.debianSlim('3.12').env({ PROJECT_ROOT: '/home/daytona' })

    // 作業ディレクトリを設定
    const image = Image.debianSlim('3.12').workdir('/home/daytona')
    ```
  </TabItem>

  <TabItem label="Ruby" icon="seti:ruby">
    ```ruby
    # 環境変数を設定
    image = Daytona::Image.debian_slim('3.12').env('PROJECT_ROOT': '/home/daytona')

    # 作業ディレクトリを設定
    image = Daytona::Image.debian_slim('3.12').workdir('/home/daytona')
    ```
  </TabItem>
</Tabs>

詳細については、[Python SDK](/docs/ja/python-sdk/) および [TypeScript SDK](/docs/ja/typescript-sdk/) のリファレンスを参照してください。

> [**env（Python SDK）**](/docs/python-sdk/common/image#imageenv)
>
> [**workdir（Python SDK）**](/docs/python-sdk/common/image#imageworkdir)
>
> [**env（TypeScript SDK）**](/docs/typescript-sdk/image#env)
>
> [**workdir（TypeScript SDK）**](/docs/typescript-sdk/image#workdir)

### コマンドとエントリポイント \{#commands-and-entrypoints\}

Daytona では、ビルド時にコマンドを実行し、コンテナの起動時の挙動を設定するためのオプションを提供しています。\
次のスニペットは、ビルド時にコマンドを実行し、コンテナの起動時の挙動を設定する方法を示しています:

<Tabs syncKey="language">
  <TabItem label="Python" icon="seti:python">
    ```python
    # ビルド時にシェルコマンドを実行
    image = Image.debian_slim("3.12").run_commands(
        'apt-get update && apt-get install -y git',
        'groupadd -r daytona && useradd -r -g daytona -m daytona',
        'mkdir -p /home/daytona/workspace'
    )

    # エントリポイントを設定
    image = Image.debian_slim("3.12").entrypoint(["/bin/bash"])

    # デフォルトのコマンドを設定
    image = Image.debian_slim("3.12").cmd(["/bin/bash"])
    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    // ビルド時にシェルコマンドを実行
    const image = Image.debianSlim('3.12').runCommands(
        'apt-get update && apt-get install -y git',
        'groupadd -r daytona && useradd -r -g daytona -m daytona',
        'mkdir -p /home/daytona/workspace'
    )

    // エントリポイントを設定
    const image = Image.debianSlim('3.12').entrypoint(['/bin/bash'])

    // デフォルトのコマンドを設定
    const image = Image.debianSlim('3.12').cmd(['/bin/bash'])
    ```
  </TabItem>

  <TabItem label="Ruby" icon="seti:ruby">
    ```ruby
    # ビルド時にシェルコマンドを実行
    image = Daytona::Image.debian_slim('3.12').run_commands(
      'apt-get update && apt-get install -y git',
      'groupadd -r daytona && useradd -r -g daytona -m daytona',
      'mkdir -p /home/daytona/workspace'
    )

    # エントリポイントを設定
    image = Daytona::Image.debian_slim('3.12').entrypoint(['/bin/bash'])

    # デフォルトのコマンドを設定
    image = Daytona::Image.debian_slim('3.12').cmd(['/bin/bash'])
    ```
  </TabItem>
</Tabs>

詳細については、[Python SDK](/docs/ja/python-sdk/) と [TypeScript SDK](/docs/ja/typescript-sdk/) のリファレンスを参照してください:

> [**run&#95;commands (Python SDK)**](/docs/python-sdk/common/image#imagerun_commands)
>
> [**entrypoint (Python SDK)**](/docs/python-sdk/common/image#imageentrypoint)
>
> [**cmd (Python SDK)**](/docs/python-sdk/common/image#imagecmd)
>
> [**runCommands (TypeScript SDK)**](/docs/typescript-sdk/image#runcommands)
>
> [**entrypoint (TypeScript SDK)**](/docs/typescript-sdk/image#entrypoint)
>
> [**cmd (TypeScript SDK)**](/docs/typescript-sdk/image#cmd)

### Dockerfile の統合 \{#dockerfile-integration\}

Daytona では、既存の Dockerfile を取り込んだり、カスタムの Dockerfile コマンドを追加したりするためのオプションを提供しています。
次のスニペットは、既存の Dockerfile を取り込む方法と、カスタムの Dockerfile コマンドを追加する方法を示しています:

<Tabs syncKey="language">
  <TabItem label="Python" icon="seti:python">
    ```python
    # カスタムの Dockerfile コマンドを追加
    image = Image.debian_slim("3.12").dockerfile_commands(["RUN echo 'Hello, world!'"])

    # 既存の Dockerfile を使用
    image = Image.from_dockerfile("Dockerfile")

    # 既存の Dockerfile を拡張
    image = Image.from_dockerfile("app/Dockerfile").pip_install(["numpy"])
    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    // カスタムの Dockerfile コマンドを追加
    const image = Image.debianSlim('3.12').dockerfileCommands(['RUN echo "Hello, world!"'])

    // 既存の Dockerfile を使用
    const image = Image.fromDockerfile('Dockerfile')

    // 既存の Dockerfile を拡張
    const image = Image.fromDockerfile("app/Dockerfile").pipInstall(['numpy'])
    ```
  </TabItem>
</Tabs>

詳細については、[Python SDK](/docs/ja/python-sdk/) および [TypeScript SDK](/docs/ja/typescript-sdk/) のリファレンスを参照してください:

> [**dockerfile&#95;commands (Python SDK)**](/docs/python-sdk/common/image#imagedockerfile_commands)
>
> [**from&#95;dockerfile (Python SDK)**](/docs/python-sdk/common/image#imagefrom_dockerfile)
>
> [**dockerfileCommands (TypeScript SDK)**](/docs/typescript-sdk/image#dockerfilecommands)
>
> [**fromDockerfile (TypeScript SDK)**](/docs/typescript-sdk/image#fromdockerfile)