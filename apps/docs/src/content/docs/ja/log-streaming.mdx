---
title: ログストリーミング
---

サンドボックスで長時間実行されるプロセスを扱う際、**リアルタイム**でログにアクセスして処理したい場面がよくあります。

Daytona SDK は次の両方をサポートしています:

* `Fetching log snapshot` — ある時点までのログをまとめて取得。
* `Log streaming` — プロセスの実行中に生成されるログをそのままストリーミング。

このガイドでは、非同期モードと同期モードの両方でのログストリーミングの使い方を解説します。
リアルタイムストリーミングは、**デバッグ**、**監視**、および**オブザーバビリティツール**との統合に特に有用です。

:::note
バージョン `0.27.0` 以降では、セッションコマンドのログを **stdout** と **stderr** の2つの独立したストリームで取得できます。
:::

## コールバックでログをストリーミングする \{#streaming-logs-with-callbacks\}

サンドボックス内のプロセスが大規模なシステムの一部で、長時間（または無期限に）実行される想定の場合は、
システムの他の部分を動かし続けながら、ログを**バックグラウンド**で非同期処理できます。

これは次の用途に最適です:

* 継続的な監視
* 長時間実行ジョブのデバッグ
* ライブのログ転送や可視化

import { TabItem, Tabs } from '@astrojs/starlight/components'

<Tabs syncKey="language">
  <TabItem label="Python" icon="seti:python">
    ```python
    import asyncio
    from daytona import Daytona, SessionExecuteRequest

    async def main():
      daytona = Daytona()
      sandbox = daytona.create()

      session_id = "streaming-session"
      sandbox.process.create_session(session_id)

      command = sandbox.process.execute_session_command(
        session_id,
        SessionExecuteRequest(
          command='for i in {1..5}; do echo "Step $i"; echo "Error $i" >&2; sleep 1; done',
          var_async=True,
        ),
      )

      # 標準出力・標準エラーを別々のコールバックでストリーミング
      logs_task = asyncio.create_task(
        sandbox.process.get_session_command_logs_async(
          session_id,
          command.cmd_id,
          lambda stdout: print(f"[STDOUT]: {stdout}"),
          lambda stderr: print(f"[STDERR]: {stderr}"),
        )
      )

      print("ログをストリーミングしつつ処理を継続します...")
      await asyncio.sleep(3)
      print("その他の処理が完了しました。")

      # ログのストリーミング完了を待機
      await logs_task

      sandbox.delete()
      
    if __name__ == "__main__":
        asyncio.run(main())

    ```
  </TabItem>

  <TabItem label="Typescript" icon="seti:typescript">
    ```typescript
    import { Daytona, SessionExecuteRequest } from '@daytonaio/sdk'

    async function main() {
      const daytona = new Daytona()
      const sandbox = await daytona.create()
      const sessionId = "exec-session-1"
      await sandbox.process.createSession(sessionId)

      const command = await sandbox.process.executeSessionCommand(
        sessionId,
        {
          command: 'for i in {1..5}; do echo "Step $i"; echo "Error $i" >&2; sleep 1; done',
          runAsync: true,
        },
      )

      // 標準出力・標準エラーを別々のコールバックでストリーミング
      const logsTask = sandbox.process.getSessionCommandLogs(
        sessionId,
        command.cmdId!,
        (stdout) => console.log('[STDOUT]:', stdout),
        (stderr) => console.log('[STDERR]:', stderr),
      )

      console.log('ログをストリーミングしつつ処理を継続します...')
      await new Promise((resolve) => setTimeout(resolve, 3000))
      console.log('その他の処理が完了しました。')

      // ログのストリーミング完了を待機
      await logsTask

      await sandbox.delete()
    }

    main()
    ```
  </TabItem>
</Tabs>

## 既存のログをすべて取得する \{#retrieve-all-existing-logs\}

コマンドの実行時間が予測できる場合、あるいはバックグラウンドで実行する必要はないが
定期的に既存のログをすべて確認したい場合は、次の例で現時点までのログを取得できます。

<Tabs syncKey="language">
  <TabItem label="Python" icon="seti:python">
    ```python
    import time
    from daytona import Daytona, SessionExecuteRequest

    daytona = Daytona()
    sandbox = daytona.create()
    session_id = "exec-session-1"
    sandbox.process.create_session(session_id)

    # ブロッキングなコマンドを実行して結果を待つ
    command = sandbox.process.execute_session_command(
      session_id, SessionExecuteRequest(command="echo 'Hello from stdout' && echo 'Hello from stderr' >&2")
    )
    print(f"[STDOUT]: {command.stdout}")
    print(f"[STDERR]: {command.stderr}")
    print(f"[OUTPUT]: {command.output}")

    # あるいはバックグラウンドでコマンドを実行し、後でログを取得する
    command = sandbox.process.execute_session_command(
      session_id, 
      SessionExecuteRequest(
        command='while true; do if (( RANDOM % 2 )); then echo "All good at $(date)"; else echo "Oops, an error at $(date)" >&2; fi; sleep 1; done',
        run_async=True
      )
    )
    time.sleep(5)
    # 現時点までのログを取得
    logs = sandbox.process.get_session_command_logs(session_id, command.cmd_id)
    print(f"[STDOUT]: {logs.stdout}")
    print(f"[STDERR]: {logs.stderr}")
    print(f"[OUTPUT]: {logs.output}")

    sandbox.delete()
    ```
  </TabItem>

  <TabItem label="Typescript" icon="seti:typescript">
    ```typescript
    import { Daytona, SessionExecuteRequest } from '@daytonaio/sdk'

    async function main() {
      const daytona = new Daytona()
      const sandbox = await daytona.create()
      const sessionId = "exec-session-1"
      await sandbox.process.createSession(sessionId)

      // ブロッキングなコマンドを実行して結果を待つ
      const command = await sandbox.process.executeSessionCommand(
        sessionId,
        {
          command: 'echo "Hello from stdout" && echo "Hello from stderr" >&2',
        },
      )
      console.log(`[STDOUT]: ${command.stdout}`)
      console.log(`[STDERR]: ${command.stderr}`)
      console.log(`[OUTPUT]: ${command.output}`)

      // あるいはバックグラウンドでコマンドを実行し、後でログを取得する
      const command2 = await sandbox.process.executeSessionCommand(
        sessionId,
        {
          command: 'while true; do if (( RANDOM % 2 )); then echo "All good at $(date)"; else echo "Oops, an error at $(date)" >&2; fi; sleep 1; done',
          runAsync: true,
        },
      )
      await new Promise((resolve) => setTimeout(resolve, 5000))
      # 現時点までのログを取得
      const logs = await sandbox.process.getSessionCommandLogs(sessionId, command2.cmdId!)
      console.log(`[STDOUT]: ${logs.stdout}`)
      console.log(`[STDERR]: ${logs.stderr}`)
      console.log(`[OUTPUT]: ${logs.output}`)

      await sandbox.delete()
    }

    main()
    ```
  </TabItem>
</Tabs>