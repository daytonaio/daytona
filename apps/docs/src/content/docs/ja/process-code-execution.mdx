---
title: プロセスとコード実行
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

Daytona SDKは、サンドボックス内の`process`モジュールを通じて、強力なプロセスとコード実行の機能を提供します。本ガイドでは、利用可能なすべてのプロセス操作とベストプラクティスを紹介します。

## コード実行 \{#code-execution\}

Daytona SDK は、ステートレスおよびステートフルの両方のコード実行フローをサポートしています。ステートレス実行では `process` モジュールを使用し、
Python、TypeScript、JavaScript など複数の言語に対応しています。ステートフルなコードインタープリターは、呼び出し間で変数やインポートを保持し、
現時点では Python のみに対応しています。

:::note

* ステートレス実行は、作成時に選択したサンドボックスの言語を継承します。詳しくは [Basic Sandbox Creation](/docs/ja/sandboxes/#basic-sandbox-creation) を参照してください。
* ステートフルインタープリターは Python のみをサポートします。
  :::

### ステートレス実行 \{#stateless-execution\}

各スニペットが互いに独立している場合には、ステートレス実行を使用します。呼び出しのたびに、クリーンな状態のインタープリタから開始されます。

<Tabs syncKey="language">
  <TabItem label="Python" icon="seti:python">
    ```python
    # Python コードを実行
    response = sandbox.process.code_run('''
    def greet(name):
        return f"Hello, {name}!"

    print(greet("Daytona"))
    ''')

    print(response.result)
    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    // TypeScript コードを実行
    let response = await sandbox.process.codeRun(`
    function greet(name: string): string {
        return \`Hello, \${name}!\`;
    }

    console.log(greet("Daytona"));
    `);
    console.log(response.result);

    // argv と環境変数を指定してコードを実行
    response = await sandbox.process.codeRun(
        `
        console.log(\`Hello, \${process.argv[2]}!\`);
        console.log(\`FOO: \${process.env.FOO}\`);
        `,
        { 
          argv: ["Daytona"],
          env: { FOO: "BAR" }
        }
    );
    console.log(response.result);

    // タイムアウトを指定してコードを実行
    response = await sandbox.process.codeRun(
        'setTimeout(() => console.log("Done"), 2000);',
        undefined,
        5000
    );
    console.log(response.result);
    ```
  </TabItem>

  <TabItem label="Ruby" icon="seti:ruby">
    ```ruby
    # Python コードを実行
    response = sandbox.process.code_run(code: <<~PYTHON)
      def greet(name):
          return f"Hello, {name}!"
      
      print(greet("Daytona"))
    PYTHON

    puts response.result

    # 環境変数を指定してコードを実行
    response = sandbox.process.code_run(
      code: 'import os; print(f"FOO: {os.environ.get(\'FOO\')}")',
      env: { 'FOO' => 'BAR' }
    )
    puts response.result

    # タイムアウトを指定してコードを実行
    response = sandbox.process.code_run(
      code: 'import time; time.sleep(2); print("Done")',
      timeout: 5
    )
    puts response.result
    ```
  </TabItem>
</Tabs>

詳細は [code&#95;run (Python SDK)](/docs/python-sdk/sync/process/#processcode_run)、[codeRun (TypeScript SDK)](/docs/typescript-sdk/process/#coderun)、[code&#95;run (Ruby SDK)](/docs/ruby-sdk/process/#code_run) を参照してください。

### ステートフルなコードインタープリタ \{#stateful-code-interpreter\}

呼び出し間で変数や import の状態を保持する必要がある場合は、サンドボックスの code interpreter を使用します。これにより、次のことが可能です。

* 呼び出し間で状態を保持する共有のデフォルトコンテキスト。
* 特定のワークフロー用に分離されたコンテキストを作成／削除する機能。
* 呼び出しごとに環境変数やタイムアウトを制御する機能。

<Tabs syncKey="language">
  <TabItem label="Python" icon="seti:python">
    ```python
    from daytona import Daytona, OutputMessage

    def handle_stdout(message: OutputMessage):
        print(f"[STDOUT] {message.output}")

    daytona = Daytona()
    sandbox = daytona.create()

    # Shared default context
    result = sandbox.code_interpreter.run_code(
        "counter = 1\nprint(f'Counter initialized at {counter}')",
        on_stdout=handle_stdout,
    )

    # Isolated context
    ctx = sandbox.code_interpreter.create_context()
    try:
        sandbox.code_interpreter.run_code(
            "value = 'stored in ctx'",
            context=ctx,
        )
        sandbox.code_interpreter.run_code(
            "print(value)",
            context=ctx,
            on_stdout=handle_stdout,
        )
    finally:
        sandbox.code_interpreter.delete_context(ctx)
    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    import { Daytona } from '@daytonaio/sdk'

    const daytona = new Daytona()

    async function main() {
        const sandbox = await daytona.create()

        // Shared default context
        await sandbox.codeInterpreter.runCode(
    `
    counter = 1
    print(f'Counter initialized at {counter}')
    `,
            { onStdout: (msg) => process.stdout.write(`[STDOUT] ${msg.output}`)},
        )

        // Isolated context
        const ctx = await sandbox.codeInterpreter.createContext()
        try {
        await sandbox.codeInterpreter.runCode(
            `value = 'stored in ctx'`,
            { context: ctx },
        )
        await sandbox.codeInterpreter.runCode(
            `print(value)`,
            { context: ctx, onStdout: (msg) => process.stdout.write(`[STDOUT] ${msg.output}`) },
        )
        } finally {
        await sandbox.codeInterpreter.deleteContext(ctx)
        }
    }

    main()
    ```
  </TabItem>
</Tabs>

詳しくは、[code&#95;interpreter (Python SDK)](/docs/python-sdk/sync/code-interpreter)、[codeInterpreter (TypeScript SDK)](/docs/typescript-sdk/code-interpreter)、および [code&#95;interpreter (Ruby SDK)](/docs/ruby-sdk/code-interpreter) を参照してください。

## プロセス実行 \{#process-execution\}

Daytona SDK は、サンドボックス内でシェルコマンドを実行し、バックグラウンドプロセスを管理する機能を提供します。実行時の workDir は、既定で現在のサンドボックスの作業ディレクトリです。Dockerfile に WORKDIR が指定されていればそれが使われ、指定がない場合はユーザーのホームディレクトリが用いられます。例: `workspace/repo` は `/my-work-dir/workspace/repo` を意味しますが、パスを `/` で始めることで絶対パスにして上書きできます。

### コマンドの実行 \{#running-commands\}

Daytona SDK は、Python、TypeScript、Ruby でシェルコマンドを実行する手段を提供します。入力、タイムアウト、環境変数を指定してコマンドを実行できます。

<Tabs syncKey="language">
  <TabItem label="Python" icon="seti:python">
    ```python
    # 任意のシェルコマンドを実行
    response = sandbox.process.exec("ls -la")
    print(response.result)

    # 作業ディレクトリとタイムアウトを設定
    response = sandbox.process.exec("sleep 3", cwd="workspace/src", timeout=5)
    print(response.result)

    # 環境変数を渡す
    response = sandbox.process.exec("echo $CUSTOM_SECRET", env={
            "CUSTOM_SECRET": "DAYTONA"
        }
    )
    print(response.result)

    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript

    // 任意のシェルコマンドを実行
    const response = await sandbox.process.executeCommand("ls -la");
    console.log(response.result);

    // 作業ディレクトリとタイムアウトを設定
    const response2 = await sandbox.process.executeCommand("sleep 3", "workspace/src", undefined, 5);
    console.log(response2.result);

    // 環境変数を渡す
    const response3 = await sandbox.process.executeCommand("echo $CUSTOM_SECRET", ".", {
            "CUSTOM_SECRET": "DAYTONA"
        }
    );
    console.log(response3.result);

    ```
  </TabItem>

  <TabItem label="Ruby" icon="seti:ruby">
    ```ruby

    # 任意のシェルコマンドを実行
    response = sandbox.process.exec(command: 'ls -la')
    puts response.result

    # 作業ディレクトリとタイムアウトを設定
    response = sandbox.process.exec(command: 'sleep 3', cwd: 'workspace/src', timeout: 5)
    puts response.result

    # 環境変数を渡す
    response = sandbox.process.exec(
      command: 'echo $CUSTOM_SECRET',
      env: { 'CUSTOM_SECRET' => 'DAYTONA' }
    )
    puts response.result

    ```
  </TabItem>
</Tabs>

参照: [exec (Python SDK)](/docs/python-sdk/sync/process/#processexec), [executeCommand (TypeScript SDK)](/docs/typescript-sdk/process/#executecommand), [exec (Ruby SDK)](/docs/ruby-sdk/process/#exec)

## セッション（バックグラウンドプロセス） \{#sessions-background-processes\}

Daytona SDK は、サンドボックス内のバックグラウンドプロセスセッションの開始・停止・管理に対応しています。長時間実行されるコマンドを実行し、プロセスの状態を監視し、稼働中のプロセスを一覧できます。

### 長時間実行プロセスの管理 \{#managing-long-running-processes\}

Daytona SDK はバックグラウンドプロセスの開始・停止を行う機能を提供します。長時間実行するコマンドを実行し、プロセスの状態を監視できます。

<Tabs syncKey="language">
  <TabItem label="Python" icon="seti:python">
    ```python
    # セッションで実行されたコマンドを確認
    session = sandbox.process.get_session(session_id)
    print(f"Session {session_id}:")
    for command in session.commands:
        print(f"Command: {command.command}, Exit Code: {command.exit_code}")

    # 実行中のすべてのセッションを一覧表示
    sessions = sandbox.process.list_sessions()
    for session in sessions:
        print(f"PID: {session.id}, Commands: {session.commands}")

    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    // セッションで実行されたコマンドを確認
    const session = await sandbox.process.getSession(sessionId);
    console.log(`Session ${sessionId}:`);
    for (const command of session.commands) {
        console.log(`Command: ${command.command}, Exit Code: ${command.exitCode}`);
    }

    // 実行中のすべてのセッションを一覧表示
    const sessions = await sandbox.process.listSessions();
    for (const session of sessions) {
        console.log(`PID: ${session.id}, Commands: ${session.commands}`);
    }

    ```
  </TabItem>

  <TabItem label="Ruby" icon="seti:ruby">
    ```ruby
    # セッションで実行されたコマンドを確認
    session = sandbox.process.get_session(session_id)
    puts "Session #{session_id}:"
    session.commands.each do |command|
      puts "Command: #{command.command}, Exit Code: #{command.exit_code}"
    end

    # 実行中のすべてのセッションを一覧表示
    sessions = sandbox.process.list_sessions
    sessions.each do |session|
      puts "PID: #{session.id}, Commands: #{session.commands}"
    end

    ```
  </TabItem>
</Tabs>

参照: [get&#95;session (Python SDK)](/docs/python-sdk/sync/process/#processget_session), [list&#95;sessions (Python SDK)](/docs/python-sdk/sync/process/#processlist_sessions), [getSession (TypeScript SDK)](/docs/typescript-sdk/process/#getsession), [listSessions (TypeScript SDK)](/docs/typescript-sdk/process/#listsessions), [get&#95;session (Ruby SDK)](/docs/ruby-sdk/process/#get_session), [list&#95;sessions (Ruby SDK)](/docs/ruby-sdk/process/#list_sessions)

## ベストプラクティス \{#best-practices\}

Daytona SDK でプロセスやコードの実行を扱う際は、次のベストプラクティスに従ってください。

### リソース管理 \{#resource-management\}

プロセス実行時のリソース管理には、次のベストプラクティスが適用されます：

1. 長時間実行の処理には[セッション](#sessions-background-processes)を使用する
2. 実行後はセッションを後片付け（クリーンアップ）する
3. セッションで発生する例外を適切に処理する

<Tabs syncKey="language">
  <TabItem label="Python" icon="seti:python">
    ```python
    # Python - セッションのクリーンアップ
    session_id = "long-running-cmd"
    try:
        sandbox.process.create_session(session_id)
        session = sandbox.process.get_session(session_id)
        # Do work...
    finally:
        sandbox.process.delete_session(session.session_id)
    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    // TypeScript - セッションのクリーンアップ
    const sessionId = "long-running-cmd";
    try {
        await sandbox.process.createSession(sessionId);
        const session = await sandbox.process.getSession(sessionId);
        // Do work...
    } finally {
        await sandbox.process.deleteSession(session.sessionId);
    }
    ```
  </TabItem>

  <TabItem label="Ruby" icon="seti:ruby">
    ```ruby
    # Ruby - セッションのクリーンアップ
    session_id = 'long-running-cmd'
    begin
      sandbox.process.create_session(session_id)
      session = sandbox.process.get_session(session_id)
      # Do work...
    ensure
      sandbox.process.delete_session(session.session_id)
    end
    ```
  </TabItem>
</Tabs>

参照：[create&#95;session（Python SDK）](/docs/python-sdk/sync/process/#processcreate_session)、[delete&#95;session（Python SDK）](/docs/python-sdk/sync/process/#processdelete_session)、[createSession（TypeScript SDK）](/docs/typescript-sdk/process/#createsession)、[deleteSession（TypeScript SDK）](/docs/typescript-sdk/process/#deletesession)、[create&#95;session（Ruby SDK）](/docs/ruby-sdk/process/#create_session)、[delete&#95;session（Ruby SDK）](/docs/ruby-sdk/process/#delete_session)

### エラー処理 \{#error-handling\}

プロセス実行時のエラー処理には、次のベストプラクティスが有効です:

* プロセスで発生した例外を適切に処理する
* デバッグのためにエラーの詳細をログに記録する
* エラー処理には try-catch ブロックを使用する

<Tabs syncKey="language">
  <TabItem label="Python" icon="seti:python">
    ```python
    try:
        response = sandbox.process.code_run("invalid python code")
    except ProcessExecutionError as e:
        print(f"Execution failed: {e}")
        print(f"Exit code: {e.exit_code}")
        print(f"Error output: {e.stderr}")
    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    try {
        const response = await sandbox.process.codeRun("invalid typescript code");
    } catch (e) {
        if (e instanceof ProcessExecutionError) {
            console.error("Execution failed:", e);
            console.error("Exit code:", e.exitCode);
            console.error("Error output:", e.stderr);
        }
    }
    ```
  </TabItem>

  <TabItem label="Ruby" icon="seti:ruby">
    ```ruby
    begin
      response = sandbox.process.code_run(code: 'invalid python code')
    rescue Daytona::ProcessExecutionError => e
      puts "Execution failed: #{e}"
      puts "Exit code: #{e.exit_code}"
      puts "Error output: #{e.stderr}"
    end
    ```
  </TabItem>
</Tabs>

## よくある問題 \{#common-issues\}

プロセスやコード実行に関するよくある問題のトラブルシューティングは、次の表を参照してください。

| 問題 | 解決策 |
|-------|-----------|
| `Process Execution Failed` | ・コマンドの構文を確認する<br />・必要な依存関係を確認する<br />・必要な権限が付与されていることを確認する |
| `Process Timeout` | ・タイムアウト設定を調整する<br />・長時間実行タスクを最適化する<br />・バックグラウンド処理の利用を検討する |
| `Resource Limits` | ・プロセスのメモリ使用量を監視する<br />・プロセスの後処理（クリーンアップ）を適切に行う<br />・適切なリソース制限を設定する |