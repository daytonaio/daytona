---
title: 擬似端末 (PTY)
---

import { TabItem, Tabs } from '@astrojs/starlight/components'

Daytona SDK は、サンドボックス内の `process` モジュールを通じて強力な擬似端末 (PTY) 機能を提供します。PTY セッションを使うと、コマンドの実行、ユーザー入力の処理、端末操作の管理が可能な対話型ターミナルセッションを作成できます。

## PTY とは？ \{#what-is-pty\}

PTY（擬似端末）は、プログラムが実際の端末に接続されているかのようにシェルとやり取りできる仮想端末インターフェースです。Daytona における PTY セッションでは、以下が可能です：

* リアルタイムの入出力による対話的なコマンド実行
* 端末のリサイズ
* kill 操作を含むプロセス管理
* 端末セッションからのリアルタイムなデータストリーミング

## PTY を使った対話型コマンド \{#interactive-commands-with-pty\}

PTY セッションは、ユーザー入力を伴う対話型コマンドの実行に適しており、実行中でもサイズを変更できます。

<Tabs>
  <TabItem label="Python" icon="seti:python">
    ```python
    import time
    from daytona import Daytona, Sandbox
    from daytona.common.pty import PtySize

    def handle_pty_data(data: bytes):
    text = data.decode("utf-8", errors="replace")
    print(text, end="")

    # PTY セッションを作成

    pty_handle = sandbox.process.create_pty_session(
    id="interactive-session",
    pty_size=PtySize(cols=300, rows=100)
    )

    # 対話型コマンドを送信

    pty_handle.send_input('printf "Are you accepting the terms and conditions? (y/n): " && read confirm && if [ "$confirm" = "y" ]; then echo "You accepted"; else echo "You did not accept"; fi\n')
    time.sleep(1)
    pty_handle.send_input("y\n")

    # 端末サイズを変更

    pty_session_info = pty_handle.resize(PtySize(cols=210, rows=110))
    print(f"PTY session resized to {pty_session_info.cols}x{pty_session_info.rows}")

    # セッションを終了

    pty_handle.send_input('exit\n')

    # イテレーターで出力を処理

    for data in pty_handle:
    handle_pty_data(data)

    print(f"Session completed with exit code: {pty_handle.exit_code}")

    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    import { Daytona, Sandbox } from '@daytonaio/sdk'

    // PTY セッションを作成
    const ptyHandle = await sandbox.process.createPty({
      id: 'interactive-session',
      cols: 300,
      rows: 100,
      onData: (data) => {
        const text = new TextDecoder().decode(data)
        process.stdout.write(text)
      },
    })

    await ptyHandle.waitForConnection()

    // 対話型コマンドを送信
    await ptyHandle.sendInput('printf "Are you accepting the terms and conditions? (y/n): " && read confirm && if [ "$confirm" = "y" ]; then echo "You accepted"; else echo "You did not accept"; fi\n')
    await new Promise(resolve => setTimeout(resolve, 1000))
    await ptyHandle.sendInput('y\n')

    // 端末サイズを変更
    const ptySessionInfo = await sandbox.process.resizePtySession(ptySessionId, 210, 110)
    console.log(`\nPTY session resized to ${ptySessionInfo.cols}x${ptySessionInfo.rows}`)

    // セッションを終了
    await ptyHandle.sendInput('exit\n')

    // 完了を待機
    const result = await ptyHandle.wait()
    console.log(`Session completed with exit code: ${result.exitCode}`)
    ```
  </TabItem>
</Tabs>

## PTY を用いた長時間実行プロセス \{#long-running-processes-with-pty\}

PTY セッションは、監視や強制終了が必要な長時間実行プロセスの管理に最適です。

<Tabs>
  <TabItem label="Python" icon="seti:python">
    ```python
    import time
    from daytona import Daytona, Sandbox
    from daytona.common.pty import PtySize

    def handle_pty_data(data: bytes):
        text = data.decode("utf-8", errors="replace")
        print(text, end="")

    # PTY セッションを作成

    pty_handle = sandbox.process.create_pty_session(
        id="long-running-session",
        pty_size=PtySize(cols=120, rows=30)
    )

    # 長時間実行プロセスを開始

    pty_handle.send_input('while true; do echo "Running... $(date)"; sleep 1; done\n')

    # スレッドと wait() メソッドを使って PTY 出力を処理

    thread = threading.Thread(target=pty_handle.wait, args=(handle_pty_data, 10))
    thread.start()

    time.sleep(3)  # しばらく実行させる

    print("長時間実行プロセスを停止します...")
    pty_handle.kill()

    thread.join()

    print(f"\nプロセスは終了コード {result.exit_code} で終了しました")
    if result.error:
        print(f"終了理由: {result.error}")

    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    import { Daytona, Sandbox } from '@daytonaio/sdk'

    // PTY セッションを作成
    const ptyHandle = await sandbox.process.createPty({
      id: 'long-running-session',
      cols: 120,
      rows: 30,
      onData: (data) => {
        const text = new TextDecoder().decode(data)
        process.stdout.write(text)
      },
    })

    await ptyHandle.waitForConnection()

    // 長時間実行プロセスを開始
    await ptyHandle.sendInput('while true; do echo "Running... $(date)"; sleep 1; done\n')
    await new Promise(resolve => setTimeout(resolve, 3000)) // しばらく実行させる

    console.log('長時間実行プロセスを停止します...')
    await ptyHandle.kill()

    // 終了を待機
    const result = await ptyHandle.wait()
    console.log(`\nプロセスは終了コード ${result.exitCode} で終了しました`)
    if (result.error) {
      console.log(`終了理由: ${result.error}`)
    }
    ```
  </TabItem>
</Tabs>

## ベストプラクティス \{#best-practices\}

### リソース管理 \{#resource-management\}

リソースリークを防ぐため、PTY セッションは必ずクリーンアップしてください:

<Tabs>
  <TabItem label="Python" icon="seti:python">
    ```python
    # Python: try/finally を使用
    pty_handle = None
    try:
        pty_handle = sandbox.process.create_pty_session(id="session", pty_size=PtySize(cols=120, rows=30))
        # 処理を実行...
    finally:
        if pty_handle:
            pty_handle.kill()
    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    // TypeScript: try/finally を使用
    let ptyHandle
    try {
      ptyHandle = await sandbox.process.createPty({
        id: 'session',
        cols: 120,
        rows: 30,
      })
      // 処理を実行...
    } finally {
      if (ptyHandle) await ptyHandle.kill()
    }
    ```
  </TabItem>
</Tabs>

### エラー処理 \{#error-handling\}

終了コードを監視し、適切にエラーを処理します：

<Tabs>
  <TabItem label="Python" icon="seti:python">
    ```python
    # Python: 終了コードを確認する
    result = pty_handle.wait()
    if result.exit_code != 0:
        print(f"Command failed: {result.exit_code}")
        print(f"Error: {result.error}")
    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    // TypeScript: 終了コードを確認する
    const result = await ptyHandle.wait()
    if (result.exitCode !== 0) {
      console.log(`Command failed: ${result.exitCode}`)
      console.log(`Error: ${result.error}`)
    }
    ```
  </TabItem>
</Tabs>

## 一般的なユースケース \{#common-use-cases\}

* **インタラクティブ開発**: REPL、デバッガ、開発ツール
* **ビルド処理**: コンパイル、テスト、デプロイの実行と監視
* **システム管理**: リモートサーバーの管理と設定
* **ユーザーインターフェース**: ユーザー操作を伴うターミナルベースのアプリケーション

## トラブルシューティング \{#troubleshooting\}

**接続の問題**: サンドボックスのステータス、ネットワーク接続、正しいセッションIDを確認してください。
**パフォーマンスの問題**: 適切なターミナルサイズと効率的なデータハンドラーを使用してください。
**プロセス管理**: 長時間実行されるプロセスには、明示的な `kill()` の呼び出しと適切なタイムアウト処理を行ってください。