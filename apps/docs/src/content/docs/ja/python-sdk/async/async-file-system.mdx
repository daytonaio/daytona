---
title: "AsyncFileSystem"
hideTitleOnPage: true
---

## AsyncFileSystem \{#asyncfilesystem\}

```python
class AsyncFileSystem()
```

サンドボックス内のファイルシステム操作を提供します。

このクラスは、Daytonaのサンドボックス内で実行可能なファイルシステム操作に対する高レベルなインターフェースを実装します。

#### AsyncFileSystem.&#95;&#95;init&#95;&#95; \{#asyncfilesystem&#95;&#95;init&#95;&#95;\}

```python
def __init__(sandbox_id: str, toolbox_api: ToolboxApi,
             get_root_dir: Callable[[], Awaitable[str]])
```

新しい FileSystem インスタンスを初期化します。

**引数**:

* `sandbox_id` *str* - サンドボックスのID。
* `toolbox_api` *ToolboxApi* - サンドボックス操作用のAPIクライアント。
* `get_root_dir` *Callable[[], Awaitable[str]]* - サンドボックスのデフォルトのルートディレクトリを取得する関数。

#### AsyncFileSystem.create&#95;folder \{#asyncfilesystemcreate&#95;folder\}

```python
@intercept_errors(message_prefix="Failed to create folder: ")
async def create_folder(path: str, mode: str) -> None
```

指定されたパスに、与えられた権限でサンドボックス内に新しいディレクトリを作成します。

**引数**:

* `path` *str* - ディレクトリを作成するパス。相対パスはユーザーのルートディレクトリを基準に解決されます。
* `mode` *str* - 8進数形式のディレクトリ権限（例: &quot;755&quot; は rwxr-xr-x）。

**例**:

```python
# 標準的な権限でディレクトリを作成
await sandbox.fs.create_folder("workspace/data", "755")

# プライベートなディレクトリを作成
await sandbox.fs.create_folder("workspace/secrets", "700")
```

#### AsyncFileSystem.delete&#95;file \{#asyncfilesystemdelete&#95;file\}

```python
@intercept_errors(message_prefix="Failed to delete file: ")
async def delete_file(path: str, recursive: bool = False) -> None
```

サンドボックスからファイルを削除します。

**引数**:

* `path` *str* - 削除するファイルの絶対パス。
* `recursive` *bool* - 対象がディレクトリの場合、削除するには True にする必要があります。

**例**:

```python
# ファイルを削除する
await sandbox.fs.delete_file("workspace/data/old_file.txt")
```

#### AsyncFileSystem.download&#95;file \{#asyncfilesystemdownload&#95;file\}

```python
@overload
async def download_file(remote_path: str, timeout: int = 30 * 60) -> bytes
```

サンドボックスからファイルをダウンロードします。ファイルの内容を bytes オブジェクトとして返します。
このメソッドは、ディスクに保存せずにファイルをメモリ上で読み込みたい場合に便利です。
小さなファイルにのみ使用できます。

**引数**:

* `remote_path` *str* - サンドボックス内のファイルパス。相対パスはユーザーの
  ルートディレクトリを基準に解決されます。
* `timeout` *int* - ダウンロード処理のタイムアウト（秒）。0 はタイムアウトなしを意味します。デフォルトは 30 分です。

**戻り値**:

* `bytes` - ファイル内容を表す bytes オブジェクト。

**例**:

```python
# ファイルをダウンロードしてローカルに保存
content = await sandbox.fs.download_file("workspace/data/file.txt")
with open("local_copy.txt", "wb") as f:
    f.write(content)

# テキスト内容をダウンロードして処理
content = await sandbox.fs.download_file("workspace/data/config.json")
config = json.loads(content.decode('utf-8'))
```

#### AsyncFileSystem.download&#95;file \{#asyncfilesystemdownload&#95;file\}

```python
@overload
async def download_file(remote_path: str,
                        local_path: str,
                        timeout: int = 30 * 60) -> None
```

サンドボックスからファイルをダウンロードし、ストリーミングでローカルファイルに保存します。
このメソッドは、メモリに収まりきらない可能性がある大きなファイルのダウンロードに有用です。

**引数**:

* `remote_path` *str* - サンドボックス内のファイルパス。相対パスはユーザーのルートディレクトリを基準に解決されます。
* `local_path` *str* - ローカルに保存するファイルのパス。
* `timeout` *int* - ダウンロード処理のタイムアウト（秒）。0 はタイムアウトなしを意味します。デフォルトは30分です。

**例**:

```python
local_path = "local_copy.txt"
await sandbox.fs.download_file("tmp/large_file.txt", local_path)
size_mb = os.path.getsize(local_path) / 1024 / 1024
print(f"Size of the downloaded file {local_path}: {size_mb} MB")
```

#### AsyncFileSystem.find&#95;files \{#asyncfilesystemfind&#95;files\}

```python
@intercept_errors(message_prefix="Failed to find files: ")
async def find_files(path: str, pattern: str) -> List[Match]
```

grep コマンドのように、指定したパターンを含むファイルを検索します。

**引数**:

* `path` *str* - 検索対象のファイルまたはディレクトリへのパス。パスがディレクトリの場合は再帰的に検索します。相対パスはユーザーのルートディレクトリを基準に解決されます。
* `pattern` *str* - ファイル内容に対して照合する検索パターン。

**戻り値**:

* `List[Match]` - ファイル内で見つかった一致のリスト。各 Match オブジェクトには以下が含まれます:
  * file: 一致が見つかったファイルのパス
  * line: 一致が見つかった行番号
  * content: 一致した行の内容

**例**:

```python
# Pythonファイル内の TODO を検索
matches = await sandbox.fs.find_files("workspace/src", "TODO:")
for match in matches:
    print(f"{match.file}:{match.line}: {match.content.strip()}")
```

#### AsyncFileSystem.get&#95;file&#95;info \{#asyncfilesystemget&#95;file&#95;info\}

```python
@intercept_errors(message_prefix="Failed to get file info: ")
async def get_file_info(path: str) -> FileInfo
```

ファイルまたはディレクトリの詳細情報（サイズ、権限、タイムスタンプなど）を取得します。

**引数**:

* `path` *str* - ファイルまたはディレクトリのパス。相対パスはユーザーのルートディレクトリを基準に解決されます。

**戻り値**:

* `FileInfo` - 次を含む詳細なファイル情報:
  * name: ファイル名
  * is&#95;dir: パスがディレクトリかどうか
  * size: バイト単位のファイルサイズ
  * mode: ファイルのパーミッション
  * mod&#95;time: 最終更新時刻のタイムスタンプ
  * permissions: 8進数表記のファイルパーミッション
  * owner: ファイル所有者
  * group: ファイルのグループ

**例**:

```python
# ファイルのメタデータを取得
info = await sandbox.fs.get_file_info("workspace/data/file.txt")
print(f"Size: {info.size} bytes")
print(f"Modified: {info.mod_time}")
print(f"Mode: {info.mode}")

# パスがディレクトリかを確認
info = await sandbox.fs.get_file_info("workspace/data")
if info.is_dir:
    print("Path is a directory")
```

#### AsyncFileSystem.list&#95;files \{#asyncfilesystemlist&#95;files\}

```python
@intercept_errors(message_prefix="Failed to list files: ")
async def list_files(path: str) -> List[FileInfo]
```

指定されたパス内のファイルとディレクトリを列挙し、その情報を返します。`ls -l` コマンドに相当します。

**引数**:

* `path` *str* - 内容を列挙する対象ディレクトリへのパス。相対パスはユーザーの
  ルートディレクトリを基準に解決されます。

**戻り値**:

* `List[FileInfo]` - ファイルおよびディレクトリ情報のリスト。各 `FileInfo`
  オブジェクトには、`get_file_info()` に記載のフィールドが含まれます。

**例**:

```python
# ディレクトリ内容を一覧表示
files = await sandbox.fs.list_files("workspace/data")

# ファイルとそのサイズを表示
for file in files:
    if not file.is_dir:
        print(f"{file.name}: {file.size} bytes")

# ディレクトリのみを一覧表示
dirs = [f for f in files if f.is_dir]
print("Subdirectories:", ", ".join(d.name for d in dirs))
```

#### AsyncFileSystem.move&#95;files \{#asyncfilesystemmove&#95;files\}

```python
@intercept_errors(message_prefix="Failed to move files: ")
async def move_files(source: str, destination: str) -> None
```

ファイルまたはディレクトリを移動または名前変更します。移動先の親ディレクトリが存在している必要があります。

**引数**:

* `source` *str* - 移動元のファイルまたはディレクトリへのパス。相対パスはユーザーの
  ルートディレクトリを基準に解決されます。
* `destination` *str* - 移動先のパス。相対パスはユーザーの
  ルートディレクトリを基準に解決されます。

**例**:

```python
# ファイル名を変更
await sandbox.fs.move_files(
    "workspace/data/old_name.txt",
    "workspace/data/new_name.txt"
)

# ファイルを別のディレクトリに移動
await sandbox.fs.move_files(
    "workspace/data/file.txt",
    "workspace/archive/file.txt"
)

# ディレクトリを移動
await sandbox.fs.move_files(
    "workspace/old_dir",
    "workspace/new_dir"
)
```

#### AsyncFileSystem.replace&#95;in&#95;files \{#asyncfilesystemreplace&#95;in&#95;files\}

```python
@intercept_errors(message_prefix="Failed to replace in files: ")
async def replace_in_files(files: List[str], pattern: str,
                           new_value: str) -> List[ReplaceResult]
```

複数ファイルに対して検索と置換を実行します。

**引数**:

* `files` *List[str]* - 置換を行うファイルパスのリスト。相対パスはユーザーのルートディレクトリを基準に解決されます。
* `pattern` *str* - 検索するパターン。
* `new_value` *str* - 一致箇所を置換する文字列。

**戻り値**:

* `List[ReplaceResult]` - 各ファイルで行われた置換内容を示す結果のリスト。各 ReplaceResult には次が含まれます:
  * file: 変更されたファイルのパス
  * success: 操作が成功したかどうか
  * error: 操作が失敗した場合のエラーメッセージ

**例**:

```python
# 特定のファイルで置換する
results = await sandbox.fs.replace_in_files(
    files=["workspace/src/file1.py", "workspace/src/file2.py"],
    pattern="old_function",
    new_value="new_function"
)

# 結果を出力する
for result in results:
    if result.success:
        print(f"{result.file}: {result.success}")
    else:
        print(f"{result.file}: {result.error}")
```

#### AsyncFileSystem.search&#95;files \{#asyncfilesystemsearch&#95;files\}

```python
@intercept_errors(message_prefix="Failed to search files: ")
async def search_files(path: str, pattern: str) -> SearchFilesResponse
```

指定したパターンに一致する名前のファイルおよびディレクトリを検索します。パターンは単純な文字列またはグロブパターンを指定できます。

**引数**:

* `path` *str* - 検索を開始するルートディレクトリへのパス。相対パスはユーザーのルートディレクトリを基準に解決されます。
* `pattern` *str* - ファイル名に対して照合するパターン。グロブパターンをサポートします（例: Python ファイルなら &quot;*.py&quot;）。

**戻り値**:

* `SearchFilesResponse` - 検索結果を含みます:
  * files: 一致したファイルおよびディレクトリのパスのリスト

**例**:

```python
# すべての Python ファイルを検索
result = await sandbox.fs.search_files("workspace", "*.py")
for file in result.files:
    print(file)

# 特定の接頭辞を持つファイルを検索
result = await sandbox.fs.search_files("workspace/data", "test_*")
print(f"Found {len(result.files)} test files")
```

#### AsyncFileSystem.set&#95;file&#95;permissions \{#asyncfilesystemset&#95;file&#95;permissions\}

```python
@intercept_errors(message_prefix="Failed to set file permissions: ")
async def set_file_permissions(path: str,
                               mode: str = None,
                               owner: str = None,
                               group: str = None) -> None
```

ファイルまたはディレクトリの権限（パーミッション）と所有者情報を設定します。各パラメーターを None にすると、その属性は変更されません。

**引数**:

* `path` *str* - 対象のファイルまたはディレクトリへのパス。相対パスはユーザーの
  ルートディレクトリを基準に解決されます。
* `mode` *Optional[str]* - 8進数表記のファイルモード/権限
  （例: &quot;644&quot; は rw-r--r--）。
* `owner` *Optional[str]* - ファイルの所有ユーザー。
* `group` *Optional[str]* - ファイルの所有グループ。

**例**:

```python
# ファイルを実行可能にする
await sandbox.fs.set_file_permissions(
    path="workspace/scripts/run.sh",
    mode="755"  # rwxr-xr-x
)

# ファイルの所有者を変更する
await sandbox.fs.set_file_permissions(
    path="workspace/data/file.txt",
    owner="daytona",
    group="daytona"
)
```

#### AsyncFileSystem.upload&#95;file \{#asyncfilesystemupload&#95;file\}

```python
@overload
async def upload_file(file: bytes,
                      remote_path: str,
                      timeout: int = 30 * 60) -> None
```

サンドボックス内の指定パスにファイルをアップロードします。宛先パスにすでにファイルが存在する場合は上書きされます。メモリに収まる小さなファイルをアップロードする場合に便利です。

**引数**:

* `file` *bytes* - バイト列としてのファイル内容。
* `remote_path` *str* - 宛先ファイルのパス。相対パスはユーザーの
  ルートディレクトリを基準に解決されます。
* `timeout` *int* - アップロード処理のタイムアウト（秒）。0 はタイムアウトなしを意味します。デフォルトは 30 分です。

**例**:

```python
# テキストファイルをアップロード
content = b"Hello, World!"
await sandbox.fs.upload_file(content, "tmp/hello.txt")

# ローカルファイルをアップロード
with open("local_file.txt", "rb") as f:
    content = f.read()
await sandbox.fs.upload_file(content, "tmp/file.txt")

# バイナリデータをアップロード
import json
data = {"key": "value"}
content = json.dumps(data).encode('utf-8')
await sandbox.fs.upload_file(content, "tmp/config.json")
```

#### AsyncFileSystem.upload&#95;file \{#asyncfilesystemupload&#95;file\}

```python
@overload
async def upload_file(local_path: str,
                      remote_path: str,
                      timeout: int = 30 * 60) -> None
```

ローカルファイルシステムからサンドボックス内の指定パスにファイルをアップロードします。
宛先パスにすでにファイルが存在する場合は上書きされます。このメソッドは
ストリーミングでアップロードを行うため、メモリに収まりきらない可能性のある大きなファイルのアップロードに有用です。

**引数**:

* `local_path` *str* - アップロードするローカルファイルのパス。
* `remote_path` *str* - サンドボックス内のアップロード先ファイルのパス。相対パスは
  ユーザーのルートディレクトリを基準に解決されます。
* `timeout` *int* - アップロード処理のタイムアウト（秒）。0 はタイムアウトなしを意味します。デフォルトは30分。

**例**:

```python
await sandbox.fs.upload_file("local_file.txt", "tmp/large_file.txt")
```

#### AsyncFileSystem.upload&#95;files \{#asyncfilesystemupload&#95;files\}

```python
@intercept_errors(message_prefix="Failed to upload files: ")
async def upload_files(files: List[FileUpload],
                       timeout: int = 30 * 60) -> None
```

複数のファイルをサンドボックスにアップロードします。宛先パスに同名のファイルが既に存在する場合は上書きされます。

**引数**:

* `files` *List[FileUpload]* - アップロードするファイルの一覧。
* `timeout` *int* - アップロード処理のタイムアウト（秒）。0 はタイムアウトなしを意味します。既定値は 30 分。

**例**:

```python
# 複数のテキストファイルをアップロード
files = [
    FileUpload(
        source=b"Content of file 1",
        destination="/tmp/file1.txt"
    ),
    FileUpload(
        source="workspace/data/file2.txt",
        destination="/tmp/file2.txt"
    ),
    FileUpload(
        source=b'{"key": "value"}',
        destination="/tmp/config.json"
    )
]
await sandbox.fs.upload_files(files)
```

## FileUpload \{#fileupload\}

```python
@dataclass
class FileUpload()
```

サンドボックスにアップロードするファイルを表します。

**属性**:

* `source` *Union[bytes, str]* - ファイルの内容。`bytes` オブジェクトまたはローカルファイルパスを指定します。`bytes` オブジェクトを指定する場合はメモリに収まることを確認し、そうでない場合はローカルファイルパスを使用してください。ローカルファイルパスを指定した場合、内容はサンドボックスへストリーミングされます。
* `destination` *str* - サンドボックス内の絶対パス。相対パスはユーザーのルートディレクトリを基準に解決されます。