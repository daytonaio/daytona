---
title: "AsyncLspServer"
hideTitleOnPage: true
---

## AsyncLspServer \{#asynclspserver\}

```python
class AsyncLspServer()
```

コードインテリジェンスのための Language Server Protocol 機能を提供し、コード補完やシンボル検索などの IDE 相当の機能を実現します。

#### AsyncLspServer.**init** \{#asynclspserver&#95;&#95;init&#95;&#95;\}

```python
def __init__(language_id: LspLanguageId, path_to_project: str,
             toolbox_api: ToolboxApi, sandbox_id: str)
```

新しい LSP サーバーインスタンスを初期化します。

**引数**:

* `language_id` *LspLanguageId* - 言語サーバーの種類（例: LspLanguageId.TYPESCRIPT）。
* `path_to_project` *str* - プロジェクトのルートディレクトリへの絶対パス。
* `toolbox_api` *ToolboxApi* - サンドボックス操作用の API クライアント。
* `instance` *SandboxInstance* - このサーバーが属するサンドボックスインスタンス。

#### AsyncLspServer.start \{#asynclspserverstart\}

```python
@intercept_errors(message_prefix="Failed to start LSP server: ")
async def start() -> None
```

言語サーバーを起動します。

このメソッドは、他の LSP 機能を使用する前に呼び出す必要があります。指定した言語とプロジェクト向けに言語サーバーを初期化します。

**例**:

```python
lsp = sandbox.create_lsp_server("typescript", "workspace/project")
await lsp.start()  # Initialize the server
# Now ready for LSP operations
```

#### AsyncLspServer.stop \{#asynclspserverstop\}

```python
@intercept_errors(message_prefix="Failed to stop LSP server: ")
async def stop() -> None
```

言語サーバーを停止します。

LSP サーバーが不要になったときは、システムリソースを解放するためにこのメソッドを呼び出してください。

**例**:

```python
# When done with LSP features
await lsp.stop()  # Clean up resources
```

#### AsyncLspServer.did&#95;open \{#asynclspserverdid&#95;open\}

```python
@intercept_errors(message_prefix="Failed to open file: ")
async def did_open(path: str) -> None
```

ファイルが開かれたことを言語サーバーに通知します。

このメソッドは、エディタでファイルを開いたときに呼び出し、そのファイルに対する診断や補完などの言語機能を有効化します。サーバーはファイル内容の追跡を開始し、言語機能を提供します。

**引数**:

* `path` *str* - 開いたファイルのパス。相対パスは LSP サーバーのコンストラクタで設定されたプロジェクトパスに基づいて解決されます。

**例**:

```python
# When opening a file for editing
await lsp.did_open("workspace/project/src/index.ts")
# Now can get completions, symbols, etc. for this file
```

#### AsyncLspServer.did&#95;close \{#asynclspserverdid&#95;close\}

```python
@intercept_errors(message_prefix="Failed to close file: ")
async def did_close(path: str) -> None
```

ファイルが閉じられたことを言語サーバーに通知します。

このメソッドは、エディタでファイルを閉じたときに呼び出し、そのファイルに関連するリソースを言語サーバーがクリーンアップできるようにします。

**引数**:

* `path` *str* - 閉じたファイルのパス。相対パスは LSP サーバーのコンストラクタで設定されたプロジェクトパスに基づいて解決されます。

**例**:

```python
# When done editing a file
await lsp.did_close("workspace/project/src/index.ts")
```

#### AsyncLspServer.document&#95;symbols \{#asynclspserverdocument&#95;symbols\}

```python
@intercept_errors(message_prefix="Failed to get symbols from document: ")
async def document_symbols(path: str) -> List[LspSymbol]
```

ドキュメントからシンボル情報（関数、クラス、変数など）を取得します。

**引数**:

* `path` *str* - シンボルを取得するファイルのパス。相対パスは LSP サーバーのコンストラクタで設定されたプロジェクトパスに基づいて解決されます。

**戻り値**:

* `List[LspSymbol]` - ドキュメント内のシンボルのリスト。各シンボルには以下が含まれます:
  * name: シンボル名
  * kind: シンボルの種類（関数、クラス、変数など）
  * location: ファイル内のシンボルの位置

**例**:

```python
# Get all symbols in a file
symbols = await lsp.document_symbols("workspace/project/src/index.ts")
for symbol in symbols:
    print(f"{symbol.kind} {symbol.name}: {symbol.location}")
```

#### AsyncLspServer.workspace&#95;symbols \{#asynclspserverworkspace&#95;symbols\}

```python
@deprecated(
    reason=
    "Method is deprecated. Use `sandbox_symbols` instead. This method will be removed in a future version."
)
async def workspace_symbols(query: str) -> List[LspSymbol]
```

サンドボックス内のすべてのファイルを対象に、クエリ文字列に一致するシンボルを検索します。

**引数**:

* `query` *str* - シンボル名に対してマッチさせる検索クエリ。

**戻り値**:

* `List[LspSymbol]` - すべてのファイルから一致したシンボルのリスト。

#### AsyncLspServer.sandbox&#95;symbols \{#asynclspserversandbox&#95;symbols\}

```python
@intercept_errors(message_prefix="Failed to get symbols from sandbox: ")
async def sandbox_symbols(query: str) -> List[LspSymbol]
```

サンドボックス内のすべてのファイルを対象に、クエリ文字列に一致するシンボルを検索します。

**引数**:

* `query` *str* - シンボル名に対してマッチさせる検索クエリ。

**戻り値**:

* `List[LspSymbol]` - すべてのファイルから一致したシンボルのリスト。各シンボルには次が含まれます:
  * name: シンボル名
  * kind: シンボルの種別（関数、クラス、変数など）
  * location: ファイル内でのシンボルの位置

**例**:

```python
# "User" を含むすべてのシンボルを検索
symbols = await lsp.sandbox_symbols("User")
for symbol in symbols:
    print(f"{symbol.name} in {symbol.location}")
```

#### AsyncLspServer.completions \{#asynclspservercompletions\}

```python
@intercept_errors(message_prefix="Failed to get completions: ")
async def completions(path: str, position: Position) -> CompletionList
```

ファイル内の指定位置での補完候補を取得します。

**引数**:

* `path` *str* - ファイルパス。相対パスは、LSP サーバーのコンストラクタで設定されたプロジェクトパスを基準に解決されます。
* `position` *Position* - 補完候補を取得するカーソル位置。

**戻り値**:

* `CompletionList` - 補完候補のリスト。次を含みます:
  * isIncomplete: 追加の項目が存在する可能性があるか
  * items: 補完アイテムのリスト。各アイテムには次が含まれます:
  * label: 挿入するテキスト
  * kind: 補完の種別
  * detail: アイテムに関する追加情報
  * documentation: アイテムのドキュメント
  * sortText: リスト内での並び替えに用いるテキスト
  * filterText: フィルタリングに用いるテキスト
  * insertText: 実際に挿入するテキスト（label と異なる場合）

**例**:

```python
# 指定位置で補完候補を取得
pos = Position(line=10, character=15)
completions = await lsp.completions("workspace/project/src/index.ts", pos)
for item in completions.items:
    print(f"{item.label} ({item.kind}): {item.detail}")
```

## LspLanguageId \{#lsplanguageid\}

```python
class LspLanguageId(Enum)
```

LSP（Language Server Protocol）の言語ID。

**列挙メンバー**:

* `PYTHON` (&quot;python&quot;)
* `TYPESCRIPT` (&quot;typescript&quot;)
* `JAVASCRIPT` (&quot;javascript&quot;)

## Position \{#position\}

```python
class Position()
```

テキストドキュメント内の0始まりの位置を表し、行番号と文字オフセットで指定します。

**属性**:

* `line` *int* - ドキュメント内の0始まりの行番号。
* `character` *int* - 行内の0始まりの文字オフセット。

#### Position.**init** \{#position&#95;&#95;init&#95;&#95;\}

```python
def __init__(line: int, character: int)
```

新しい Position インスタンスを初期化します。

**引数**:

* `line` *int* - ドキュメント内の0始まりの行番号。
* `character` *int* - 行内の0始まりの文字オフセット。
