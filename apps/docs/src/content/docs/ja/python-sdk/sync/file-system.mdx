---
title: "ファイルシステム"
hideTitleOnPage: true
---

## FileSystem \{#filesystem\}

```python
class FileSystem()
```

サンドボックス内のファイルシステム操作を提供します。

このクラスは、Daytonaのサンドボックス内で実行可能なファイルシステム操作に対する高水準インターフェースを実装します。

#### FileSystem.__init__ \{#filesystem__init__\}

```python
def __init__(api_client: FileSystemApi, ensure_toolbox_url: Callable[[],
                                                                     None])
```

新しい FileSystem インスタンスを初期化します。

**引数**:

* `api_client` *FileSystemApi* - サンドボックスのファイルシステム操作用 API クライアント。
* `ensure_toolbox_url` *Callable[[], None]* - Toolbox API の URL が初期化されていることを保証する関数。
  API クライアントのプライベートメソッドを呼び出す前に必ず実行してください。

#### FileSystem.create_folder \{#filesystemcreate_folder\}

```python
@intercept_errors(message_prefix="フォルダーの作成に失敗しました: ")
@with_instrumentation()
def create_folder(path: str, mode: str) -> None
```

指定したパスに、指定した権限でサンドボックス内に新しいディレクトリを作成します。

**引数**:

* `path` *str* - ディレクトリを作成するパス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。
* `mode` *str* - 8進数表記のディレクトリ権限（例: &quot;755&quot; は rwxr-xr-x）。

**例**:

```python
# 標準権限でディレクトリを作成
sandbox.fs.create_folder("workspace/data", "755")

# Create a private directory
sandbox.fs.create_folder("workspace/secrets", "700")
```

#### FileSystem.delete_file \{#filesystemdelete_file\}

```python
@intercept_errors(message_prefix="ファイルの削除に失敗しました: ")
@with_instrumentation()
def delete_file(path: str, recursive: bool = False) -> None
```

サンドボックスからファイルを削除します。

**引数**:

* `path` *str* - 削除するファイルのパス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。
* `recursive` *bool* - 対象がディレクトリの場合、削除するには true にする必要があります。

**例**:

```python
# ファイルを削除
sandbox.fs.delete_file("workspace/data/old_file.txt")
```

#### FileSystem.download_file \{#filesystemdownload_file\}

```python
@overload
def download_file(remote_path: str, timeout: int = 30 * 60) -> bytes
```

サンドボックスからファイルをダウンロードします。ファイルの内容をバイト列（bytes）オブジェクトとして返します。
このメソッドは、ディスクに保存せずにファイルをメモリに読み込みたい場合に便利です。
小容量のファイルにのみ使用できます。

**引数**:

* `remote_path` *str* - サンドボックス内のファイルパス。相対パスは
  サンドボックスの作業ディレクトリを基準に解決されます。
* `timeout` *int* - ダウンロード処理のタイムアウト（秒）。0 はタイムアウトなしを意味します。既定は30分です。

**戻り値**:

* `bytes` - ファイル内容を表すバイト列（bytes）オブジェクト。

**例**:

```python
# ファイルをローカルにダウンロードして保存
content = sandbox.fs.download_file("workspace/data/file.txt")
with open("local_copy.txt", "wb") as f:
    f.write(content)

# テキストコンテンツをダウンロードして処理
content = sandbox.fs.download_file("workspace/data/config.json")
config = json.loads(content.decode('utf-8'))
```

#### FileSystem.download_file \{#filesystemdownload_file\}

```python
@overload
def download_file(remote_path: str,
                  local_path: str,
                  timeout: int = 30 * 60) -> None
```

サンドボックスからファイルをダウンロードし、ストリーム経由でローカルファイルに保存します。
このメソッドは、メモリに収まりきらない可能性のある大きなファイルをダウンロードする際に有用です。

**引数**:

* `remote_path` *str* - サンドボックス内のファイルパス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。
* `local_path` *str* - ファイルを保存するローカルのパス。
* `timeout` *int* - ダウンロード処理のタイムアウト（秒）。0 はタイムアウトなしを意味します。デフォルトは30分です。

**例**:

```python
local_path = "local_copy.txt"
sandbox.fs.download_file("tmp/large_file.txt", local_path)
size_mb = os.path.getsize(local_path) / 1024 / 1024
print(f"ダウンロードしたファイル {local_path} のサイズ: {size_mb} MB")
```

#### FileSystem.download_files \{#filesystemdownload_files\}

```python
@intercept_errors(message_prefix="ファイルのダウンロードに失敗しました: ")
@with_instrumentation()
def download_files(files: list[FileDownloadRequest],
                   timeout: int = 30 * 60) -> list[FileDownloadResponse]
```

サンドボックスから複数のファイルをダウンロードします。ファイルがローカルに既に存在する場合は上書きされます。

**引数**:

* `files` *list[FileDownloadRequest]* - ダウンロードするファイルのリスト。
* `timeout` *int* - ダウンロード処理のタイムアウト（秒）。0 はタイムアウトなしを意味します。既定値は 30 分です。

**戻り値**:

* `list[FileDownloadResponse]` - ダウンロード結果のリスト。

**例外**:

* `Exception` - リクエスト自体が失敗した場合のみ（ネットワーク障害、不正なリクエスト／レスポンスなど）。個々の
  ファイルのダウンロードエラーは `FileDownloadResponse.error` フィールドで返されます。

**例**:

```python
# Download multiple files
results = sandbox.fs.download_files([
    FileDownloadRequest(source="tmp/data.json"),
    FileDownloadRequest(source="tmp/config.json", destination="local_config.json")
])
for result in results:
    if result.error:
        print(f"{result.source} のダウンロード中にエラーが発生しました: {result.error}")
    elif result.result:
        print(f"Downloaded {result.source} to {result.result}")
```

#### FileSystem.find_files \{#filesystemfind_files\}

```python
@intercept_errors(message_prefix="ファイルの検索に失敗しました: ")
@with_instrumentation()
def find_files(path: str, pattern: str) -> list[Match]
```

パターンに一致するファイルを検索します。`grep` コマンドに似ています。

**引数**:

* `path` *str* - 検索対象のファイルまたはディレクトリへのパス。パスがディレクトリの場合は、
  再帰的に検索が行われます。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。
* `pattern` *str* - ファイル内容に対して照合する検索パターン。

**返り値**:

* `list[Match]` - ファイル内で見つかった一致のリスト。各 Match オブジェクトには次が含まれます:
  * file: 一致を含むファイルのパス
  * line: 一致が見つかった行番号
  * content: 一致した行の内容

**例**:

```python
# Pythonファイル内のTODOを検索
matches = sandbox.fs.find_files("workspace/src", "TODO:")
for match in matches:
    print(f"{match.file}:{match.line}: {match.content.strip()}")
```

#### FileSystem.get_file_info \{#filesystemget_file_info\}

```python
@intercept_errors(message_prefix="ファイル情報の取得に失敗しました: ")
@with_instrumentation()
def get_file_info(path: str) -> FileInfo
```

ファイルまたはディレクトリの詳細情報（サイズ、権限、タイムスタンプなど）を取得します。

**引数**:

* `path` *str* - ファイルまたはディレクトリへのパス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。

**戻り値**:

* `FileInfo` - 次を含む詳細なファイル情報:
  * name: ファイル名
  * is&#95;dir: パスがディレクトリかどうか
  * size: バイト単位のファイルサイズ
  * mode: ファイル権限
  * mod&#95;time: 最終更新時刻
  * permissions: 8進数形式のファイル権限
  * owner: ファイルの所有者
  * group: ファイルのグループ

**例**:

```python
# ファイルメタデータを取得
info = sandbox.fs.get_file_info("workspace/data/file.txt")
print(f"サイズ: {info.size} バイト")
print(f"更新日時: {info.mod_time}")
print(f"モード: {info.mode}")

# パスがディレクトリかどうかを確認
info = sandbox.fs.get_file_info("workspace/data")
if info.is_dir:
    print("パスはディレクトリです")
```

#### FileSystem.list_files \{#filesystemlist_files\}

```python
@intercept_errors(message_prefix="ファイル一覧の取得に失敗しました: ")
@with_instrumentation()
def list_files(path: str) -> list[FileInfo]
```

指定したパス配下のファイルとディレクトリを一覧表示し、その情報を返します。ls -l コマンドに類似します。

**引数**:

* `path` *str* - 内容を一覧表示するディレクトリのパス。相対パスは
  サンドボックスの作業ディレクトリを基準に解決されます。

**戻り値**:

* `list[FileInfo]` - ファイルおよびディレクトリ情報のリスト。各 FileInfo
  オブジェクトは get&#95;file&#95;info() で説明されているフィールドと同一です。

**例**:

```python
# List directory contents
files = sandbox.fs.list_files("workspace/data")

# Print files and their sizes
for file in files:
    if not file.is_dir:
        print(f"{file.name}: {file.size} bytes")

# List only directories
dirs = [f for f in files if f.is_dir]
print("サブディレクトリ:", ", ".join(d.name for d in dirs))
```

#### FileSystem.move_files \{#filesystemmove_files\}

```python
@intercept_errors(message_prefix="ファイルの移動に失敗しました: ")
@with_instrumentation()
def move_files(source: str, destination: str) -> None
```

ファイルまたはディレクトリを移動またはリネームします。移動先の親ディレクトリは存在している必要があります。

**引数**:

* `source` *str* - 元のファイルまたはディレクトリへのパス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。
* `destination` *str* - 移動先のパス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。

**例**:

```python
# ファイルの名前を変更
sandbox.fs.move_files(
    "workspace/data/old_name.txt",
    "workspace/data/new_name.txt"
)

# ファイルを別のディレクトリに移動
sandbox.fs.move_files(
    "workspace/data/file.txt",
    "workspace/archive/file.txt"
)

# ディレクトリを移動
sandbox.fs.move_files(
    "workspace/old_dir",
    "workspace/new_dir"
)
```

#### FileSystem.replace_in_files \{#filesystemreplace_in_files\}

```python
@intercept_errors(message_prefix="ファイル内の置換に失敗しました: ")
@with_instrumentation()
def replace_in_files(files: list[str], pattern: str,
                     new_value: str) -> list[ReplaceResult]
```

複数のファイルにわたって検索と置換を実行します。

**引数**:

* `files` *list[str]* - 置換を行うファイルパスのリスト。相対パスは
  サンドボックスの作業ディレクトリを基準に解決されます。
* `pattern` *str* - 検索するパターン。
* `new_value` *str* - 一致箇所を置換するテキスト。

**戻り値**:

* `list[ReplaceResult]` - 各ファイルで実施された置換内容を示す結果のリスト。
  各 ReplaceResult には次が含まれます:
  * file: 変更されたファイルのパス
  * success: 操作が成功したかどうか
  * error: 操作が失敗した場合のエラーメッセージ

**例**:

```python
# 特定のファイルで置換
results = sandbox.fs.replace_in_files(
    files=["workspace/src/file1.py", "workspace/src/file2.py"],
    pattern="old_function",
    new_value="new_function"
)

# Print results
for result in results:
    if result.success:
        print(f"{result.file}: {result.success}")
    else:
        print(f"{result.file}: {result.error}")
```

#### FileSystem.search_files \{#filesystemsearch_files\}

```python
@intercept_errors(message_prefix="ファイル検索に失敗しました: ")
@with_instrumentation()
def search_files(path: str, pattern: str) -> SearchFilesResponse
```

指定したパターンに名前が一致するファイルとディレクトリを検索します。パターンはシンプルな文字列またはグロブパターンを指定できます。

**引数**:

* `path` *str* - 検索を開始するルートディレクトリへのパス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。
* `pattern` *str* - ファイル名に対して照合するパターン。グロブパターンをサポートします（例: &quot;*.py&quot; は Python ファイル）。

**戻り値**:

* `SearchFilesResponse` - 次を含む検索結果:
  * files: 一致したファイルおよびディレクトリパスの一覧

**例**:

```python
# Find all Python files
result = sandbox.fs.search_files("workspace", "*.py")
for file in result.files:
    print(file)

# Find files with specific prefix
result = sandbox.fs.search_files("workspace/data", "test_*")
print(f"{len(result.files)}個のテストファイルが見つかりました")
```

#### FileSystem.set_file_permissions \{#filesystemset_file_permissions\}

```python
@intercept_errors(message_prefix="ファイル権限の設定に失敗しました: ")
@with_instrumentation()
def set_file_permissions(path: str,
                         mode: str | None = None,
                         owner: str | None = None,
                         group: str | None = None) -> None
```

ファイルまたはディレクトリの権限と所有権を設定します。いずれのパラメータも None の場合、
その属性は変更されません。

**引数**:

* `path` *str* - ファイルまたはディレクトリへのパス。相対パスは
  サンドボックスの作業ディレクトリを基準に解決されます。
* `mode` *str | None* - 8進数形式のファイルモード/パーミッション
  (例: &quot;644&quot; は rw-r--r--)。
* `owner` *str | None* - ファイルの所有ユーザー。
* `group` *str | None* - ファイルの所有グループ。

**例**:

```python
# ファイルを実行可能にする
sandbox.fs.set_file_permissions(
    path="workspace/scripts/run.sh",
    mode="755"  # rwxr-xr-x
)

# Change file owner
sandbox.fs.set_file_permissions(
    path="workspace/data/file.txt",
    owner="daytona",
    group="daytona"
)
```

#### FileSystem.upload_file \{#filesystemupload_file\}

```python
@overload
def upload_file(file: bytes, remote_path: str, timeout: int = 30 * 60) -> None
```

サンドボックス内の指定パスにファイルをアップロードします。宛先パスに既にファイルが存在する場合は上書きされます。このメソッドは、メモリに収まる小さなファイルをアップロードする際に有用です。

**引数**:

* `file` *bytes* - バイト列としてのファイル内容。
* `remote_path` *str* - 宛先ファイルへのパス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。
* `timeout` *int* - アップロード処理のタイムアウト（秒）。0 はタイムアウトなしを意味します。既定値は30分です。

**例**:

```python
# テキストファイルをアップロード
content = b"Hello, World!"
sandbox.fs.upload_file(content, "tmp/hello.txt")

# ローカルファイルをアップロード
with open("local_file.txt", "rb") as f:
    content = f.read()
sandbox.fs.upload_file(content, "tmp/file.txt")

# バイナリデータをアップロード
import json
data = {"key": "value"}
content = json.dumps(data).encode('utf-8')
sandbox.fs.upload_file(content, "tmp/config.json")
```

#### FileSystem.upload_file \{#filesystemupload_file\}

```python
@overload
def upload_file(local_path: str,
                remote_path: str,
                timeout: int = 30 * 60) -> None
```

ローカルファイルシステムからサンドボックス内の指定パスにファイルをアップロードします。
宛先パスに既にファイルが存在する場合は上書きされます。このメソッドは
ストリーミングでアップロードを行うため、メモリに収まりきらない可能性のある
大きなファイルをアップロードする際に有用です。

**引数**:

* `local_path` *str* - アップロードするローカルファイルのパス。
* `remote_path` *str* - サンドボックス内のアップロード先ファイルのパス。相対パスは
  サンドボックスの作業ディレクトリを基準に解決されます。
* `timeout` *int* - アップロード処理のタイムアウト（秒）。0 は無制限。既定は 30 分。

**例**:

```python
sandbox.fs.upload_file("local_file.txt", "tmp/large_file.txt")
```

#### FileSystem.upload_files \{#filesystemupload_files\}

```python
@intercept_errors(message_prefix="ファイルのアップロードに失敗しました: ")
@with_instrumentation()
def upload_files(files: list[FileUpload], timeout: int = 30 * 60) -> None
```

複数のファイルをサンドボックスにアップロードします。宛先パスに既にファイルが存在する場合は上書きされます。

**引数**:

* `files` *list[FileUpload]* - アップロードするファイルの一覧。
* `timeout` *int* - アップロード処理のタイムアウト（秒）。0 はタイムアウトなしを意味します。既定値は 30 分。

**例**:

```python
# 複数のテキストファイルをアップロード
files = [
    FileUpload(
        source=b"Content of file 1",
        destination="/tmp/file1.txt"
    ),
    FileUpload(
        source="workspace/data/file2.txt",
        destination="/tmp/file2.txt"
    ),
    FileUpload(
        source=b'{"key": "value"}',
        destination="/tmp/config.json"
    )
]
sandbox.fs.upload_files(files)
```

## ファイルのアップロード \{#fileupload\}

```python
@dataclass
class FileUpload()
```

サンドボックスにアップロードするファイルを表します。

**属性**:

* `source` *bytes | str* - ファイルの内容。bytes オブジェクトまたはローカルファイルパスを指定します。bytes オブジェクトを指定する場合は、メモリに収まることを確認してください。収まらない場合はローカルファイルパスを使用してください。ファイルの内容はサンドボックスへストリーミングされます。
* `destination` *str* - サンドボックス内の保存先の絶対パス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。

## FileDownloadRequest \{#filedownloadrequest\}

```python
@dataclass
class FileDownloadRequest()
```

サンドボックスから単一のファイルをダウンロードするリクエストを表します。

**属性**:

* `source` *str* - サンドボックス内のソースパス。相対パスはユーザーの
  ルートディレクトリを基準に解決されます。
* `destination` *str | None* - ファイル内容をストリーミングするローカルファイルシステム上の出力先パス。
  指定しない場合、ファイルはバイトバッファにダウンロードされます
  （ファイルが大きい場合はメモリ使用量が増え、問題を引き起こす可能性があります）。

## FileDownloadResponse（ファイルダウンロード応答） \{#filedownloadresponse\}

```python
@dataclass
class FileDownloadResponse()
```

単一のファイルダウンロード要求に対するレスポンスを表します。

**属性**:

* `source` *str* - ダウンロード対象として要求された元のソースパス。
* `result` *str | bytes | None* - ダウンロード結果。要求に宛先が指定されている場合はファイルパス、
  宛先がない場合はバイト列。失敗した場合、またはデータが受信されなかった場合は None。
* `error` *str | None* - ダウンロードが失敗した場合のエラーメッセージ。成功した場合は None。
