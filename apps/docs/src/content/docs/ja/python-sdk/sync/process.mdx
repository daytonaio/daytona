---
title: "プロセス"
hideTitleOnPage: true
---

## プロセス \{#process\}

```python
class Process()
```

サンドボックス内のプロセスおよびコード実行を管理します。

#### Process.**init** \{#process&#95;&#95;init&#95;&#95;\}

```python
def __init__(sandbox_id: str, code_toolbox: SandboxPythonCodeToolbox,
             toolbox_api: ToolboxApi,
             get_preview_link: Callable[[int], PortPreviewUrl])
```

新しい Process インスタンスを初期化します。

**引数**:

* `sandbox_id` *str* - サンドボックスのID。
* `code_toolbox` *SandboxPythonCodeToolbox* - 言語固有のコード実行ツールボックス。
* `toolbox_api` *ToolboxApi* - サンドボックス操作用のAPIクライアント。

#### Process.exec \{#processexec\}

```python
@intercept_errors(message_prefix="コマンドの実行に失敗しました: ")
def exec(command: str,
         cwd: Optional[str] = None,
         env: Optional[Dict[str, str]] = None,
         timeout: Optional[int] = None) -> ExecuteResponse
```

サンドボックスでシェルコマンドを実行します。

**引数**:

* `command` *str* - 実行するシェルコマンド。
* `cwd` *Optional[str]* - コマンド実行時の作業ディレクトリ。未指定の場合は
  サンドボックスの作業ディレクトリを使用します。
* `env` *Optional[Dict[str, str]]* - コマンドに設定する環境変数。
* `timeout` *Optional[int]* - コマンドの完了を待機する最大時間（秒）。
  0 は無期限に待機します。

**戻り値**:

* `ExecuteResponse` - コマンド実行結果を含みます:
  * exit&#95;code: コマンドの終了ステータス
  * result: コマンドの標準出力
  * artifacts: `stdout`（result と同一）および `charts`（matplotlib のチャートメタデータ）を含む ExecutionArtifacts オブジェクト

**例**:

```python
# シンプルなコマンド
response = sandbox.process.exec("echo 'Hello'")
print(response.artifacts.stdout)  # 出力: Hello

# 作業ディレクトリを指定したコマンド
result = sandbox.process.exec("ls", cwd="workspace/src")

# タイムアウトを指定したコマンド
result = sandbox.process.exec("sleep 10", timeout=5)
```

#### Process.code&#95;run \{#processcode&#95;run\}

```python
def code_run(code: str,
             params: Optional[CodeRunParams] = None,
             timeout: Optional[int] = None) -> ExecuteResponse
```

適切な言語ランタイムを使ってサンドボックス内でコードを実行します。

**引数**:

* `code` *str* - 実行するコード。
* `params` *Optional[CodeRunParams]* - コード実行のパラメータ。
* `timeout` *Optional[int]* - コードの完了を待つ最大時間（秒）。0 は無期限に待機します。

**戻り値**:

* `ExecuteResponse` - コード実行結果。以下を含みます:
  * exit&#95;code: 実行の終了ステータス
  * result: コードの標準出力
  * artifacts: `stdout`（result と同一）および `charts`（matplotlib のチャートメタデータ）を含む ExecutionArtifacts オブジェクト

**例**:

```python
# Pythonコードを実行
response = sandbox.process.code_run('''
    x = 10
    y = 20
    print(f"Sum: {x + y}")
''')
print(response.artifacts.stdout)  # 出力: Sum: 30
```

Matplotlib のチャートは自動検出され、`ExecutionArtifacts` オブジェクトの
`charts` フィールドで返されます。

```python
code = '''
import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(0, 10, 30)
y = np.sin(x)

plt.figure(figsize=(8, 5))
plt.plot(x, y, 'b-', linewidth=2)
plt.title('Line Chart')
plt.xlabel('X-axis (seconds)')
plt.ylabel('Y-axis (amplitude)')
plt.grid(True)
plt.show()
'''

response = sandbox.process.code_run(code)
chart = response.artifacts.charts[0]

print(f"Type: {chart.type}")
print(f"Title: {chart.title}")
if chart.type == ChartType.LINE and isinstance(chart, LineChart):
    print(f"X Label: {chart.x_label}")
    print(f"Y Label: {chart.y_label}")
    print(f"X Ticks: {chart.x_ticks}")
    print(f"X Tick Labels: {chart.x_tick_labels}")
    print(f"X Scale: {chart.x_scale}")
    print(f"Y Ticks: {chart.y_ticks}")
    print(f"Y Tick Labels: {chart.y_tick_labels}")
    print(f"Y Scale: {chart.y_scale}")
    print("Elements:")
    for element in chart.elements:
        print(f"Label: {element.label}")
        print(f"Points: {element.points}")
```

#### Process.create&#95;session \{#processcreate&#95;session\}

```python
@intercept_errors(message_prefix="Failed to create session: ")
def create_session(session_id: str) -> None
```

サンドボックス内に新しい長時間稼働のバックグラウンドセッションを作成します。

セッションはコマンド間で状態を保持するバックグラウンドプロセスであり、複数の関連コマンドの実行や永続的な環境のセットアップが必要なシナリオに最適です。長時間実行するコマンドを走らせ、そのプロセスの状態を監視できます。

**引数**:

* `session_id` *str* - 新規セッションの一意の識別子。

**例**:

```python
# Create a new session
session_id = "my-session"
sandbox.process.create_session(session_id)
session = sandbox.process.get_session(session_id)
# Do work...
sandbox.process.delete_session(session_id)
```

#### Process.get&#95;session \{#processget&#95;session\}

```python
@intercept_errors(message_prefix="Failed to get session: ")
def get_session(session_id: str) -> Session
```

サンドボックス内のセッションを取得します。

**引数**:

* `session_id` *str* - 取得対象のセッションの一意識別子。

**戻り値**:

* `Session` - 次の情報を含むセッション情報:
  * session&#95;id: セッションの一意識別子
  * commands: セッション内で実行されたコマンドのリスト

**例**:

```python
session = sandbox.process.get_session("my-session")
for cmd in session.commands:
    print(f"Command: {cmd.command}")
```

#### Process.get&#95;session&#95;command \{#processget&#95;session&#95;command\}

```python
@intercept_errors(message_prefix="Failed to get session command: ")
def get_session_command(session_id: str, command_id: str) -> Command
```

セッション内で実行された特定のコマンドに関する情報を取得します。

**引数**:

* `session_id` *str* - セッションの一意の識別子。
* `command_id` *str* - コマンドの一意の識別子。

**戻り値**:

* `Command` - 次を含むコマンド情報:
  * id: コマンドの一意の識別子
  * command: 実行されたコマンド文字列
  * exit&#95;code: コマンドの終了ステータス（完了済みの場合）

**例**:

```python
cmd = sandbox.process.get_session_command("my-session", "cmd-123")
if cmd.exit_code == 0:
    print(f"Command {cmd.command} completed successfully")
```

#### Process.execute&#95;session&#95;command \{#processexecute&#95;session&#95;command\}

```python
@intercept_errors(message_prefix="Failed to execute session command: ")
def execute_session_command(
        session_id: str,
        req: SessionExecuteRequest,
        timeout: Optional[int] = None) -> SessionExecuteResponse
```

セッション内でコマンドを実行します。

**引数**:

* `session_id` *str* - 使用するセッションの一意の識別子。
* `req` *SessionExecuteRequest* - 次を含むコマンド実行リクエスト:
  * command: 実行するコマンド
  * run&#95;async: 非同期で実行するかどうか

**戻り値**:

* `SessionExecuteResponse` - 次を含むコマンド実行結果:
  * cmd&#95;id: 実行されたコマンドの一意の識別子
  * output: 結合されたコマンド出力（stdout と stderr）（同期実行時）
  * stdout: コマンドの標準出力
  * stderr: コマンドの標準エラー出力
  * exit&#95;code: コマンドの終了ステータス（同期実行時）

**例**:

```python
# セッション状態を維持しつつ順にコマンドを実行
session_id = "my-session"

# ディレクトリを変更
req = SessionExecuteRequest(command="cd /workspace")
sandbox.process.execute_session_command(session_id, req)

# ファイルを作成
req = SessionExecuteRequest(command="echo 'Hello' > test.txt")
sandbox.process.execute_session_command(session_id, req)

# ファイルを読み取る
req = SessionExecuteRequest(command="cat test.txt")
result = sandbox.process.execute_session_command(session_id, req)
print(f"Command stdout: {result.stdout}")
print(f"Command stderr: {result.stderr}")
```

#### Process.get&#95;session&#95;command&#95;logs \{#processget&#95;session&#95;command&#95;logs\}

```python
@intercept_errors(message_prefix="Failed to get session command logs: ")
def get_session_command_logs(session_id: str,
                             command_id: str) -> SessionCommandLogsResponse
```

セッション内で実行されたコマンドのログを取得します。

**引数**:

* `session_id` *str* - セッションの一意の識別子
* `command_id` *str* - コマンドの一意の識別子

**戻り値**:

* `SessionCommandLogsResponse` - コマンドログ。以下を含みます:
  * output: コマンド出力の統合（stdout と stderr）
  * stdout: コマンドの標準出力
  * stderr: コマンドの標準エラー出力

**例**:

```python
logs = sandbox.process.get_session_command_logs(
    "my-session",
    "cmd-123"
)
print(f"Command stdout: {logs.stdout}")
print(f"Command stderr: {logs.stderr}")
```

#### Process.get&#95;session&#95;command&#95;logs&#95;async \{#processget&#95;session&#95;command&#95;logs&#95;async\}

```python
@intercept_errors(message_prefix="Failed to get session command logs: ")
async def get_session_command_logs_async(
        session_id: str, command_id: str, on_stdout: Callable[[str], None],
        on_stderr: Callable[[str], None]) -> None
```

セッション内で実行されたコマンドのログを、利用可能になり次第、非同期で取得・処理します。

**引数**:

* `session_id` *str* - セッションの一意の識別子。
* `command_id` *str* - コマンドの一意の識別子。
* `on_stdout` *Callable[[str], None]* - 受信した標準出力のログチャンクを処理するコールバック関数。
* `on_stderr` *Callable[[str], None]* - 受信した標準エラー出力のログチャンクを処理するコールバック関数。

**例**:

```python
await sandbox.process.get_session_command_logs_async(
    "my-session",
    "cmd-123",
    lambda log: print(f"[STDOUT]: {log}"),
    lambda log: print(f"[STDERR]: {log}"),
)
```

#### Process.list&#95;sessions \{#processlist&#95;sessions\}

```python
@intercept_errors(message_prefix="Failed to list sessions: ")
def list_sessions() -> List[Session]
```

サンドボックス内のすべてのセッションを一覧します。

**戻り値**:

* `List[Session]` - サンドボックス内のすべてのセッションのリスト。

**例**:

```python
sessions = sandbox.process.list_sessions()
for session in sessions:
    print(f"Session {session.session_id}:")
    print(f"  Commands: {len(session.commands)}")
```

#### Process.delete&#95;session \{#processdelete&#95;session\}

```python
@intercept_errors(message_prefix="Failed to delete session: ")
def delete_session(session_id: str) -> None
```

サンドボックス内のセッションを終了して削除し、関連リソースをクリーンアップします。

**引数**:

* `session_id` *str* - 削除対象のセッションの一意識別子。

**例**:

```python
# セッションを作成して使用
sandbox.process.create_session("temp-session")
# ... セッションを使用 ...

# 作業完了後にクリーンアップ
sandbox.process.delete_session("temp-session")
```

## CodeRunParams \{#coderunparams\}

```python
@dataclass
class CodeRunParams()
```

コード実行用のパラメータ。

**属性**:

* `argv` *Optional[List[str]]* - コマンドライン引数
* `env` *Optional[Dict[str, str]]* - 環境変数

## SessionExecuteRequest \{#sessionexecuterequest\}

```python
class SessionExecuteRequest(ApiSessionExecuteRequest,
                            AsyncApiSessionExecuteRequest)
```

セッション内でコマンドを実行するためのリクエストです。

**属性**:

* `command` *str* - 実行するコマンド。
* `run_async` *Optional[bool]* - コマンドを非同期で実行するかどうか。
* `var_async` *Optional[bool]* - 非推奨。代わりに `run_async` を使用してください。

## 実行成果物 (ExecutionArtifacts) \{#executionartifacts\}

```python
class ExecutionArtifacts()
```

コマンド実行で得られる成果物。

**属性**:

* `stdout` *str* - コマンドの標準出力。`ExecuteResponse` の `result` と同一
* `charts` *Optional[List[Chart]]* - matplotlib のチャートメタデータのリスト

## ExecuteResponse \{#executeresponse\}

```python
class ExecuteResponse(ClientExecuteResponse)
```

コマンド実行のレスポンス。

**属性**:

* `exit_code` *int* - コマンド実行の終了コード
* `result` *str* - コマンド実行の出力
* `artifacts` *Optional[ExecutionArtifacts]* - コマンド実行の成果物

## SessionExecuteResponse \{#sessionexecuteresponse\}

```python
class SessionExecuteResponse(ApiSessionExecuteResponse)
```

セッションでのコマンド実行のレスポンス。

**属性**:

* `output` *str* - コマンド実行の出力
* `exit_code` *int* - コマンド実行の終了コード

## SessionCommandLogsResponse \{#sessioncommandlogsresponse\}

```python
class SessionCommandLogsResponse()
```

コマンドログのレスポンス。

**属性**:

* `output` *str* - コマンドの出力を結合したもの
* `stdout` *str* - コマンドの標準出力
* `stderr` *str* - コマンドの標準エラー出力

#### parse&#95;session&#95;command&#95;logs \{#parse&#95;session&#95;command&#95;logs\}

```python
def parse_session_command_logs(data: bytes) -> SessionCommandLogsResponse
```

結合された stdout/stderr の出力を、それぞれのストリームに分離して解析します。

**引数**:

* `data` - STDOUT&#95;PREFIX と STDERR&#95;PREFIX のマーカーを含む結合ログのバイト列

**戻り値**:

stdout と stderr が分離された SessionCommandLogsResponse

#### demux&#95;log \{#demux&#95;log\}

```python
def demux_log(data: bytes) -> tuple[bytes, bytes]
```

結合された stdout/stderr のログデータをデマルチプレックスします。

**引数**:

* `data` - STDOUT&#95;PREFIX および STDERR&#95;PREFIX のマーカーを含む結合ログのバイト列

**戻り値**:

(stdout&#95;bytes, stderr&#95;bytes) のタプル