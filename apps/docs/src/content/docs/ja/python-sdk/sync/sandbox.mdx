---
title: "サンドボックス"
hideTitleOnPage: true
---

## サンドボックス

```python
class Sandbox(SandboxDto)
```

Daytona のサンドボックスを表します。

**属性**:

- `fs` _FileSystem_ - ファイルシステム操作インターフェース。
- `git` _Git_ - Git 操作インターフェース。
- `process` _Process_ - プロセス実行インターフェース。
- `computer_use` _ComputerUse_ - デスクトップ自動化のためのコンピューター使用インターフェース。
- `id` _str_ - サンドボックスの一意の識別子。
- `organization_id` _str_ - サンドボックスの組織 ID。
- `snapshot` _str_ - サンドボックスの作成に使用された Daytona のスナップショット。
- `user` _str_ - サンドボックス内で稼働する OS ユーザー。
- `env` _Dict[str, str]_ - サンドボックスで設定される環境変数。
- `labels` _Dict[str, str]_ - サンドボックスに付与されたカスタムラベル。
- `public` _bool_ - サンドボックスが公開アクセス可能かどうか。
- `target` _str_ - サンドボックスが実行されるランナーのターゲット(リージョン)。
- `cpu` _int_ - サンドボックスに割り当てられた CPU 数。
- `gpu` _int_ - サンドボックスに割り当てられた GPU 数。
- `memory` _int_ - サンドボックスに割り当てられたメモリ量（GiB）。
- `disk` _int_ - サンドボックスに割り当てられたディスク容量（GiB）。
- `state` _SandboxState_ - サンドボックスの現在の状態（例: "started"、"stopped"）。
- `error_reason` _str_ - サンドボックスがエラー状態の場合のエラーメッセージ。
- `backup_state` _SandboxBackupStateEnum_ - サンドボックスのバックアップの現在の状態。
- `backup_created_at` _str_ - バックアップが作成された日時。
- `auto_stop_interval` _int_ - 自動停止の間隔（分）。
- `auto_archive_interval` _int_ - 自動アーカイブの間隔（分）。
- `auto_delete_interval` _int_ - 自動削除の間隔（分）。
- `runner_domain` _str_ - サンドボックスのランナーのドメイン名。
- `volumes` _List[str]_ - サンドボックスに接続されたボリューム。
- `build_info` _str_ - 動的ビルドから作成された場合のサンドボックスのビルド情報。
- `created_at` _str_ - サンドボックスが作成された日時。
- `updated_at` _str_ - サンドボックスが最後に更新された日時。
- `network_block_all` _bool_ - サンドボックスのすべてのネットワークアクセスをブロックするかどうか。
- `network_allow_list` _str_ - サンドボックスで許可される CIDR ネットワークアドレスのカンマ区切りリスト。

#### Sandbox.\_\_init\_\_

```python
def __init__(sandbox_dto: SandboxDto, sandbox_api: SandboxApi,
             toolbox_api: ToolboxApi, code_toolbox: SandboxCodeToolbox)
```

新しいサンドボックスインスタンスを初期化します。

**引数**:

- `id` _str_ - サンドボックスの一意の識別子。
- `instance` _SandboxInstance_ - 基盤となるサンドボックスインスタンス。
- `sandbox_api` _SandboxApi_ - サンドボックス操作用の API クライアント。
- `toolbox_api` _ToolboxApi_ - ツールボックス操作用の API クライアント。
- `code_toolbox` _SandboxCodeToolbox_ - 言語固有のツールボックス実装。

#### Sandbox.refresh\_data

```python
def refresh_data() -> None
```

API からサンドボックスのデータをリフレッシュします。

**例**:

```python
sandbox.refresh_data()
print(f"Sandbox {sandbox.id}:")
print(f"State: {sandbox.state}")
print(f"Resources: {sandbox.cpu} CPU, {sandbox.memory} GiB RAM")
```

#### Sandbox.get\_user\_root\_dir

```python
@intercept_errors(message_prefix="Failed to get sandbox root directory: ")
def get_user_root_dir() -> str
```

サンドボックス内でログイン中のユーザーのルートディレクトリパスを取得します。

**戻り値**:

- `str` - ログイン中のユーザー用サンドボックスのルートディレクトリの絶対パス。
  

**例**:

```python
root_dir = sandbox.get_user_root_dir()
print(f"Sandbox root: {root_dir}")
```

#### Sandbox.create\_lsp\_server

```python
def create_lsp_server(language_id: LspLanguageId,
                      path_to_project: str) -> LspServer
```

新しい Language Server Protocol (LSP) サーバーインスタンスを作成します。

LSP サーバーは、コード補完、診断などの言語固有の機能を提供します。

**引数**:

- `language_id` _LspLanguageId_ - 言語サーバーの種類（例: LspLanguageId.PYTHON）。
- `path_to_project` _str_ - プロジェクトのルートディレクトリへのパス。相対パスはユーザーの
  ルートディレクトリを基準に解決されます。
  

**戻り値**:

- `LspServer` - 指定した言語向けに構成された新しい LSP サーバーインスタンス。
  

**例**:

```python
lsp = sandbox.create_lsp_server("python", "workspace/project")
```

#### Sandbox.set\_labels

```python
@intercept_errors(message_prefix="Failed to set labels: ")
def set_labels(labels: Dict[str, str]) -> Dict[str, str]
```

サンドボックスにラベルを設定します。

ラベルはサンドボックスを整理・識別するために使用できるキーと値のペアです。

**引数**:

- `labels` _Dict[str, str]_ - サンドボックスのラベルを表すキーと値のペアのディクショナリ。
  

**戻り値**:

  Dict[str, str]: 更新後のサンドボックスのラベルを含むディクショナリ。
  

**例**:

```python
new_labels = sandbox.set_labels({
    "project": "my-project",
    "environment": "development",
    "team": "backend"
})
print(f"Updated labels: {new_labels}")
```

#### Sandbox.start

```python
@intercept_errors(message_prefix="Failed to start sandbox: ")
@with_timeout(error_message=lambda self, timeout: (
    f"Sandbox {self.id} failed to start within the {timeout} seconds timeout period"
))
def start(timeout: Optional[float] = 60)
```

サンドボックスを起動し、準備完了になるまで待機します。

**引数**:

- `timeout` _Optional[float]_ - 待機する最大時間（秒）。0 はタイムアウトなしを意味します。デフォルトは 60 秒。
  

**送出**:

- `DaytonaError` - タイムアウトが負の場合、またはサンドボックスの起動に失敗／タイムアウトした場合。
  

**例**:

```python
sandbox = daytona.get_current_sandbox("my-sandbox")
sandbox.start(timeout=40)  # 最大 40 秒待機
print("Sandbox started successfully")
```

#### Sandbox.stop

```python
@intercept_errors(message_prefix="Failed to stop sandbox: ")
@with_timeout(error_message=lambda self, timeout: (
    f"Sandbox {self.id} failed to stop within the {timeout} seconds timeout period"
))
def stop(timeout: Optional[float] = 60)
```

サンドボックスを停止し、完全に停止するまで待機します。

**引数**:

- `timeout` _Optional[float]_ - 待機する最大時間（秒）。0 はタイムアウトなしを意味します。デフォルトは 60 秒。
  

**送出**:

- `DaytonaError` - タイムアウトが負の場合、またはサンドボックスの停止に失敗／タイムアウトした場合。
  

**例**:

```python
sandbox = daytona.get_current_sandbox("my-sandbox")
sandbox.stop()
print("Sandbox stopped successfully")
```

#### Sandbox.delete

```python
@intercept_errors(message_prefix="Failed to remove sandbox: ")
def delete(timeout: Optional[float] = 60) -> None
```

サンドボックスを削除します。

**引数**:

- `timeout` _Optional[float]_ - サンドボックス削除のタイムアウト（秒）。0 はタイムアウトなしを意味します。
  デフォルトは 60 秒。

#### Sandbox.wait\_for\_sandbox\_start

```python
@intercept_errors(
    message_prefix="Failure during waiting for sandbox to start: ")
@with_timeout(error_message=lambda self, timeout: (
    f"Sandbox {self.id} failed to become ready within the {timeout} seconds timeout period"
))
def wait_for_sandbox_start(timeout: Optional[float] = 60) -> None
```

サンドボックスが「started」状態になるまで待機します。サンドボックスのステータスをポーリングし、
「started」状態に達するか、エラーが発生するか、タイムアウトするまで待機します。

**引数**:

- `timeout` _Optional[float]_ - 待機する最大時間（秒）。0 はタイムアウトなしを意味します。デフォルトは 60 秒。
  

**送出**:

- `DaytonaError` - タイムアウトが負の場合、またはサンドボックスの起動に失敗／タイムアウトした場合。

#### Sandbox.wait\_for\_sandbox\_stop

```python
@intercept_errors(
    message_prefix="Failure during waiting for sandbox to stop: ")
@with_timeout(error_message=lambda self, timeout: (
    f"Sandbox {self.id} failed to become stopped within the {timeout} seconds timeout period"
))
def wait_for_sandbox_stop(timeout: Optional[float] = 60) -> None
```

サンドボックスが「stopped」状態になるまで待機します。サンドボックスのステータスをポーリングし、
「stopped」状態に達するか、エラーが発生するか、タイムアウトするまで待機します。サンドボックスが停止するまで最長 60 秒待機します。

**引数**:

- `timeout` _Optional[float]_ - 待機する最大時間（秒）。0 はタイムアウトなしを意味します。デフォルトは 60 秒。
  

**送出**:

- `DaytonaError` - タイムアウトが負の場合、またはサンドボックスの停止に失敗／タイムアウトした場合。

#### Sandbox.set\_autostop\_interval

```python
@intercept_errors(message_prefix="Failed to set auto-stop interval: ")
def set_autostop_interval(interval: int) -> None
```

サンドボックスの自動停止間隔を設定します。

サンドボックスは、指定した間隔のあいだアイドル状態（新しいイベントなし）が続くと自動的に停止します。
イベントには、SDK を介したサンドボックスとの状態変更や操作が含まれます。
サンドボックスのプレビュー経由の操作は含まれません。

**引数**:

- `interval` _int_ - 自動停止までの非アクティブ時間（分）。
  0 に設定すると自動停止を無効化します。デフォルトは 15。
  

**送出**:

- `DaytonaError` - interval が負の場合
  

**例**:

```python
# 1時間後に自動停止
sandbox.set_autostop_interval(60)
# または自動停止を無効化
sandbox.set_autostop_interval(0)
```

#### Sandbox.set\_auto\_archive\_interval

```python
@intercept_errors(message_prefix="Failed to set auto-archive interval: ")
def set_auto_archive_interval(interval: int) -> None
```

サンドボックスの自動アーカイブ間隔を設定します。

サンドボックスは、指定した間隔のあいだ連続して停止状態が続くと自動的にアーカイブされます。

**引数**:

- `interval` _int_ - 連続して停止してから自動アーカイブされるまでの分数。
  0 に設定すると最大間隔になります。デフォルトは 7 日。
  

**送出**:

- `DaytonaError` - interval が負の場合
  

**例**:

```python
# 1時間後に自動アーカイブ
sandbox.set_auto_archive_interval(60)
# または最大間隔を使用
sandbox.set_auto_archive_interval(0)
```

#### Sandbox.set\_auto\_delete\_interval

```python
@intercept_errors(message_prefix="Failed to set auto-delete interval: ")
def set_auto_delete_interval(interval: int) -> None
```

サンドボックスの自動削除間隔を設定します。

サンドボックスは、指定した間隔のあいだ連続して停止状態が続くと自動的に削除されます。

**引数**:

- `interval` _int_ - 連続して停止してから自動削除されるまでの分数。
  負の値に設定すると自動削除を無効化します。0 に設定すると停止時に即時削除します。
  既定では自動削除は無効です。
  

**例**:

```python
# 1時間後に自動削除
sandbox.set_auto_delete_interval(60)
# または停止時に即時削除
sandbox.set_auto_delete_interval(0)
# または自動削除を無効化
sandbox.set_auto_delete_interval(-1)
```

#### Sandbox.get\_preview\_link

```python
@intercept_errors(message_prefix="Failed to get preview link: ")
def get_preview_link(port: int) -> PortPreviewUrl
```

指定したポートのサンドボックスのプレビューリンクを取得します。ポートが閉じている場合は
自動的に開かれます。プライベートなサンドボックスでは、URL にアクセス権を与える
トークンが含まれます。

**引数**:

- `port` _int_ - プレビューリンクを開くポート。
  

**返り値**:

- `PortPreviewUrl` - プレビューリンクのレスポンスオブジェクト。`url`
  と（プライベートなサンドボックスにアクセスするための）`token` を含みます。
  

**例**:

```python
preview_link = sandbox.get_preview_link(3000)
print(f"Preview URL: {preview_link.url}")
print(f"Token: {preview_link.token}")
```

#### Sandbox.archive

```python
@intercept_errors(message_prefix="Failed to archive sandbox: ")
def archive() -> None
```

サンドボックスをアーカイブし、非アクティブ化して状態を保持します。サンドボックスが
アーカイブされると、ファイルシステム全体の状態はコスト効率の高いオブジェクトストレージに移動され、
長期間にわたりサンドボックスを利用可能な状態に保つことができます。アーカイブ状態と
停止状態のトレードオフは、アーカイブされたサンドボックスの起動には、そのサイズに応じて
より時間がかかる点です。アーカイブする前にサンドボックスは停止している必要があります。


## リソース

```python
@dataclass
class Resources()
```

サンドボックスのリソース設定。

**属性**:

- `cpu` _Optional[int]_ - 割り当てる CPU コア数。
- `memory` _Optional[int]_ - 割り当てるメモリ容量（GiB）。
- `disk` _Optional[int]_ - 割り当てるディスク容量（GiB）。
- `gpu` _Optional[int]_ - 割り当てる GPU 数。
  

**例**:

```python
resources = Resources(
    cpu=2,
    memory=4,  # 4GiB RAM
    disk=20,   # 20GiB disk
    gpu=1
)
params = CreateSandboxFromImageParams(
    image=Image.debian_slim("3.12"),
    language="python",
    resources=resources
)
```

