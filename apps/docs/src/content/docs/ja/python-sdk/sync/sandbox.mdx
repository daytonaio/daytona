---
title: "サンドボックス"
hideTitleOnPage: true
---

## サンドボックス \{#sandbox\}

```python
class Sandbox(SandboxDto)
```

Daytona サンドボックスを表します。

**属性**:

* `fs` *FileSystem* - ファイルシステム操作用インターフェース。
* `git` *Git* - Git 操作用インターフェース。
* `process` *Process* - プロセス実行用インターフェース。
* `computer_use` *ComputerUse* - デスクトップ自動化のためのコンピューター使用用インターフェース。
* `id` *str* - サンドボックスの一意の識別子。
* `name` *str* - サンドボックス名。
* `organization_id` *str* - サンドボックスの組織 ID。
* `snapshot` *str* - サンドボックスの作成に使用された Daytona のスナップショット。
* `user` *str* - サンドボックス内で実行中の OS ユーザー。
* `env` *Dict[str, str]* - サンドボックスで設定される環境変数。
* `labels` *Dict[str, str]* - サンドボックスに付与されるカスタムラベル。
* `public` *bool* - サンドボックスが公開アクセス可能かどうか。
* `target` *str* - サンドボックスが実行されるランナーのターゲット位置。
* `cpu` *int* - サンドボックスに割り当てられた CPU 数。
* `gpu` *int* - サンドボックスに割り当てられた GPU 数。
* `memory` *int* - サンドボックスに割り当てられたメモリ量（GiB）。
* `disk` *int* - サンドボックスに割り当てられたディスク容量（GiB）。
* `state` *SandboxState* - サンドボックスの現在の状態（例: &quot;started&quot;, &quot;stopped&quot;）。
* `error_reason` *str* - サンドボックスがエラー状態の場合のエラーメッセージ。
* `backup_state` *SandboxBackupStateEnum* - サンドボックスのバックアップの現在の状態。
* `backup_created_at` *str* - バックアップの作成時刻。
* `auto_stop_interval` *int* - 自動停止までの間隔（分）。
* `auto_archive_interval` *int* - 自動アーカイブまでの間隔（分）。
* `auto_delete_interval` *int* - 自動削除までの間隔（分）。
* `volumes` *List[str]* - サンドボックスに接続されたボリューム。
* `build_info` *str* - 動的ビルドから作成された場合のビルド情報。
* `created_at` *str* - サンドボックスの作成時刻。
* `updated_at` *str* - サンドボックスの最終更新時刻。
* `network_block_all` *bool* - サンドボックスのすべてのネットワークアクセスをブロックするかどうか。
* `network_allow_list` *str* - サンドボックスで許可される CIDR ネットワークアドレスのカンマ区切りリスト。

#### Sandbox.**init** \{#sandbox&#95;&#95;init&#95;&#95;\}

```python
def __init__(sandbox_dto: SandboxDto, sandbox_api: SandboxApi,
             toolbox_api: ToolboxApi, code_toolbox: SandboxCodeToolbox)
```

新規サンドボックスインスタンスを初期化します。

**引数**:

* `id` *str* - サンドボックスの一意の識別子。
* `instance` *SandboxInstance* - 基盤となるサンドボックスインスタンス。
* `sandbox_api` *SandboxApi* - サンドボックス操作用の API クライアント。
* `toolbox_api` *ToolboxApi* - ツールボックス操作用の API クライアント。
* `code_toolbox` *SandboxCodeToolbox* - 言語別のツールボックス実装。

#### Sandbox.refresh&#95;data \{#sandboxrefresh&#95;data\}

```python
@intercept_errors(message_prefix="サンドボックスデータの更新に失敗しました: ")
def refresh_data() -> None
```

API からサンドボックスのデータを最新状態に更新します。

**例**:

```python
sandbox.refresh_data()
print(f"サンドボックス {sandbox.id}:")
print(f"状態: {sandbox.state}")
print(f"リソース: {sandbox.cpu} CPU、{sandbox.memory} GiB RAM")
```

#### Sandbox.get&#95;user&#95;home&#95;dir \{#sandboxget&#95;user&#95;home&#95;dir\}

```python
@intercept_errors(message_prefix="ユーザーホームディレクトリの取得に失敗しました: ")
def get_user_home_dir() -> str
```

サンドボックス内にあるユーザーのホームディレクトリのパスを取得します。

**戻り値**:

* `str` - サンドボックス内のユーザーのホームディレクトリの絶対パス。

**例**:

```python
user_home_dir = sandbox.get_user_home_dir()
print(f"サンドボックスユーザーホーム: {user_home_dir}")
```

#### Sandbox.get&#95;work&#95;dir \{#sandboxget&#95;work&#95;dir\}

```python
@intercept_errors(message_prefix="作業ディレクトリパスの取得に失敗しました: ")
def get_work_dir() -> str
```

サンドボックス内の作業ディレクトリのパスを取得します。

**戻り値**:

* `str` - サンドボックスの作業ディレクトリへの絶対パス。Dockerfile に WORKDIR が指定されていればそれを使用し、指定がなければユーザーのホームディレクトリを使用します。

**例**:

```python
work_dir = sandbox.get_work_dir()
print(f"サンドボックス作業ディレクトリ: {work_dir}")
```

#### Sandbox.create&#95;lsp&#95;server \{#sandboxcreate&#95;lsp&#95;server\}

```python
def create_lsp_server(language_id: LspLanguageId,
                      path_to_project: str) -> LspServer
```

新しい Language Server Protocol (LSP) サーバー インスタンスを作成します。

LSP サーバーは、コード補完や診断などの言語固有の機能を提供します。

**引数**:

* `language_id` *LspLanguageId* - 言語サーバーの種類（例: LspLanguageId.PYTHON）。
* `path_to_project` *str* - プロジェクトのルートディレクトリへのパス。相対パスは
  サンドボックスの作業ディレクトリを基準に解決されます。

**戻り値**:

* `LspServer` - 指定した言語向けに構成された新しい LSP サーバー インスタンス。

**例**:

```python
lsp = sandbox.create_lsp_server("python", "workspace/project")
```

#### Sandbox.set&#95;labels \{#sandboxset&#95;labels\}

```python
@intercept_errors(message_prefix="ラベルの設定に失敗しました: ")
def set_labels(labels: Dict[str, str]) -> Dict[str, str]
```

サンドボックスのラベルを設定します。

ラベルは、サンドボックスを整理・識別するためのキーと値のペアです。

**引数**:

* `labels` *Dict[str, str]* - サンドボックスのラベルを表すキーと値ペアの辞書。

**戻り値**:

Dict[str, str]: 更新後のサンドボックスのラベルを含む辞書。

**例**:

```python
new_labels = sandbox.set_labels({
    "project": "my-project",
    "environment": "development",
    "team": "backend"
})
print(f"更新されたラベル: {new_labels}")
```

#### Sandbox.start \{#sandboxstart\}

```python
@intercept_errors(message_prefix="サンドボックスの開始に失敗しました: ")
@with_timeout(error_message=lambda self, timeout: (
    f"サンドボックス {self.id} は {timeout} 秒のタイムアウト期間内に開始できませんでした"
))
def start(timeout: Optional[float] = 60)
```

サンドボックスを起動し、使用可能になるまで待機します。

**引数**:

* `timeout` *Optional[float]* - 待機する最大時間（秒）。0 はタイムアウトなしを意味します。既定値は 60 秒です。

**例外**:

* `DaytonaError` - `timeout` が負の場合、またはサンドボックスの起動に失敗した場合やタイムアウトした場合。

**例**:

```python
sandbox = daytona.get_current_sandbox("my-sandbox")
sandbox.start(timeout=40)  # 最大40秒待機
print("サンドボックスが正常に開始されました")
```

#### Sandbox.stop \{#sandboxstop\}

```python
@intercept_errors(message_prefix="サンドボックスの停止に失敗しました: ")
@with_timeout(error_message=lambda self, timeout: (
    f"サンドボックス {self.id} は {timeout} 秒のタイムアウト期間内に停止できませんでした"
))
def stop(timeout: Optional[float] = 60)
```

サンドボックスを停止し、完全に停止するまで待機します。

**引数**:

* `timeout` *Optional[float]* - 待機する最大時間（秒）。0 はタイムアウトなしを意味します。デフォルトは 60 秒です。

**例外**:

* `DaytonaError` - タイムアウトが負の値の場合、サンドボックスの停止に失敗した場合、またはタイムアウトした場合

**例**:

```python
sandbox = daytona.get_current_sandbox("my-sandbox")
sandbox.stop()
print("サンドボックスが正常に停止されました")
```

#### Sandbox.delete \{#sandboxdelete\}

```python
@intercept_errors(message_prefix="サンドボックスの削除に失敗しました: ")
def delete(timeout: Optional[float] = 60) -> None
```

サンドボックスを削除します。

**引数**:

* `timeout` *Optional[float]* - サンドボックス削除のタイムアウト（秒）。0 はタイムアウトなしを意味します。
  デフォルトは 60 秒です。

#### Sandbox.wait&#95;for&#95;sandbox&#95;start \{#sandboxwait&#95;for&#95;sandbox&#95;start\}

```python
@intercept_errors(
    message_prefix="サンドボックスの開始待機中に失敗: ")
@with_timeout(error_message=lambda self, timeout: (
    f"サンドボックス {self.id} は {timeout} 秒のタイムアウト期間内に準備完了になりませんでした"
))
def wait_for_sandbox_start(timeout: Optional[float] = 60) -> None
```

サンドボックスが「started」状態に到達するまで待機します。サンドボックスのステータスをポーリングし、「started」状態に達するか、エラーが発生するか、タイムアウトするまで続行します。

**引数**:

* `timeout` *Optional[float]* - 待機する最大時間（秒）。0 はタイムアウトなしを意味します。デフォルトは 60 秒。

**例外**:

* `DaytonaError` - タイムアウトが負の値の場合、サンドボックスの起動に失敗した場合、またはタイムアウトした場合

#### Sandbox.wait&#95;for&#95;sandbox&#95;stop \{#sandboxwait&#95;for&#95;sandbox&#95;stop\}

```python
@intercept_errors(
    message_prefix="サンドボックスの停止待機中に失敗: ")
@with_timeout(error_message=lambda self, timeout: (
    f"サンドボックス {self.id} は {timeout} 秒のタイムアウト期間内に停止できませんでした"
))
def wait_for_sandbox_stop(timeout: Optional[float] = 60) -> None
```

サンドボックスが「stopped」状態に到達するまで待機します。サンドボックスのステータスをポーリングし、
「stopped」状態になるか、エラーが発生するか、タイムアウトするまで継続します。サンドボックスが停止するまで最大60秒間待機します。
停止後に自動的に削除される一時的なサンドボックスを考慮し、「destroyed」を「stopped」と同等として扱います。

**引数**:

* `timeout` *Optional[float]* - 秒単位の最大待機時間。0 はタイムアウトなしを意味します。既定値は 60 秒。

**例外**:

* `DaytonaError` - timeout が負の場合、サンドボックスの停止に失敗した場合、またはタイムアウトした場合。

#### Sandbox.set&#95;autostop&#95;interval \{#sandboxset&#95;autostop&#95;interval\}

```python
@intercept_errors(message_prefix="自動停止間隔の設定に失敗しました: ")
def set_autostop_interval(interval: int) -> None
```

サンドボックスの自動停止間隔を設定します。

指定した間隔のあいだアイドル状態（新しいイベントなし）が続くと、サンドボックスは自動的に停止します。
イベントには、SDK を介したサンドボックスの状態変更や操作が含まれます。
サンドボックスのプレビュー経由の操作は含まれません。

**引数**:

* `interval` *int* - 自動停止までの非アクティブな時間（分）。
  0 に設定すると自動停止を無効化します。既定値は 15。

**送出**:

* `DaytonaError` - interval が負の値の場合

**例**:

```python
# 1時間後に自動停止
sandbox.set_autostop_interval(60)
# または自動停止を無効化
sandbox.set_autostop_interval(0)
```

#### Sandbox.set&#95;auto&#95;archive&#95;interval \{#sandboxset&#95;auto&#95;archive&#95;interval\}

```python
@intercept_errors(message_prefix="自動アーカイブ間隔の設定に失敗しました: ")
def set_auto_archive_interval(interval: int) -> None
```

サンドボックスの自動アーカイブ間隔を設定します。

指定した間隔のあいだ連続して停止状態が続くと、サンドボックスは自動的にアーカイブされます。

**引数**:

* `interval` *int* - 連続して停止してから自動アーカイブされるまでの分（分単位）。
  最大間隔にするには 0 を指定します。既定値は 7 日です。

**送出**:

* `DaytonaError` - interval が負の場合

**例**:

```python
# 1時間後に自動アーカイブ
sandbox.set_auto_archive_interval(60)
# または最大間隔を使用
sandbox.set_auto_archive_interval(0)
```

#### Sandbox.set&#95;auto&#95;delete&#95;interval \{#sandboxset&#95;auto&#95;delete&#95;interval\}

```python
@intercept_errors(message_prefix="自動削除間隔の設定に失敗しました: ")
def set_auto_delete_interval(interval: int) -> None
```

サンドボックスの自動削除間隔を設定します。

指定した間隔のあいだ連続して停止状態が続くと、サンドボックスは自動的に削除されます。

**引数**:

* `interval` *int* - 連続して停止してから自動削除されるまでの時間（分）。
  自動削除を無効にするには負の値を設定します。停止と同時に即時削除するには 0 を設定します。
  既定では自動削除は無効です。

**例**:

```python
# 1時間後に自動削除
sandbox.set_auto_delete_interval(60)
# または停止時に即座に削除
sandbox.set_auto_delete_interval(0)
# または自動削除を無効化
sandbox.set_auto_delete_interval(-1)
```

#### Sandbox.get&#95;preview&#95;link \{#sandboxget&#95;preview&#95;link\}

```python
@intercept_errors(message_prefix="プレビューリンクの取得に失敗しました: ")
def get_preview_link(port: int) -> PortPreviewUrl
```

指定したポートのサンドボックスに対するプレビューリンクを取得します。ポートが閉じている場合は自動的に開きます。プライベートなサンドボックスの場合は、URL へのアクセスを許可するトークンが含まれます。

**引数**:

* `port` *int* - プレビューリンクを公開するポート。

**戻り値**:

* `PortPreviewUrl` - プレビューリンクのレスポンスオブジェクト。`url` と
  `token`（プライベートなサンドボックスにアクセスするため）を含みます。

**例**:

```python
preview_link = sandbox.get_preview_link(3000)
print(f"プレビューURL: {preview_link.url}")
print(f"トークン: {preview_link.token}")
```

#### Sandbox.archive \{#sandboxarchive\}

```python
@intercept_errors(message_prefix="サンドボックスのアーカイブに失敗しました: ")
def archive() -> None
```

サンドボックスをアーカイブし、非アクティブ化して状態を保持します。サンドボックスを
アーカイブすると、ファイルシステム全体の状態がコスト効率の高いオブジェクトストレージに移され、
長期間にわたりサンドボックスを利用可能な状態で保持できます。アーカイブ状態と停止状態のトレードオフは、
サンドボックスのサイズに応じて、アーカイブされたサンドボックスの起動により時間がかかる点です。
アーカイブする前にサンドボックスを停止する必要があります。

#### Sandbox.create&#95;ssh&#95;access \{#sandboxcreate&#95;ssh&#95;access\}

```python
@intercept_errors(message_prefix="SSHアクセスの作成に失敗しました: ")
def create_ssh_access(
        expires_in_minutes: Optional[int] = None) -> SshAccessDto
```

サンドボックスのSSHアクセストークンを作成します。

**引数**:

* `expires_in_minutes` *Optional[int]* - SSHアクセストークンの有効期間（分）。

#### Sandbox.revoke&#95;ssh&#95;access \{#sandboxrevoke&#95;ssh&#95;access\}

```python
@intercept_errors(message_prefix="SSHアクセスの取り消しに失敗しました: ")
def revoke_ssh_access(token: str) -> None
```

サンドボックスのSSHアクセス・トークンを取り消します。

**引数**:

* `token` *str* - 取り消すトークン。

#### Sandbox.validate&#95;ssh&#95;access \{#sandboxvalidate&#95;ssh&#95;access\}

```python
@intercept_errors(message_prefix="SSHアクセスの検証に失敗しました: ")
def validate_ssh_access(token: str) -> SshAccessValidationDto
```

サンドボックスのSSHアクセス用トークンを検証します。

**引数**:

* `token` *str* - 検証対象のトークン。

## ページネートされたサンドボックス \{#paginatedsandboxes\}

```python
class PaginatedSandboxes(PaginatedSandboxesDto)
```

Daytona のサンドボックスに対するページネーション付きの一覧を表します。

**属性**:

* `items` *List[Sandbox]* - 現在のページに含まれるサンドボックス インスタンスの一覧。
* `total` *int* - 全ページ合計のサンドボックス数。
* `page` *int* - 現在のページ番号。
* `total_pages` *int* - 総ページ数。

## リソース \{#resources\}

```python
@dataclass
class Resources()
```

サンドボックスのリソース設定。

**属性**:

* `cpu` *Optional[int]* - 割り当てるCPUコア数。
* `memory` *Optional[int]* - 割り当てるメモリ容量（GiB）。
* `disk` *Optional[int]* - 割り当てるディスク容量（GiB）。
* `gpu` *Optional[int]* - 割り当てるGPU数。

**例**:

```python
resources = Resources(
    cpu=2,
    memory=4,  # 4GiB RAM
    disk=20,   # 20GiB ディスク
    gpu=1
)
params = CreateSandboxFromImageParams(
    image=Image.debian_slim("3.12"),
    language="python",
    resources=resources
)
```
