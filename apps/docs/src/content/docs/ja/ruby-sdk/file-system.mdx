---
title: "ファイルシステム"
hideTitleOnPage: true
---

## FileSystem \{#filesystem\}

新しい FileSystem インスタンスを表すメインクラスです。

### コンストラクタ \{#constructors\}

#### new FileSystem() \{#new-filesystem\}

```ruby
def initialize(sandbox_id:, toolbox_api:, otel_state:)

```

新しい `FileSystem` インスタンスを初期化します。

**パラメータ**:

* `sandbox_id` *String* - サンドボックスの ID
* `toolbox_api` *DaytonaToolboxApiClient:FileSystemApi* - サンドボックス操作用の API クライアント
* `otel_state` *Daytona:OtelState, nil* - OTel の状態、または `nil`

**戻り値**:

* `FileSystem` - 新しい `FileSystem` インスタンス

### メソッド \{#methods\}

#### sandbox_id() \{#sandbox_id\}

```ruby
def sandbox_id()

```

**戻り値**:

* `String` - サンドボックス ID を表す文字列

#### toolbox_api() \{#toolbox_api\}

```ruby
def toolbox_api()

```

**戻り値**:

* `DaytonaToolboxApiClient:FileSystemApi` - サンドボックス操作用の API クライアント

#### create_folder() \{#create_folder\}

```ruby
def create_folder(path, mode)

```

サンドボックス内の指定されたパスに、指定されたパーミッションで新しいディレクトリを作成します。

**パラメータ**:

* `path` *String* - フォルダーを作成するパス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。
* `mode` *String* - 8進数形式のフォルダーのパーミッション (例: &quot;755&quot; は rwxr-xr-x を表します)。

**戻り値**:

* `void`

**スローされる例外**:

* `Daytona:Sdk:Error` - 操作が失敗した場合にスローされます

**例:**

```ruby
# 標準的な権限でディレクトリを作成
sandbox.fs.create_folder("workspace/data", "755")

# Create a private directory
sandbox.fs.create_folder("workspace/secrets", "700")

```

#### delete_file() \{#delete_file\}

```ruby
def delete_file(path, recursive:)

```

サンドボックスからファイルを削除します。

**パラメータ**:

* `path` *String* - 削除するファイルへのパス。相対パスはサンドボックスの作業ディレクトリを基準として解決されます。
* `recursive` *Boolean* - ファイルがディレクトリである場合、それを削除するには true にする必要があります。

**戻り値**:

* `void`

**スローされる例外**:

* `Daytona:Sdk:Error` - 操作が失敗した場合

**使用例:**

```ruby
# ファイルを削除する
sandbox.fs.delete_file("workspace/data/old_file.txt")

# ディレクトリを再帰的に削除する
sandbox.fs.delete_file("workspace/old_dir", recursive: true)

```

#### get_file_info() \{#get_file_info\}

```ruby
def get_file_info(path)

```

ファイルまたはディレクトリの詳細情報（サイズ、パーミッション、タイムスタンプなどを含む）を取得します。

**パラメーター**:

* `path` *String* - ファイルまたはディレクトリへのパス。相対パスはサンドボックスの作業ディレクトリを基準として解決されます。

**戻り値**:

* `DaytonaApiClient:FileInfo` - 詳細なファイル情報

**例外**:

* `Daytona:Sdk:Error` - 操作が失敗した場合に送出されます

**使用例:**

```ruby
# Get file metadata
info = sandbox.fs.get_file_info("workspace/data/file.txt")
puts "Size: #{info.size} bytes"
puts "Modified: #{info.mod_time}"
puts "Mode: #{info.mode}"

# パスがディレクトリであるかを確認
info = sandbox.fs.get_file_info("workspace/data")
puts "Path is a directory" if info.is_dir

```

#### list_files() \{#list_files\}

```ruby
def list_files(path)

```

指定されたパス内のファイルとディレクトリを一覧表示し、その情報を返します。`ls -l` コマンドと同様の動作です。

**パラメータ**:

* `path` *String* - 内容を一覧表示するディレクトリへのパス。相対パスは
  サンドボックスの作業ディレクトリを基準として解決されます。

**戻り値**:

* `Array\<DaytonaApiClient:FileInfo\>` - ファイルおよびディレクトリ情報のリスト

**送出される例外**:

* `Daytona:Sdk:Error` - 操作が失敗した場合に送出されます

**使用例:**

```ruby
# ディレクトリの内容を一覧表示
files = sandbox.fs.list_files("workspace/data")

# ファイルとそのサイズを出力
files.each do |file|
  puts "#{file.name}: #{file.size} bytes" unless file.is_dir
end

# ディレクトリのみを一覧表示
dirs = files.select(&:is_dir)
puts "Subdirectories: #{dirs.map(&:name).join(', ')}"

```

#### download_file() \{#download_file\}

```ruby
def download_file(remote_path, local_path)

```

サンドボックスからファイルをダウンロードします。ファイルの内容を文字列として返します。
このメソッドは、ファイルをディスクに保存せずにメモリ上に読み込みたい場合に便利です。
小容量のファイルに対してのみ使用できます。

**パラメーター**:

* `remote_path` *String* - サンドボックス内のファイルへのパス。相対パスは
  サンドボックスの作業ディレクトリを基準に解決されます。
* `local_path` *String, nil* - ファイルをローカルに保存するための省略可能なパス。指定された場合、ファイルはディスクに保存されます。

**戻り値**:

* `File, nil` - `local_path` が nil の場合はファイル、それ以外の場合は nil

**スローされる例外**:

* `Daytona:Sdk:Error` - 操作が失敗した場合

**例:**

```ruby
# Download and get file content
content = sandbox.fs.download_file("workspace/data/file.txt")
puts content

# ファイルをダウンロードしてローカルに保存
sandbox.fs.download_file("workspace/data/file.txt", "local_copy.txt")
size_mb = File.size("local_copy.txt") / 1024.0 / 1024.0
puts "Size of the downloaded file: #{size_mb} MB"

```

#### upload_file() \{#upload_file\}

```ruby
def upload_file(source, remote_path)

```

サンドボックス内の指定されたパスにファイルをアップロードします。宛先パスにすでに
ファイルが存在する場合は上書きされます。

**パラメーター**:

* `source` *String, IO* - 文字列/バイト列としてのファイル内容、ローカルファイルパス、または IO オブジェクト。
* `remote_path` *String* - 宛先ファイルへのパス。相対パスはサンドボックスの作業ディレクトリを基準として解決されます。

**戻り値**:

* `void`

**スローされる例外**:

* `Daytona:Sdk:Error` - 操作が失敗した場合

**使用例:**

```ruby
# 文字列コンテンツからテキストファイルをアップロードする
content = "Hello, World!"
sandbox.fs.upload_file(content, "tmp/hello.txt")

# Upload a local file
sandbox.fs.upload_file("local_file.txt", "tmp/file.txt")

# Upload binary data
data = { key: "value" }.to_json
sandbox.fs.upload_file(data, "tmp/config.json")

```

#### upload_files() \{#upload_files\}

```ruby
def upload_files(files)

```

複数のファイルをサンドボックスにアップロードします。指定されたアップロード先パスにすでにファイルが存在する場合は、
上書きされます。

**パラメータ**:

* `files` *Array&lt;FileUpload&gt;* - アップロードするファイルの一覧。

**戻り値**:

* `void`

**例外**:

* `Daytona:Sdk:Error` - 操作が失敗した場合にスローされます

**使用例:**

```ruby
# 複数のファイルをアップロード
files = [
  FileUpload.new("Content of file 1", "/tmp/file1.txt"),
  FileUpload.new("workspace/data/file2.txt", "/tmp/file2.txt"),
  FileUpload.new('{"key": "value"}', "/tmp/config.json")
]
sandbox.fs.upload_files(files)

```

#### find_files() \{#find_files\}

```ruby
def find_files(path, pattern)

```

`grep` コマンドと同様に、指定したパターンを含むファイルを検索します。

**Parameters**:

* `path` *String* - 検索対象のファイルまたはディレクトリへのパス。パスがディレクトリの場合、
  検索は再帰的に実行されます。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。
* `pattern` *String* - ファイルの内容と照合する検索パターン。

**Returns**:

* `Array\<DaytonaApiClient:Match\>` - ファイル内で見つかった一致箇所のリスト

**Raises**:

* `Daytona:Sdk:Error` - 操作が失敗した場合に送出されます

**Examples:**

```ruby
# Rubyファイル内のTODOを検索
matches = sandbox.fs.find_files("workspace/src", "TODO:")
matches.each do |match|
  puts "#{match.file}:#{match.line}: #{match.content.strip}"
end

```

#### search_files() \{#search_files\}

```ruby
def search_files(path, pattern)

```

指定したパターンと名前が一致するファイルおよびディレクトリを検索します。
パターンには、単純な文字列またはグロブパターンを指定できます。

**パラメーター**:

* `path` *String* - 検索を開始するルートディレクトリへのパス。相対パスは
  サンドボックスの作業ディレクトリを基準として解決されます。
* `pattern` *String* - ファイル名に対してマッチさせるパターン。グロブパターンを
  サポートします（例: Ruby ファイルなら &quot;*.rb&quot;）。

**戻り値**:

* `DaytonaApiClient:SearchFilesResponse`

**スローされる例外**:

* `Daytona:Sdk:Error` - 操作が失敗した場合

**使用例:**

```ruby
# すべてのRubyファイルを検索
result = sandbox.fs.search_files("workspace", "*.rb")
result.files.each { |file| puts file }

# 特定のプレフィックスを持つファイルを検索
result = sandbox.fs.search_files("workspace/data", "test_*")
puts "Found #{result.files.length} test files"

```

#### move_files() \{#move_files\}

```ruby
def move_files(source, destination)

```

ファイルまたはディレクトリを移動または名前を変更します。移動先の親ディレクトリは、あらかじめ存在している必要があります。

**パラメータ**:

* `source` *String* - ソースファイルまたはディレクトリへのパス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。
* `destination` *String* - 宛先へのパス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。

**戻り値**:

* `void`

**送出される例外**:

* `Daytona:Sdk:Error` - 操作に失敗した場合

**例:**

```ruby
# ファイル名を変更する
sandbox.fs.move_files(
  "workspace/data/old_name.txt",
  "workspace/data/new_name.txt"
)

# ファイルを別のディレクトリに移動する
sandbox.fs.move_files(
  "workspace/data/file.txt",
  "workspace/archive/file.txt"
)

# ディレクトリを移動する
sandbox.fs.move_files(
  "workspace/old_dir",
  "workspace/new_dir"
)

```

#### replace_in_files() \{#replace_in_files\}

```ruby
def replace_in_files(files:, pattern:, new_value:)

```

複数のファイルに対して検索および置換処理を実行します。

**Parameters**:

* `files` *Array&lt;String&gt;* - 置換を実行するファイルパスの一覧。相対パスは
  サンドボックスの作業ディレクトリを基準に解決されます。
* `pattern` *String* - 検索するパターン。
* `new_value` *String* - 一致した部分を置き換えるテキスト。

**Returns**:

* `Array\<DaytonaApiClient:ReplaceResult\>` - 各ファイルで行われた置換内容を示す結果のリスト

**Raises**:

* `Daytona:Sdk:Error` - 操作が失敗した場合に発生します

**Examples:**

```ruby
# 特定のファイル内で置換
results = sandbox.fs.replace_in_files(
  files: ["workspace/src/file1.rb", "workspace/src/file2.rb"],
  pattern: "old_function",
  new_value: "new_function"
)

# 結果を表示
results.each do |result|
  if result.success
    puts "#{result.file}: #{result.success}"
  else
    puts "#{result.file}: #{result.error}"
  end
end

```

#### set_file_permissions() \{#set_file_permissions\}

```ruby
def set_file_permissions(path:, mode:, owner:, group:)

```

ファイルまたはディレクトリのパーミッションと所有権を設定します。いずれのパラメータも nil にすると、その属性は変更されずに保持されます。

**パラメータ**:

* `path` *String* - ファイルまたはディレクトリへのパス。相対パスはサンドボックスの作業ディレクトリを基準として解決されます。
* `mode` *String, nil* - 8 進数形式のファイルモード／パーミッション（例: &quot;644&quot; は rw-r--r--）。
* `owner` *String, nil* - ファイルの所有ユーザー。
* `group` *String, nil* - ファイルの所有グループ。

**戻り値**:

* `void`

**送出される例外**:

* `Daytona:Sdk:Error` - 操作が失敗した場合

**例:**

```ruby
# ファイルを実行可能にする
sandbox.fs.set_file_permissions(
  path: "workspace/scripts/run.sh",
  mode: "755"  # rwxr-xr-x
)

# Change file owner
sandbox.fs.set_file_permissions(
  path: "workspace/data/file.txt",
  owner: "daytona",
  group: "daytona"
)

```
