---
title: スナップショット
---

import { TabItem, Tabs } from '@astrojs/starlight/components'
import Label from '@components/Label.astro'

スナップショットは、Daytona のサンドボックスに必要な依存関係、ツール、環境設定、リソース要件をすべて含む事前構成済みのテンプレートです。Daytona は、標準的な [Docker](https://www.docker.com/) あるいは [OCI](https://opencontainers.org/) 互換イメージからのスナップショット作成をサポートしています。

## スナップショットの作成 \{#creating-snapshots\}

サンドボックスを起動する際、Daytona は、`python`、`node`、`pip` および一般的な pip パッケージなどの有用なユーティリティが事前インストールされたシンプルなイメージに基づくスナップショットを使用します。詳細は[下記](#default-snapshot)をご参照ください。

この挙動は上書き可能で、ダッシュボードにアクセスし、[Snapshots](https://app.daytona.io/dashboard/snapshots) をクリックしてから `Create Snapshot` を選択することで、カスタムスナップショットを作成できます。

スナップショットのイメージには、Docker Hub の `alpine:3.21.3` や `debian:12.10` のような公開イメージ、または他のパブリックコンテナレジストリ（例: `my-public-registry.com/custom-alpine:3.21`）にある任意のイメージの名前とタグを入力できます。

entrypoint フィールドは任意です。イメージに常駐プロセスを持つ entrypoint がない場合、Daytona は自動的に `sleep infinity` を実行し、コンテナが作成直後に即時終了しないようにします。

:::note
`latest` タグ付きのイメージは頻繁に更新されるため、特定のタグ（例: `0.1.0`）のみがサポートされます。同様に、`lts` や `stable` といったタグにも同様の考え方が適用されるため、イメージ定義時にはそれらの使用を避けることを推奨します。
:::

スナップショットがプル・検証され、`Active` 状態になれば使用可能です。使用するカスタムスナップショットを指定するために、`CreateSandboxFromSnapshotParams` オブジェクトを定義します:

<Tabs>
  <TabItem label="Python" icon="seti:python">
    ```python
    sandbox = daytona.create(CreateSandboxFromSnapshotParams(
        snapshot="my-snapshot-name",
    ))
    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    const sandbox = await daytona.create({
      snapshot: "my-snapshot-name",
    })
    ```
  </TabItem>
</Tabs>

完全な例:

<Tabs>
  <TabItem label="Python" icon="seti:python">
    ```python
    from daytona import Daytona, CreateSandboxFromSnapshotParams

    daytona = Daytona()

    sandbox = daytona.create(CreateSandboxFromSnapshotParams(
        snapshot="my-snapshot-name",
    ))

    response = sandbox.process.code_run('print("Sum of 3 and 4 is " + str(3 + 4))')
    if response.exit_code != 0:
        print(f"Error running code: {response.exit_code} {response.result}")
    else:
        print(response.result)

    sandbox.delete()

    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    import { Daytona } from '@daytonaio/sdk'

    async function main() {
      // Initialize the Daytona client
      const daytona = new Daytona()

      try {
        // Create the Sandbox instance
        const sandbox = await daytona.create({
          snapshot: "my-snapshot-name",
        })
        // Run the code securely inside the Sandbox
        const response = await sandbox.process.codeRun(
          'print("Sum of 3 and 4 is " + str(3 + 4))',
        )
        if (response.exitCode !== 0) {
          console.error('Error running code:', response.exitCode, response.result)
        } else {
          console.log(response.result)
        }
      } catch (error) {
        console.error('Sandbox flow error:', error)
      } finally {
        // Clean up the Sandbox
        await sandbox.delete()
      }
    }

    main()
    ```
  </TabItem>
</Tabs>

### スナップショットのリソース \{#snapshot-resources\}

スナップショットには、Daytona サンドボックスのリソース要件が含まれます。標準では、Daytona サンドボックスは **1 vCPU**、**1GB RAM**、**3GiB ディスク**が割り当てられます。

組織ごとのサンドボックスのリソース上限は 4 vCPU、8GB RAM、10GB ディスクです。より高いリソースが必要な場合は、[support@daytona.io](mailto:support@daytona.io) までユースケースを添えてお問い合わせください。

利用可能なリソースと上限は[ダッシュボード](https://app.daytona.io/dashboard/limits)で確認できます。

<Tabs>
  <TabItem label="Python" icon="seti:python">
    ```python
    from daytona import (
        Daytona,
        CreateSnapshotParams,
        Image,
        Resources,
        CreateSandboxFromSnapshotParams,
    )

    daytona = Daytona()

    # カスタムリソースのスナップショットを作成

    daytona.snapshot.create(
        CreateSnapshotParams(
            name="my-snapshot",
            image=Image.debian_slim("3.12"),
            resources=Resources(
              cpu=2,
              memory=4,
              disk=8,
            ),
        ),
        on_logs=print,
    )

    # カスタムスナップショットでサンドボックスを作成

    sandbox = daytona.create(
        CreateSandboxFromSnapshotParams(
            snapshot="my-snapshot",
        )
    )

    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    import { Daytona, Image } from "@daytonaio/sdk";

    async function main() {
      const daytona = new Daytona();

      // カスタムリソースのスナップショットを作成
      await daytona.snapshot.create(
        {
          name: "my-snapshot",
          image: Image.debianSlim("3.13"),
          resources: {
            cpu: 2,
            memory: 4,
            disk: 8,
          },
        },
        { onLogs: console.log }
      );

      // カスタムスナップショットでサンドボックスを作成
      const sandbox = await daytona.create({
        snapshot: "my-snapshot",
      });
    }

    main();
    ```
  </TabItem>
</Tabs>

:::note
すべてのリソースパラメータは任意です。指定しない場合はデフォルト値が使用されます。
:::

### プライベートレジストリからのイメージ \{#images-from-private-registries\}

公開されていないイメージからスナップショットを作成するには、まずイメージのプライベート Container Registry を追加します。

1. ダッシュボードの [Registries](https://app.daytona.io/dashboard/registries) ページに移動します
2. `Add Registry` ボタンをクリックします
3. カスタム名、URL、ユーザー名、パスワード、（該当する場合は）プロジェクトを入力します
4. Container Registry が作成されたら、[Snapshots](https://app.daytona.io/dashboard/snapshots) ページに戻ります
5. スナップショットを作成する際は、レジストリの URL とプロジェクト名（該当する場合）を含むプライベートイメージ名全体を必ず入力してください — `my-private-registry.com/<my-project>/custom-alpine:3.21`

次のステップは同様です。`CreateSandboxFromSnapshotParams` フィールドでカスタムスナップショットを使用するように設定すれば、追加の認証は不要です。

#### プライベートな Docker Hub イメージの使用 \{#using-a-private-docker-hub-image\}

プライベートな Docker Hub イメージを使用するには、Docker Hub の認証情報で[コンテナレジストリを追加](/docs/ja/snapshots#images-from-private-registries)します。

* **Registry URL**: `docker.io` を指定
* **Username**: Docker Hub のユーザー名（該当プライベートイメージへのアクセス権があるアカウント）
* **Password**: [Docker Hub のパーソナルアクセストークン](https://docs.docker.com/docker-hub/access-tokens/) を使用（アカウントのパスワードは使用しない）
* **スナップショットの作成**: レジストリを追加したら、イメージ名にフルパスを指定してスナップショットを作成します: `docker.io/<username>/<image>:<tag>`

### ローカルイメージの使用 \{#using-a-local-image\}

プライベートコンテナレジストリを手動で用意してイメージをプッシュする手間を省くために、[Daytona CLI](/docs/ja/getting-started#setting-up-the-daytona-cli) を使うと、ローカルイメージまたはローカルの Dockerfile からスナップショットを作成し、それをサンドボックスで利用できます。

`docker images` を実行して使用したいイメージとタグがあることを確認したら、`daytona snapshot push <your_local_docker_image>` コマンドでスナップショットを作成して Daytona にプッシュします。例:

```bash
daytona snapshot push custom-alpine:3.21 --name alpine-minimal
```

:::tip
`--cpu`、`--memory`、`--disk` フラグで、作成されるサンドボックスに割り当てるリソースを指定できます。

例えば、`daytona snapshot push custom-alpine:3.21 --name alpine-minimal --cpu 2 --memory 4 --disk 8` は、2 vCPU、4GiB のメモリ、8GiB のディスク容量を持つ Alpine サンドボックスを作成します。
:::

:::note
Daytona はローカルイメージが AMD64 アーキテクチャ向けにビルドされていることを想定しています。したがって、マシンが異なるアーキテクチャの場合は、Docker イメージのビルド時に `--platform=linux/amd64` フラグが必要です。

詳細は [CLI ドキュメント](/docs/ja/tools/cli#daytona-snapshot-push) を参照してください。
:::

まだ目的のイメージをビルドしておらず、Dockerfile が用意できている場合は、SDK の宣言的ビルダーを利用できます。詳細は[こちら](/docs/ja/getting-started#declarative-builder)をご覧ください。

別の方法として、CLI で実行する場合は、`create` の `--dockerfile` フラグに使用したい Dockerfile のパスを指定すると、Daytona がスナップショットをビルドします。COPY/ADD コマンドは自動的に解析されてコンテキストに追加されます。コンテキストにファイルを手動で追加するには `--context` フラグを使用します。

```bash
daytona snapshot create data-analysis01 --dockerfile ./Dockerfile
```

```text
/Users/idagelic/docs/Dockerfile からイメージをビルド中
Step 1/5 : FROM alpine:latest

...

 ⡿  スナップショットの検証を待機中 ...

 ...

 ✓  このスナップショットを使って新しいサンドボックスを作成するには 'harbor-transient.internal.daytona.app/daytona/trying-daytona:0.0.1' を使用してください

```

## スナップショットの削除 \{#deleting-snapshots\}

カスタムスナップショットの削除は簡単です。[Snapshots](https://app.daytona.io/dashboard/snapshots) ページに移動し、削除したいスナップショットの行末にある三点リーダー（︙）をクリックして表示される `Delete` ボタンを選択します。

:::tip

スナップショットを一時的に無効にしたい場合は、削除ではなく `Disable` をクリックします。これにより、そのスナップショットは新規サンドボックスでは使用されなくなりますが、削除はされません。

:::

## サンドボックスで Docker を実行する \{#running-docker-in-a-sandbox\}

Daytona のサンドボックスでは内部で Docker コンテナを実行できます（**Docker-in-Docker**）。これにより、コンテナ化アプリケーションのビルド、テスト、デプロイが可能になります。特に、データベース、メッセージキュー、その他のマイクロサービスといった外部サービスに依存するプロジェクトで有用です。

これらのサービスが同一のサンドボックス環境内で動作するため、エージェントはシームレスに連携できます。これにより、外部サービスに依存する場合と比べて、より強固な分離性とセキュリティを確保できます。

### DinDスナップショットの作成 \{#creating-a-dind-snapshot\}

プリビルドの Docker-in-Docker イメージをベースにするか、カスタムイメージに Docker を手動でインストールすることで、Docker に対応したスナップショットを作成できます。

#### 事前構築済みイメージの利用 \{#using-pre-built-images\}

以下のベースイメージは、Docker-in-Docker のスナップショット作成で広く利用されているほか、カスタム Dockerfile のベースとしても利用できます。

* `docker:28.3.3-dind` - 公式 Docker-in-Docker イメージ（Alpine ベース、軽量）
* `docker:28.3.3-dind-rootless` - セキュリティ強化のための rootless Docker-in-Docker
* `docker:28.3.2-dind-alpine3.22` - Alpine 3.22 を用いた Docker-in-Docker イメージ

#### Docker の手動インストール \{#manual-docker-installation\}

別の方法として、カスタム Dockerfile で Docker を手動インストールできます：

```dockerfile
FROM ubuntu:22.04
# 公式インストールスクリプトで Docker をインストール
RUN curl -fsSL https://get.docker.com | VERSION=28.3.3 sh -
```

### ユースケース \{#use-cases\}

* データベース（PostgreSQL、Redis、MySQL）などのサービスを実行する
* コンテナ化アプリケーションのビルドとテストを行う
* マイクロサービスとその依存関係をデプロイする
* コンテナオーケストレーションをフルに活用した分離開発環境を作成する

:::note
Docker-in-Docker のサンドボックスは、Docker デーモンのオーバーヘッドにより追加のリソースを要します。最適な性能のため、少なくとも 2 vCPU と 4 GiB のメモリを割り当てることを検討してください。
:::

## デフォルトのスナップショット \{#default-snapshot\}

Daytona が使用するデフォルトのスナップショットは、`python` と `node`、それぞれの LSP に加えて、以下の `pip` 事前インストール済みパッケージを含むイメージをベースにしています:

* `beautifulsoup4` (v4.13.3)
* `django` (v5.1.7)
* `flask` (v3.1.0)
* `keras` (v3.9.0)
* `matplotlib` (v3.10.1)
* `numpy` (v2.2.3)
* `openai` (v1.65.4)
* `opencv-python` (v4.11.0.86)
* `pandas` (v2.2.3)
* `pillow` (v11.1.0)
* `pydantic-ai` (v0.0.35)
* `requests` (v2.32.3)
* `scikit-learn` (v1.6.1)
* `scipy` (v1.15.2)
* `seaborn` (v0.13.2)
* `SQLAlchemy` (v2.0.38)
* `transformers` (v4.49.0)
* `anthropic` (v0.49.0)
* `daytona_sdk` (v0.11.1)
* `huggingface` (v0.0.1)
* `instructor` (v1.7.3)
* `langchain` (v0.3.20)
* `llama-index` (v0.12.22)
* `ollama` (v0.4.7)