---
title: "ファイルシステム"
hideTitleOnPage: true
---

## FileSystem \{#filesystem\}

サンドボックス内のファイルシステム操作を提供します。

### コンストラクタ \{#constructors\}

#### new FileSystem() \{#new-filesystem\}

```ts
new FileSystem(clientConfig: Configuration, apiClient: FileSystemApi): FileSystem
```

**パラメータ**:

* `clientConfig` *Configuration*
* `apiClient` *FileSystemApi*

**戻り値**:

* `FileSystem`

### メソッド \{#methods\}

#### createFolder() \{#createfolder\}

```ts
createFolder(path: string, mode: string): Promise<void>
```

指定したパーミッションでサンドボックス内に新しいディレクトリを作成します。

**パラメータ**:

* `path` *string* - ディレクトリを作成するパス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。
* `mode` *string* - 8進数表記のディレクトリのパーミッション（例: &quot;755&quot;）

**返り値**:

* `Promise<void>`

**例:**

```ts
// 標準権限でディレクトリを作成
await fs.createFolder('app/data', '755');
```

***

#### deleteFile() \{#deletefile\}

```ts
deleteFile(path: string, recursive?: boolean): Promise<void>
```

サンドボックスからファイルまたはディレクトリを削除します。

**パラメーター**:

* `path` *string* - 削除対象のファイルまたはディレクトリへのパス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。
* `recursive?` *boolean* - 対象がディレクトリの場合、削除するには true に設定する必要があります。

**戻り値**:

* `Promise<void>`

**例:**

```ts
// ファイルを削除
await fs.deleteFile('app/temp.log');
```

***

#### downloadFile() \{#downloadfile\}

##### 呼び出しシグネチャ \{#call-signature\}

```ts
downloadFile(remotePath: string, timeout?: number): Promise<Buffer<ArrayBufferLike>>
```

サンドボックスからファイルをダウンロードします。このメソッドはファイル全体をメモリに読み込むため、大きなファイルのダウンロードには推奨しません。

**パラメーター**:

* `remotePath` *string* - ダウンロードするファイルのパス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。
* `timeout?` *number* - ダウンロード処理のタイムアウト（秒）。0 はタイムアウトなしを意味します。
  既定値は30分です。

**戻り値**:

* `Promise<Buffer<ArrayBufferLike>>` - ファイル内容を表す Buffer。

**例:**

```ts
// ファイルをダウンロードして処理する
const fileBuffer = await fs.downloadFile('tmp/data.json');
console.log('ファイル内容:', fileBuffer.toString());
```

##### 呼び出しシグネチャ \{#call-signature\}

```ts
downloadFile(
   remotePath: string, 
   localPath: string, 
timeout?: number): Promise<void>
```

サンドボックスからファイルをダウンロードしてローカルファイルに保存します。このメソッドはストリーミングでダウンロードを行うため、大きなファイルの取得に適しています。

**パラメーター**:

* `remotePath` *string* - サンドボックス内でダウンロードするファイルのパス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。
* `localPath` *string* - ダウンロードしたファイルの保存先パス。
* `timeout?` *number* - ダウンロード処理のタイムアウト（秒）。0 はタイムアウトなしを意味します。
  既定値は 30 分です。

**戻り値**:

* `Promise<void>`

**例:**

```ts
// ファイルをダウンロードして保存
await fs.downloadFile('tmp/data.json', 'local_file.json');
```

***

#### downloadFiles() \{#downloadfiles\}

```ts
downloadFiles(files: FileDownloadRequest[], timeoutSec?: number): Promise<FileDownloadResponse[]>
```

サンドボックスから複数のファイルをダウンロードします。対象のファイルがローカルに既に存在する場合は上書きされます。

**パラメータ**:

* `files` *FileDownloadRequest[]* - ファイルダウンロード要求の配列。
* `timeoutSec?` *number = ...* - ダウンロード処理のタイムアウト（秒）。0 はタイムアウトなしを意味します。
  既定値は30分です。

**戻り値**:

* `Promise<FileDownloadResponse[]>` - ダウンロード結果の配列。

**スロー**:

リクエスト自体が失敗した場合（ネットワーク障害、不正なリクエスト/レスポンスなど）。個々の
ファイルのダウンロードエラーは `FileDownloadResponse.error` フィールドで返されます。

**例:**

```ts
// 複数のファイルをダウンロード
const results = await fs.downloadFiles([
  { source: 'tmp/data.json' },
  { source: 'tmp/config.json', destination: 'local_config.json' }
]);
results.forEach(result => {
  if (result.error) {
    console.error(`${result.source}のダウンロード中にエラーが発生しました: ${result.error}`);
  } else if (result.result) {
    console.log(`${result.source}を${result.result}にダウンロードしました`);
  }
});
```

***

#### findFiles() \{#findfiles\}

```ts
findFiles(path: string, pattern: string): Promise<Match[]>
```

サンドボックス内のファイルからテキストパターンを検索します。

**パラメータ**:

* `path` *string* - 検索対象のディレクトリ。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。
* `pattern` *string* - 検索パターン

**戻り値**:

* `Promise<Match[]>` - ファイル名と行情報を含む一致結果の配列

**例:**

```ts
// TypeScriptファイル内のすべてのTODOコメントを検索
const matches = await fs.findFiles('app/src', 'TODO:');
matches.forEach(match => {
  console.log(`${match.file}:${match.line}: ${match.content}`);
});
```

***

#### getFileDetails() \{#getfiledetails\}

```ts
getFileDetails(path: string): Promise<FileInfo>
```

ファイルまたはディレクトリの詳細情報を取得します。

**パラメーター**:

* `path` *string* - ファイルまたはディレクトリのパス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。

**戻り値**:

* `Promise<FileInfo>` - サイズ、権限、更新時刻などを含む詳細なファイル情報

**例:**

```ts
// ファイルの詳細を取得
const info = await fs.getFileDetails('app/config.json');
console.log(`サイズ: ${info.size}, 更新日時: ${info.modTime}`);
```

***

#### listFiles() \{#listfiles\}

```ts
listFiles(path: string): Promise<FileInfo[]>
```

サンドボックス内のディレクトリ内容を一覧表示します。

**パラメーター**:

* `path` *string* - 一覧表示するディレクトリのパス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。

**戻り値**:

* `Promise<FileInfo[]>` - ファイルおよびディレクトリの情報配列

**例:**

```ts
// ディレクトリの内容を一覧表示
const files = await fs.listFiles('app/src');
files.forEach(file => {
  console.log(`${file.name} (${file.size} bytes)`);
});
```

***

#### moveFiles() \{#movefiles\}

```ts
moveFiles(source: string, destination: string): Promise<void>
```

ファイルまたはディレクトリを移動または名称変更します。

**パラメーター**:

* `source` *string* - ソースパス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。
* `destination` *string* - 宛先パス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。

**戻り値**:

* `Promise<void>`

**例:**

```ts
// ファイルを新しい場所に移動
await fs.moveFiles('app/temp/data.json', 'app/data/data.json');
```

***

#### replaceInFiles() \{#replaceinfiles\}

```ts
replaceInFiles(
   files: string[], 
   pattern: string, 
newValue: string): Promise<ReplaceResult[]>
```

複数ファイルのテキスト内容を一括置換します。

**パラメーター**:

* `files` *string[]* - 処理するファイルパスの配列。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。
* `pattern` *string* - 置換対象のパターン
* `newValue` *string* - 置換するテキスト

**戻り値**:

* `Promise<ReplaceResult[]>` - 各ファイルに対する置換処理の結果

**例:**

```ts
// 複数のファイルでバージョン番号を更新
const results = await fs.replaceInFiles(
  ['app/package.json', 'app/version.ts'],
  '"version": "1.0.0"',
  '"version": "1.1.0"'
);
```

***

#### searchFiles() \{#searchfiles\}

```ts
searchFiles(path: string, pattern: string): Promise<SearchFilesResponse>
```

サンドボックス内で、名前パターンに基づいてファイルやディレクトリを検索します。

**パラメーター**:

* `path` *string* - 検索対象のディレクトリ。相対パスはサンドボックスのワーキングディレクトリを基準に解決されます。
* `pattern` *string* - ファイル名のパターン（グロブをサポート）

**戻り値**:

* `Promise<SearchFilesResponse>` - 一致したファイルを含む検索結果

**例:**

```ts
// すべてのTypeScriptファイルを検索
const result = await fs.searchFiles('app', '*.ts');
result.files.forEach(file => console.log(file));
```

***

#### setFilePermissions() \{#setfilepermissions\}

```ts
setFilePermissions(path: string, permissions: FilePermissionsParams): Promise<void>
```

ファイルまたはディレクトリのパーミッションと所有権を設定します。

**パラメータ**:

* `path` *string* - ファイルまたはディレクトリへのパス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。
* `permissions` *FilePermissionsParams* - パーミッション設定

**戻り値**:

* `Promise<void>`

**例:**

```ts
// ファイルの権限と所有者を設定
await fs.setFilePermissions('app/script.sh', {
  owner: 'daytona',
  group: 'users',
  mode: '755'  // シェルスクリプトの実行権限
});
```

***

#### uploadFile() \{#uploadfile\}

##### 呼び出しシグネチャ \{#call-signature\}

```ts
uploadFile(
   file: Buffer, 
   remotePath: string, 
timeout?: number): Promise<void>
```

サンドボックスにファイルをアップロードします。このメソッドはファイル全体をメモリに読み込むため、大容量ファイルのアップロードには推奨されません。

**パラメータ**:

* `file` *Buffer* - アップロードするファイルのバッファ。
* `remotePath` *string* - サンドボックス内のアップロード先パス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。
* `timeout?` *number* - アップロード処理のタイムアウト（秒）。0 はタイムアウトなしを意味します。
  既定値は30分です。

**戻り値**:

* `Promise<void>`

**例:**

```ts
// 設定ファイルをアップロード
await fs.uploadFile(Buffer.from('{"setting": "value"}'), 'tmp/config.json');
```

##### 呼び出しシグネチャ \{#call-signature\}

```ts
uploadFile(
   localPath: string, 
   remotePath: string, 
timeout?: number): Promise<void>
```

ローカルのファイルシステムからサンドボックスにファイルをアップロードします。このメソッドはストリーミングでアップロードを行うため、大きなファイルのアップロードに推奨されます。

**パラメーター**:

* `localPath` *string* - アップロードするローカルファイルのパス。
* `remotePath` *string* - サンドボックス内の保存先パス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。
* `timeout?` *number* - アップロード処理のタイムアウト（秒）。0 はタイムアウトなしを意味します。
  デフォルトは 30 分です。

**戻り値**:

* `Promise<void>`

**例:**

```ts
// ローカルファイルをアップロード
await fs.uploadFile('local_file.txt', 'tmp/file.txt');
```

***

#### uploadFiles() \{#uploadfiles\}

```ts
uploadFiles(files: FileUpload[], timeout?: number): Promise<void>
```

複数のファイルをサンドボックスにアップロードします。宛先パスに既にファイルが存在する場合は上書きされます。

**パラメーター**:

* `files` *FileUpload[]* - アップロードするファイルの配列。
* `timeout?` *number = ...* - アップロードのタイムアウト（秒）。0 はタイムアウトなしを意味します。
  既定値は 30 分です。

**戻り値**:

* `Promise<void>`

**例:**

```ts
// 複数のテキストファイルをアップロード
const files = [
  {
    source: Buffer.from('Content of file 1'),
    destination: '/tmp/file1.txt'
  },
  {
    source: 'app/data/file2.txt',
    destination: '/tmp/file2.txt'
  },
  {
    source: Buffer.from('{"key": "value"}'),
    destination: '/tmp/config.json'
  }
];
await fs.uploadFiles(files);
```

***

## DownloadMetadata \{#downloadmetadata\}

ファイルダウンロード操作のメタデータを表します。

**プロパティ**:

* `destination?` *string* - ファイル内容がストリーミングされるローカルファイルシステム内の保存先パス。
* `error?` *string* - ダウンロードが失敗した場合のエラーメッセージ。成功時は undefined。
* `result?` *string | Buffer&lt;ArrayBufferLike&gt; | Uint8Array&lt;ArrayBufferLike&gt;* - ダウンロード結果。リクエストで `destination` が指定されている場合はファイルパス、
  指定されていない場合はバイト列データ。失敗した場合、またはデータが受信されなかった場合は undefined。

## FileDownloadRequest \{#filedownloadrequest\}

サンドボックスから単一のファイルをダウンロードするリクエストを表します。

**プロパティ**:

* `destination?` *string* - ファイル内容をストリーミングするローカルファイルシステム上の保存先パス。指定しない場合、ファイルはバイトバッファにダウンロードされます（ファイルが大きい場合はメモリ問題を引き起こす可能性があります）。
* `source` *string* - サンドボックス内のソースパス。相対パスはユーザーのルートディレクトリを基準に解決されます。

## FileDownloadResponse \{#filedownloadresponse\}

単一のファイルダウンロード要求に対するレスポンスを表します。

**プロパティ**:

* `error?` *string* - ダウンロードが失敗した場合のエラーメッセージ。成功した場合は未定義。
* `result?` *string | Buffer&lt;ArrayBufferLike&gt;* - ダウンロード結果。リクエストで保存先が指定されている場合はファイルパス、指定されていない場合はバイト列の内容。失敗した場合、またはデータを受信しなかった場合は未定義。
* `source` *string* - ダウンロード対象としてリクエストされた元のソースパス。

## FilePermissionsParams \{#filepermissionsparams\}

サンドボックス内のファイル権限を設定するためのパラメータ。

**プロパティ**:

* `group?` *string* - ファイルのグループ所有者
* `mode?` *string* - 8進数形式のファイルモード/パーミッション（例: &quot;644&quot;）
* `owner?` *string* - ファイルのユーザー所有者

**例:**

```ts
const permissions: FilePermissionsParams = {
  mode: '644',
  owner: 'daytona',
  group: 'users'
};
```

## FileUpload \{#fileupload\}

サンドボックスにアップロードするファイルを表します。

**プロパティ**:

* `destination` *string* - サンドボックス内の絶対パス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。
* `source` *string | Buffer&lt;ArrayBufferLike&gt;* - アップロードするファイル。Buffer の場合、ファイル内容として解釈され、メモリに読み込まれます。
  メモリに収まることを確認してください。収まらない場合は、内容がサンドボックスへストリーミングされるローカルファイルのパスを使用してください。