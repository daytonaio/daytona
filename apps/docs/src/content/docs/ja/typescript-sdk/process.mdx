---
title: "プロセス"
hideTitleOnPage: true
---

## CodeRunParams \{#coderunparams\}

コード実行用のパラメータ。

**プロパティ**:

* `argv?` *string[]* - コマンドライン引数
* `env?` *Record&lt;string, string&gt;* - 環境変数

### コンストラクタ \{#constructors\}

#### new CodeRunParams() \{#new-coderunparams\}

```ts
new CodeRunParams(): CodeRunParams
```

**戻り値**:

* `CodeRunParams`

## プロセス \{#process\}

サンドボックス内のプロセスおよびコード実行を扱います。

### コンストラクタ \{#constructors\}

#### new Process() \{#new-process\}

```ts
new Process(
   sandboxId: string, 
   clientConfig: Configuration, 
   codeToolbox: SandboxCodeToolbox, 
   toolboxApi: ToolboxApi, 
   getRootDir: () => Promise<string>, 
   getPreviewLink: (port: number) => Promise<PortPreviewUrl>): Process
```

**パラメータ**:

* `sandboxId` *string*
* `clientConfig` *Configuration*
* `codeToolbox` *SandboxCodeToolbox*
* `toolboxApi` *ToolboxApi*
* `getRootDir` *() =&gt; Promise&lt;string&gt;*
* `getPreviewLink` *(port: number) =&gt; Promise&lt;PortPreviewUrl&gt;*

**戻り値**:

* `Process`

### メソッド \{#methods\}

#### codeRun() \{#coderun\}

```ts
codeRun(
   code: string, 
   params?: CodeRunParams, 
timeout?: number): Promise<ExecuteResponse>
```

適切な言語ランタイムを用いてサンドボックス内でコードを実行します。

**パラメータ**:

* `code` *string* - 実行するコード
* `params?` *CodeRunParams* - コード実行用パラメータ
* `timeout?` *number* - 実行完了を待つ最大時間（秒）

**戻り値**:

* `Promise<ExecuteResponse>` - 次を含むコード実行結果:
  * exitCode: 実行の終了ステータス
  * result: コードの標準出力
  * artifacts: `stdout`（result と同じ）および `charts`（matplotlib のチャートメタデータ）を含む ExecutionArtifacts オブジェクト

**例:**

```ts
// TypeScript のコードを実行
const response = await process.codeRun(`
  const x = 10;
  const y = 20;
  console.log(\`Sum: \${x + y}\`);
`);
console.log(response.artifacts.stdout);  // 出力: Sum: 30
```

```ts
// matplotlib を使用して Python のコードを実行
const response = await process.codeRun(`
import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(0, 10, 30)
y = np.sin(x)

plt.figure(figsize=(8, 5))
plt.plot(x, y, 'b-', linewidth=2)
plt.title('Line Chart')
plt.xlabel('X-axis (seconds)')
plt.ylabel('Y-axis (amplitude)')
plt.grid(True)
plt.show()
`);

if (response.artifacts?.charts) {
  const chart = response.artifacts.charts[0];

  console.log(`Type: ${chart.type}`);
  console.log(`Title: ${chart.title}`);
  if (chart.type === ChartType.LINE) {
    const lineChart = chart as LineChart
    console.log('X Label:', lineChart.x_label)
    console.log('Y Label:', lineChart.y_label)
    console.log('X Ticks:', lineChart.x_ticks)
    console.log('Y Ticks:', lineChart.y_ticks)
    console.log('X Tick Labels:', lineChart.x_tick_labels)
    console.log('Y Tick Labels:', lineChart.y_tick_labels)
    console.log('X Scale:', lineChart.x_scale)
    console.log('Y Scale:', lineChart.y_scale)
    console.log('Elements:')
    console.dir(lineChart.elements, { depth: null })
  }
}
```

***

#### createSession() \{#createsession\}

```ts
createSession(sessionId: string): Promise<void>
```

サンドボックス内に新しい長時間稼働のバックグラウンドセッションを作成します。

セッションはコマンド間で状態を維持するバックグラウンドプロセスで、複数の関連コマンドの実行や恒常的な環境セットアップが必要なシナリオに最適です。長時間実行のコマンドを動かし、プロセスの状態を監視できます。

**パラメーター**:

* `sessionId` *string* - 新規セッションの一意の識別子

**戻り値**:

* `Promise<void>`

**例:**

```ts
// 新しいセッションを作成
const sessionId = 'my-session';
await process.createSession(sessionId);
const session = await process.getSession(sessionId);
// 作業を実行...
await process.deleteSession(sessionId);
```

***

#### deleteSession() \{#deletesession\}

```ts
deleteSession(sessionId: string): Promise<void>
```

サンドボックスのセッションを削除します。

**パラメーター**:

* `sessionId` *string* - 削除するセッションの一意の識別子

**戻り値**:

* `Promise<void>`

**例:**

```ts
// 完了したセッションをクリーンアップ
await process.deleteSession('my-session');
```

***

#### executeCommand() \{#executecommand\}

```ts
executeCommand(
   command: string, 
   cwd?: string, 
   env?: Record<string, string>, 
timeout?: number): Promise<ExecuteResponse>
```

サンドボックス内でシェルコマンドを実行します。

**パラメータ**:

* `command` *string* - 実行するシェルコマンド
* `cwd?` *string* - コマンドの作業ディレクトリ。未指定の場合はサンドボックスのルートディレクトリを使用します。
  既定値はユーザーのルートディレクトリです。
* `env?` *Record&lt;string, string&gt;* - コマンドに設定する環境変数
* `timeout?` *number* - コマンドの完了を待機する最大時間（秒）。0 の場合は無期限に待機します。

**戻り値**:

* `Promise<ExecuteResponse>` - 次を含むコマンド実行結果:
  * exitCode: コマンドの終了ステータス
  * result: コマンドの標準出力
  * artifacts: `stdout`（result と同じ）および `charts`（matplotlib のチャートメタデータ）を含む ExecutionArtifacts オブジェクト

**例:**

```ts
// シンプルなコマンド
const response = await process.executeCommand('echo "Hello"');
console.log(response.artifacts.stdout);  // 出力: Hello
```

```ts
// 作業ディレクトリを指定したコマンド
const result = await process.executeCommand('ls', 'workspace/src');
```

```ts
// タイムアウトを指定したコマンド
const result = await process.executeCommand('sleep 10', undefined, 5);
```

***

#### executeSessionCommand() \{#executesessioncommand\}

```ts
executeSessionCommand(
   sessionId: string, 
   req: SessionExecuteRequest, 
timeout?: number): Promise<SessionExecuteResponse>
```

既存のセッション内でコマンドを実行します。

**パラメーター**:

* `sessionId` *string* - 使用するセッションの一意の識別子
* `req` *SessionExecuteRequest* - 次を含むコマンド実行リクエスト:
  * command: 実行するコマンド
  * runAsync: 非同期で実行するかどうか
* `timeout?` *number* - タイムアウト（秒）

**戻り値**:

* `Promise<SessionExecuteResponse>` - 次を含むコマンド実行結果:
  * cmdId: 実行されたコマンドの一意の識別子
  * output: 結合されたコマンド出力（stdout と stderr）（同期実行時）
  * stdout: コマンドの標準出力
  * stderr: コマンドの標準エラー出力
  * exitCode: コマンドの終了コード（同期実行時）

**例:**

```ts
// 状態を維持しながらコマンドを順に実行
const sessionId = 'my-session';

// ディレクトリを変更
await process.executeSessionCommand(sessionId, {
  command: 'cd /home/daytona'
});

// 新しいディレクトリでコマンドを実行
const result = await process.executeSessionCommand(sessionId, {
  command: 'pwd'
});
console.log('[STDOUT]:', result.stdout);
console.log('[STDERR]:', result.stderr);
```

***

#### getSession() \{#getsession\}

```ts
getSession(sessionId: string): Promise<Session>
```

サンドボックス内のセッションを取得します。

**パラメーター**:

* `sessionId` *string* - 取得するセッションの一意の識別子

**戻り値**:

* `Promise<Session>` - 次の情報を含むセッション情報:
  * sessionId: セッションの一意の識別子
  * commands: セッションで実行されたコマンドの一覧

**例:**

```ts
const session = await process.getSession('my-session');
session.commands.forEach(cmd => {
  console.log(`Command: ${cmd.command}`);
});
```

***

#### getSessionCommand() \{#getsessioncommand\}

```ts
getSessionCommand(sessionId: string, commandId: string): Promise<Command>
```

セッション内で実行された特定のコマンドの情報を取得します。

**パラメーター**:

* `sessionId` *string* - セッションの一意の識別子
* `commandId` *string* - コマンドの一意の識別子

**戻り値**:

* `Promise<Command>` - 次を含むコマンド情報:
  * id: コマンドの一意の識別子
  * command: 実行されたコマンド文字列
  * exitCode: コマンドの終了コード（完了している場合）

**例:**

```ts
const cmd = await process.getSessionCommand('my-session', 'cmd-123');
if (cmd.exitCode === 0) {
  console.log(`Command ${cmd.command} completed successfully`);
}
```

***

#### getSessionCommandLogs() \{#getsessioncommandlogs\}

##### 呼び出しシグネチャ \{#call-signature\}

```ts
getSessionCommandLogs(sessionId: string, commandId: string): Promise<SessionCommandLogsResponse>
```

セッション内で実行されたコマンドのログを取得します。

**パラメータ**:

* `sessionId` *string* - セッションの一意の識別子
* `commandId` *string* - コマンドの一意の識別子

**戻り値**:

* `Promise<SessionCommandLogsResponse>` - コマンドのログ。output（stdout と stderr の合成）、stdout、stderr を含みます

**例:**

```ts
const logs = await process.getSessionCommandLogs('my-session', 'cmd-123');
console.log('[STDOUT]:', logs.stdout);
console.log('[STDERR]:', logs.stderr);
```

##### 呼び出しシグネチャ \{#call-signature\}

```ts
getSessionCommandLogs(
   sessionId: string, 
   commandId: string, 
   onStdout: (chunk: string) => void, 
onStderr: (chunk: string) => void): Promise<void>
```

セッション内で実行されたコマンドのログを、利用可能になり次第、非同期で取得・処理します。

**パラメーター**:

* `sessionId` *string* - セッションの一意の識別子
* `commandId` *string* - コマンドの一意の識別子
* `onStdout` *(chunk: string) =&gt; void* - stdoutのログチャンクを処理するコールバック関数
* `onStderr` *(chunk: string) =&gt; void* - stderrのログチャンクを処理するコールバック関数

**戻り値**:

* `Promise<void>`

**例:**

```ts
const logs = await process.getSessionCommandLogs('my-session', 'cmd-123', (chunk) => {
  console.log('[STDOUT]:', chunk);
}, (chunk) => {
  console.log('[STDERR]:', chunk);
});
```

***

#### listSessions() \{#listsessions\}

```ts
listSessions(): Promise<Session[]>
```

サンドボックス内のアクティブなセッションをすべて一覧します。

**戻り値**:

* `Promise<Session[]>` - アクティブなセッションの配列

**例:**

```ts
const sessions = await process.listSessions();
sessions.forEach(session => {
  console.log(`Session ${session.sessionId}:`);
  session.commands.forEach(cmd => {
    console.log(`- ${cmd.command} (${cmd.exitCode})`);
  });
});
```

***

## SessionCommandLogsResponse \{#sessioncommandlogsresponse\}

**プロパティ**:

* `output?` *string*
* `stderr?` *string*
* `stdout?` *string*

## SessionExecuteResponse \{#sessionexecuteresponse\}

**継承:**

**プロパティ**:

* `cmdId?` *string* - 実行されたコマンドのID
  * *継承元*: `SessionExecuteResponse.cmdId`

* `exitCode?` *number* - 実行されたコマンドの終了コード
  * *継承元*: `SessionExecuteResponse.exitCode`

* `output?` *string* - 実行されたコマンドの出力（stdout と stderr の接頭辞付き）
  * *継承元*: `SessionExecuteResponse.output`

* `stderr?` *string*

* `stdout?` *string*

* `SessionExecuteResponse`

## MAX_PREFIX_LEN \{#max_prefix_len\}

```ts
const MAX_PREFIX_LEN: number;
```

***

## STDERR_PREFIX_BYTES \{#stderr_prefix_bytes\}

```ts
const STDERR_PREFIX_BYTES: Uint8Array<ArrayBuffer>;
```

***

## STDOUT_PREFIX_BYTES \{#stdout_prefix_bytes\}

```ts
const STDOUT_PREFIX_BYTES: Uint8Array<ArrayBuffer>;
```