---
title: "サンドボックス"
hideTitleOnPage: true
---

## Sandbox \{#sandbox\}

Daytona サンドボックスを表します。

**プロパティ**:

* `autoArchiveInterval?` *number* - 自動アーカイブの間隔（分）

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.autoArchiveInterval
  ```
* `autoDeleteInterval?` *number* - 自動削除までの時間（分）

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.autoDeleteInterval
  ```
* `autoStopInterval?` *number* - 自動停止までの時間（分）

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.autoStopInterval
  ```
* `backupCreatedAt?` *string* - バックアップが作成された日時

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.backupCreatedAt
  ```
* `backupState?` *SandboxBackupStateEnum* - サンドボックスのバックアップの現在の状態

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.backupState
  ```
* `buildInfo?` *BuildInfo* - 動的ビルドから作成された場合のサンドボックスのビルド情報

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.buildInfo
  ```
* `codeInterpreter` *CodeInterpreter* - ステートフルなコード実行用インターフェース。
  現在は Python のみをサポートします。他の言語については `process.codeRun` メソッドを使用してください。
* `computerUse` *ComputerUse* - デスクトップ自動化向けのコンピューター使用操作インターフェース
* `cpu` *number* - サンドボックスに割り当てられた CPU 数

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.cpu
  ```
* `createdAt?` *string* - サンドボックスが作成された日時

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.createdAt
  ```
* `disk` *number* - サンドボックスに割り当てられたディスク容量（GiB）

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.disk
  ```
* `env` *Record&lt;string, string&gt;* - サンドボックスで設定されている環境変数

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.env
  ```
* `errorReason?` *string* - サンドボックスがエラー状態のときのエラーメッセージ

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.errorReason
  ```
* `fs` *FileSystem* - ファイルシステム操作インターフェース
* `git` *Git* - Git 操作インターフェース
* `gpu` *number* - サンドボックスに割り当てられた GPU 数

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.gpu
  ```
* `id` *string* - サンドボックスの一意な識別子

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.id
  ```
* `labels` *Record&lt;string, string&gt;* - サンドボックスに付与されたカスタムラベル

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.labels
  ```
* `memory` *number* - サンドボックスに割り当てられたメモリ容量（GiB）

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.memory
  ```
* `name` *string* - サンドボックスの名前

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.name
  ```
* `networkAllowList?` *string* - サンドボックスで許可される CIDR ネットワークアドレスのカンマ区切りリスト

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.networkAllowList
  ```
* `networkBlockAll` *boolean* - サンドボックスに対するすべてのネットワークアクセスをブロックするかどうか

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.networkBlockAll
  ```
* `organizationId` *string* - サンドボックスの組織 ID

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.organizationId
  ```
* `process` *Process* - プロセス実行インターフェース
* `public` *boolean* - サンドボックスが公開アクセス可能かどうか

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.public
  ```
* `recoverable?` *boolean* - サンドボックスで発生したエラーが復旧可能かどうか。

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.recoverable
  ```
* `snapshot?` *string* - サンドボックスの作成に使用する Daytona スナップショット

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.snapshot
  ```
* `state?` *SandboxState* - サンドボックスの現在の状態（例: &quot;started&quot;、&quot;stopped&quot;）

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.state
  ```
* `target` *string* - サンドボックスが実行されるランナーのターゲット先

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.target
  ```
* `updatedAt?` *string* - サンドボックスが最後に更新された日時

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.updatedAt
  ```
* `user` *string* - サンドボックス内で動作する OS ユーザー

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.user
  ```
* `volumes?` *SandboxVolume[]* - サンドボックスにアタッチされているボリューム

  ##### 実装 \{#implementation-of\}

  ```ts
  SandboxDto.volumes
  ```

### 実装 \{#implements\}

* `Sandbox`

### コンストラクタ \{#constructors\}

#### new Sandbox() \{#new-sandbox\}

```ts
new Sandbox(
   sandboxDto: Sandbox, 
   clientConfig: Configuration, 
   axiosInstance: AxiosInstance, 
   sandboxApi: SandboxApi, 
   codeToolbox: SandboxCodeToolbox, 
   getToolboxBaseUrl: (sandboxId: string, regionId: string) => Promise<string>): Sandbox
```

新しいサンドボックスのインスタンスを作成します

**パラメータ**:

* `sandboxDto` *Sandbox* - API のサンドボックスインスタンス
* `clientConfig` *Configuration*
* `axiosInstance` *AxiosInstance*
* `sandboxApi` *SandboxApi* - サンドボックス操作用の API クライアント
* `codeToolbox` *SandboxCodeToolbox* - 言語固有のツールボックス実装
* `getToolboxBaseUrl` *(sandboxId: string, regionId: string) =&gt; Promise&lt;string&gt;*

**戻り値**:

* `Sandbox`

### メソッド \{#methods\}

#### archive() \{#archive\}

```ts
archive(): Promise<void>
```

サンドボックスをアーカイブし、非アクティブ化して状態を保持します。サンドボックスをアーカイブすると、ファイルシステム全体の状態がコスト効率の高いオブジェクトストレージに移動され、長期間にわたりサンドボックスを利用可能な状態で保持できます。
アーカイブ状態と停止状態の違いとして、アーカイブされたサンドボックスの起動には、サイズに応じてより時間がかかります。
アーカイブする前にサンドボックスを停止する必要があります。

**返り値**:

* `Promise<void>`

***

#### createLspServer() \{#createlspserver\}

```ts
createLspServer(languageId: string, pathToProject: string): Promise<LspServer>
```

新しい Language Server Protocol (LSP) サーバー インスタンスを作成します。

LSP サーバーは、コード補完や診断などの言語固有の機能を提供します。

**パラメーター**:

* `languageId` *string* - 言語サーバーの種類（例: &quot;typescript&quot;）
* `pathToProject` *string* - プロジェクトのルートディレクトリへのパス。相対パスはサンドボックスの作業ディレクトリを基準に解決されます。

**戻り値**:

* `Promise<LspServer>` - 指定した言語向けに構成された新しい LSP サーバー インスタンス

**例:**

```ts
const lsp = await sandbox.createLspServer('typescript', 'workspace/project');
```

***

#### createSshAccess() \{#createsshaccess\}

```ts
createSshAccess(expiresInMinutes?: number): Promise<SshAccessDto>
```

サンドボックスの SSH アクセストークンを作成します。

**パラメータ**:

* `expiresInMinutes?` *number* - SSH アクセストークンの有効期間（分）。

**戻り値**:

* `Promise<SshAccessDto>` - SSH アクセストークン。

***

#### delete() \{#delete\}

```ts
delete(timeout: number): Promise<void>
```

サンドボックスを削除します。

**パラメータ**:

* `timeout` *number = 60*

**戻り値**:

* `Promise<void>`

***

#### expireSignedPreviewUrl() \{#expiresignedpreviewurl\}

```ts
expireSignedPreviewUrl(port: number, token: string): Promise<void>
```

指定されたポート上のサンドボックス用の署名付きプレビュー URL を失効させます。

**Parameters**:

* `port` *number* - 署名付きプレビュー URL を失効させるポート。
* `token` *string* - 署名付きプレビュー URL を失効させるトークン。

**Returns**:

* `Promise<void>`

***

#### getPreviewLink() \{#getpreviewlink\}

```ts
getPreviewLink(port: number): Promise<PortPreviewUrl>
```

指定したポートのサンドボックスに対するプレビューリンクを取得します。ポートが閉じている場合は、
自動的に開放されます。プライベートなサンドボックスでは、URL へのアクセスを許可する
トークンが含まれます。

**パラメーター**:

* `port` *number* - プレビューリンクを公開するポート。

**戻り値**:

* `Promise<PortPreviewUrl>` - プレビューリンクのレスポンスオブジェクト。`url` と
  `token`（プライベートなサンドボックスへアクセスするため）を含みます。

**例:**

```ts
const previewLink = await sandbox.getPreviewLink(3000);
console.log(`プレビューURL: ${previewLink.url}`);
console.log(`トークン: ${previewLink.token}`);
```

***

#### getSignedPreviewUrl() \{#getsignedpreviewurl\}

```ts
getSignedPreviewUrl(port: number, expiresInSeconds?: number): Promise<SignedPortPreviewUrl>
```

指定されたポート上のサンドボックスに対する署名付きプレビューリンクを取得します。

**パラメーター**:

* `port` *number* - プレビューリンクを公開するポート番号。
* `expiresInSeconds?` *number* - 署名付きプレビューリンクが有効となる秒数。デフォルトは 60 秒。

**戻り値**:

* `Promise<SignedPortPreviewUrl>` - 署名付きプレビューリンクに対するレスポンスオブジェクト。

***

#### getUserHomeDir() \{#getuserhomedir\}

```ts
getUserHomeDir(): Promise<string>
```

サンドボックス内で、ログイン中のユーザーのホームディレクトリのパスを取得します。

**戻り値**:

* `Promise<string>` - ログイン中のサンドボックスユーザーのホームディレクトリへの絶対パス

**例:**

```ts
const userHomeDir = await sandbox.getUserHomeDir();
console.log(`サンドボックスユーザーホーム: ${userHomeDir}`);
```

***

#### ~~getUserRootDir()~~ \{#getuserrootdir\}

```ts
getUserRootDir(): Promise<string>
```

**戻り値**:

* `Promise<string>`

##### 非推奨 \{#deprecated\}

代わりに `getUserHomeDir` を使用してください。このメソッドは今後のバージョンで削除されます。

***

#### getWorkDir() \{#getworkdir\}

```ts
getWorkDir(): Promise<string>
```

サンドボックス内の作業ディレクトリのパスを取得します。

**返り値**:

* `Promise<string>` - サンドボックスの作業ディレクトリへの絶対パス。Dockerfile に WORKDIR が指定されていればそれを使用し、指定がない場合はユーザーのホームディレクトリを使用します。

**例:**

```ts
const workDir = await sandbox.getWorkDir();
console.log(`サンドボックス作業ディレクトリ: ${workDir}`);
```

***

#### recover() \{#recover\}

```ts
recover(timeout?: number): Promise<void>
```

回復可能なエラーからサンドボックスを復旧し、準備完了になるまで待機します。

**パラメータ**:

* `timeout?` *number = 60* - 待機する最大時間（秒）。0 はタイムアウトなしを意味します。
  既定では 60 秒のタイムアウトです。

**戻り値**:

* `Promise<void>`

**スローされる例外**:

* `DaytonaError` - サンドボックスの復旧に失敗した場合、またはタイムアウトした場合にスローされます

**例:**

```ts
const sandbox = await daytona.get('my-sandbox-id');
await sandbox.recover();
console.log('サンドボックスが正常に復旧されました');
```

***

#### refreshActivity() \{#refreshactivity\}

```ts
refreshActivity(): Promise<void>
```

サンドボックスのアクティビティを更新し、自動ライフサイクル管理アクションのタイマーをリセットします。

このメソッドは、サンドボックスの状態を変更せずに、最終アクティビティのタイムスタンプを更新します。
ユーザーのアクティビティが続いている間、長時間実行されるセッションを維持するのに役立ちます。

**戻り値**:

* `Promise<void>`

**例:**

```ts
// サンドボックスのアクティビティを維持
await sandbox.refreshActivity();
```

***

#### refreshData() \{#refreshdata\}

```ts
refreshData(): Promise<void>
```

API からサンドボックスのデータを最新状態に更新します。

**戻り値**:

* `Promise<void>`

**例:**

```ts
await sandbox.refreshData();
console.log(`サンドボックス ${sandbox.id}:`);
console.log(`状態: ${sandbox.state}`);
console.log(`リソース: ${sandbox.cpu} CPU, ${sandbox.memory} GiB RAM`);
```

***

#### resize() \{#resize\}

```ts
resize(resources: Resources, timeout?: number): Promise<void>
```

サンドボックスのリソースをリサイズします。

サンドボックスの CPU、メモリ、またはディスクの割り当てを変更します。ホットリサイズ（稼働中の
サンドボックスに対するリサイズ）では CPU とメモリの増加のみが可能です。ディスクリサイズには停止済みサンドボックスが必要です。

**パラメーター**:

* `resources` *Resources* - 新しいリソース構成。指定されたフィールドのみが更新されます。
  * cpu: CPU コア数（最小: 1）。ホットリサイズでは増加のみ可能です。
  * memory: メモリ（GiB 単位、最小: 1）。ホットリサイズでは増加のみ可能です。
  * disk: ディスク容量（GiB 単位、増加のみ可能で、停止済みサンドボックスが必要です）。
* `timeout?` *number = 60* - リサイズ処理のタイムアウト時間（秒）。0 の場合はタイムアウトなしを意味します。

**戻り値**:

* `Promise<void>`

**スローされる例外**:

* ホットリサイズの制約に違反した場合、稼働中のサンドボックスに対してディスクリサイズを試みた場合、
  ディスクサイズの縮小を試みた場合、リソース変更が何も指定されていない場合、またはリサイズ処理がタイムアウトした場合。

**例:**

```ts
// 実行中のサンドボックスのCPU/メモリを増加させる(ホットリサイズ)
await sandbox.resize({ cpu: 4, memory: 8 });

// ディスクを変更する(サンドボックスを停止する必要があります)
await sandbox.stop();
await sandbox.resize({ cpu: 2, memory: 4, disk: 30 });
```

***

#### revokeSshAccess() \{#revokesshaccess\}

```ts
revokeSshAccess(token: string): Promise<void>
```

サンドボックスの SSH アクセストークンを取り消します。

**パラメータ**:

* `token` *string* - 取り消すトークン。

**戻り値**:

* `Promise<void>`

***

#### setAutoArchiveInterval() \{#setautoarchiveinterval\}

```ts
setAutoArchiveInterval(interval: number): Promise<void>
```

サンドボックスの自動アーカイブ間隔を設定します。

指定した間隔のあいだ連続して停止状態が続くと、サンドボックスは自動的にアーカイブされます。

**パラメーター**:

* `interval` *number* - 連続して停止してから自動アーカイブされるまでの分数。
  最大間隔にするには 0 を設定します。デフォルトは 7 日です。

**戻り値**:

* `Promise<void>`

**スロー**:

* `DaytonaError` - interval が非負の整数でない場合

**例:**

```ts
// 1時間後に自動アーカイブ
await sandbox.setAutoArchiveInterval(60);
// または最大間隔を使用
await sandbox.setAutoArchiveInterval(0);
```

***

#### setAutoDeleteInterval() \{#setautodeleteinterval\}

```ts
setAutoDeleteInterval(interval: number): Promise<void>
```

サンドボックスの自動削除間隔を設定します。

指定した間隔のあいだ連続して停止している場合、サンドボックスは自動的に削除されます。

**パラメーター**:

* `interval` *number* - サンドボックスが連続して停止してから自動削除されるまでの分数。
  自動削除を無効にするには負の値を設定します。停止と同時に削除するには 0 を設定します。
  既定では自動削除は無効です。

**戻り値**:

* `Promise<void>`

**例:**

```ts
// 1時間後に自動削除
await sandbox.setAutoDeleteInterval(60);
// または停止と同時に即座に削除
await sandbox.setAutoDeleteInterval(0);
// または自動削除を無効にする
await sandbox.setAutoDeleteInterval(-1);
```

***

#### setAutostopInterval() \{#setautostopinterval\}

```ts
setAutostopInterval(interval: number): Promise<void>
```

サンドボックスの自動停止間隔を設定します。

指定した間隔のあいだアイドル状態（新しいイベントなし）が続くと、サンドボックスは自動的に停止します。
イベントには、SDK を通じたサンドボックスの状態変更や操作が含まれます。
サンドボックスのプレビューを使った操作は含まれません。

**パラメータ**:

* `interval` *number* - 自動停止までの非アクティブ時間（分）。
  0 に設定すると自動停止を無効化します。既定は 15 分です。

**戻り値**:

* `Promise<void>`

**スロー**:

* `DaytonaError` - interval が非負の整数でない場合

**例:**

```ts
// 1時間後に自動停止
await sandbox.setAutostopInterval(60);
// または自動停止を無効化
await sandbox.setAutostopInterval(0);
```

***

#### setLabels() \{#setlabels\}

```ts
setLabels(labels: Record<string, string>): Promise<Record<string, string>>
```

サンドボックスのラベルを設定します。

ラベルは、サンドボックスを整理・識別するために使用できるキーと値のペアです。

**パラメーター**:

* `labels` *Record&lt;string, string&gt;* - サンドボックスのラベルを表すキーと値ペアのディクショナリ

**戻り値**:

* `Promise<Record<string, string>>`

**例:**

```ts
// サンドボックスラベルを設定
await sandbox.setLabels({
  project: 'my-project',
  environment: 'development',
  team: 'backend'
});
```

***

#### start() \{#start\}

```ts
start(timeout?: number): Promise<void>
```

サンドボックスを開始します。

このメソッドはサンドボックスを開始し、準備が整うまで待機します。

**パラメータ**:

* `timeout?` *number = 60* - 待機する最大時間（秒）。0 はタイムアウトなしを意味します。
  既定では 60 秒のタイムアウトです。

**戻り値**:

* `Promise<void>`

**スロー**:

* `DaytonaError` - サンドボックスの開始に失敗した場合、またはタイムアウトした場合

**例:**

```ts
const sandbox = await daytona.getCurrentSandbox('my-sandbox');
await sandbox.start(40);  // 最大40秒待機
console.log('サンドボックスが正常に開始されました');
```

***

#### stop() \{#stop\}

```ts
stop(timeout?: number): Promise<void>
```

サンドボックスを停止します。

このメソッドはサンドボックスを停止し、完全に停止するまで待機します。

**パラメータ**:

* `timeout?` *number = 60* - 待機する最大時間（秒）。0 はタイムアウトなしを意味します。
  既定では 60 秒のタイムアウトです。

**戻り値**:

* `Promise<void>`

**例:**

```ts
const sandbox = await daytona.get('my-sandbox-id');
await sandbox.stop();
console.log('サンドボックスが正常に停止されました');
```

***

#### validateSshAccess() \{#validatesshaccess\}

```ts
validateSshAccess(token: string): Promise<SshAccessValidationDto>
```

サンドボックスのSSHアクセス用トークンを検証します。

**パラメーター**:

* `token` *string* - 検証対象のトークン。

**戻り値**:

* `Promise<SshAccessValidationDto>` - SSHアクセス検証結果。

***

#### waitForResizeComplete() \{#waitforresizecomplete\}

```ts
waitForResizeComplete(timeout?: number): Promise<void>
```

サンドボックスのリサイズ処理が完了するまで待機します。

このメソッドは、状態が &#39;resizing&#39; でなくなるまでサンドボックスのステータスをポーリングし続けます。

**パラメーター**:

* `timeout?` *number = 60* - 最大待機時間（秒）。0 はタイムアウトなしを意味します。

**戻り値**:

* `Promise<void>`

**スローされる例外**:

* サンドボックスがエラー状態になった場合、またはリサイズがタイムアウトした場合。

***

#### waitUntilStarted() \{#waituntilstarted\}

```ts
waitUntilStarted(timeout?: number): Promise<void>
```

サンドボックスが「started」状態に到達するまで待機します。

このメソッドは、サンドボックスのステータスが「started」状態に到達するか
エラーが発生するまでポーリングします。

**パラメーター**:

* `timeout?` *number = 60* - 待機する最大時間（秒）。0 はタイムアウトなしを意味します。
  既定値は 60 秒です。

**返り値**:

* `Promise<void>`

**スロー**:

* `DaytonaError` - サンドボックスがエラー状態になった場合、またはタイムアウト内に起動できなかった場合。

***

#### waitUntilStopped() \{#waituntilstopped\}

```ts
waitUntilStopped(timeout?: number): Promise<void>
```

サンドボックスが「stopped」状態になるまで待機します。

このメソッドは、サンドボックスのステータスが「stopped」状態に到達するまで、
またはエラーが発生するまでポーリングします。

**パラメーター**:

* `timeout?` *number = 60* - 待機する最大時間（秒）。0 はタイムアウトなしを意味します。
  既定は 60 秒です。

**戻り値**:

* `Promise<void>`

**スロー**:

* `DaytonaError` - タイムアウト内にサンドボックスが停止しなかった場合に送出されます。

## PaginatedSandboxes \{#paginatedsandboxes\}

**拡張:**

**プロパティ**:

* `items` *Sandbox[]*

* `page` *number*
  * *継承元*: `PaginatedSandboxes.page`

* `total` *number*
  * *継承元*: `PaginatedSandboxes.total`

* `totalPages` *number*
  * *継承元*: `PaginatedSandboxes.totalPages`

* `Omit`&lt;`PaginatedSandboxesDto`, `"items"`&gt;

## SandboxCodeToolbox \{#sandboxcodetoolbox\}

コードツールボックスが実装すべきメソッドを定義するインターフェース

### メソッド \{#methods\}

#### getRunCommand() \{#getruncommand\}

```ts
getRunCommand(code: string, params?: CodeRunParams): string
```

指定されたコードを実行するコマンドを生成します

**パラメーター**:

* `code` *string*
* `params?` *CodeRunParams*

**戻り値**:

* `string`
