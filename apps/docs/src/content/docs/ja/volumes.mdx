---
title: ボリューム
---

import Label from '@components/Label.astro'
import { Tabs, TabItem } from '@astrojs/starlight/components';

ボリュームは、サンドボックス間でファイルを共有できる FUSE ベースのマウントです。これにより、サンドボックスは大容量ファイルを即座に読み取れ、各サンドボックスへ手動でアップロードする必要がありません。ボリュームのデータは S3 互換のオブジェクトストレージに保存されます。

* 複数のボリュームを 1 つのサンドボックスにマウントできます
* 1 つのボリュームを複数のサンドボックスにマウントできます

## ボリュームの作成 \{#creating-volumes\}

サンドボックスにボリュームをマウントする前に、先に作成しておく必要があります。

<Tabs syncKey="language">
  <TabItem label="Python" icon="seti:python">
    ```bash
    volume = daytona.volume.get("my-volume", create=True)
    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```bash
    const volume = await daytona.volume.get('my-volume', true)
    ```
  </TabItem>
</Tabs>

参照: [volume.get（Python SDK）](/docs/python-sdk/sync/volume/#volumeserviceget)、[volume.get（TypeScript SDK）](/docs/typescript-sdk/volume/#get)

## ボリュームのマウント \{#mounting-volumes\}

ボリュームが作成されたら、`CreateSandboxFromSnapshotParams` オブジェクトで指定することでサンドボックスにマウントできます。ボリュームのマウントパスは、次の要件を満たす必要があります。

* **絶対パスである必要があります**: マウントパスは `/` で始まらなければなりません（例: `/home/daytona/volume`）
* **ルートディレクトリは指定できません**: `/` や `//` にマウントすることはできません
* **相対パス成分を含めてはいけません**: `/../` や `/./` を含んだり、`/..` または `/.` で終わってはいけません
* **連続したスラッシュは使用できません**: 先頭以外で `//` のように、複数のスラッシュが連続するパターンを含めてはいけません
* **システムディレクトリにはマウントできません**: 次のシステムディレクトリはマウント先として使用できません:
  * `/proc`, `/sys`, `/dev`, `/boot`, `/etc`, `/bin`, `/sbin`, `/lib`, `/lib64`

<Tabs syncKey="language">
  <TabItem label="Python" icon="seti:python">
    ```python
    import os
    from daytona import CreateSandboxFromSnapshotParams, Daytona, VolumeMount

    daytona = Daytona()

    # 新しいボリュームを作成するか、既存のボリュームを取得する
    volume = daytona.volume.get("my-volume", create=True)

    # ボリュームをサンドボックスにマウントする
    mount_dir_1 = "/home/daytona/volume"

    params = CreateSandboxFromSnapshotParams(
        language="python",
        volumes=[VolumeMount(volumeId=volume.id, mountPath=mount_dir_1)],
    )
    sandbox = daytona.create(params)

    # ボリューム内の特定のサブパスをマウントする
    # データを分離したり、マルチテナンシーを実装する際に便利です
    params = CreateSandboxFromSnapshotParams(
        language="python",
        volumes=[VolumeMount(volumeId=volume.id, mountPath=mount_dir_1, subpath="users/alice")],
    )
    sandbox2 = daytona.create(params)
    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    import { Daytona } from '@daytonaio/sdk'
    import path from 'path'

    const daytona = new Daytona()

    //  新しいボリュームを作成するか、既存のボリュームを取得する
    const volume = await daytona.volume.get('my-volume', true)

    // ボリュームをサンドボックスにマウントする
    const mountDir1 = '/home/daytona/volume'

    const sandbox1 = await daytona.create({
      language: 'typescript',
      volumes: [{ volumeId: volume.id, mountPath: mountDir1 }],
    })

    // ボリューム内の特定のサブパスをマウントする
    // データを分離したり、マルチテナンシーを実装する際に便利です
    const sandbox2 = await daytona.create({
      language: 'typescript',
      volumes: [{ volumeId: volume.id, mountPath: mountDir, subpath: 'users/alice' }],
    })
    ```
  </TabItem>
</Tabs>

参照: [CreateSandboxFromSnapshotParams (Python SDK)](/docs/python-sdk/sync/daytona#createSandboxBaseParams), [CreateSandboxFromSnapshotParams (TypeScript SDK)](/docs/typescript-sdk/daytona#createSandboxBaseParams)

## ボリュームの取り扱い \{#working-with-volumes\}

ボリュームをマウントすると、サンドボックスのファイルシステム内の他のディレクトリと同様に読み書きできます。ボリュームに書き込まれたファイルは、個々のサンドボックスのライフサイクルを超えて保持されます。

<Tabs syncKey="language">
  <TabItem label="Python" icon="seti:python">
    ```python
    # マウントしたボリューム内のファイルに書き込む
    with open("/home/daytona/volume/example.txt", "w") as f:
        f.write("Hello from Daytona volume!")

    # 作業が終わったらサンドボックスを削除できます
    # サンドボックスを削除してもボリュームは保持されます
    sandbox.delete()
    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    import fs from 'fs/promises'

    // マウントしたボリューム内のファイルに書き込む
    await fs.writeFile('/home/daytona/volume/example.txt', 'Hello from Daytona volume!')

    // 作業が終わったらサンドボックスを削除できます
    // サンドボックスを削除してもボリュームは保持されます
    await daytona.delete(sandbox1)
    ```
  </TabItem>
</Tabs>

## ボリュームの削除 \{#deleting-volumes\}

ボリュームが不要になったら、削除できます。

<Tabs syncKey="language">
  <TabItem label="Python" icon="seti:python">
    ```python
    volume = daytona.volume.get("my-volume", create=True)
    daytona.volume.delete(volume)
    ```
  </TabItem>

  <TabItem label="TypeScript" icon="seti:typescript">
    ```typescript
    const volume = await daytona.volume.get('my-volume', true)
    await daytona.volume.delete(volume)
    ```
  </TabItem>
</Tabs>

## 制限事項 \{#limitations\}

ボリュームはFUSEベースのマウントであるため、ブロックストレージへのアクセスを必要とするアプリケーション（データベースのテーブルなど）では使用できません。
ボリュームは、ローカルのサンドボックスのファイルシステムと比べて、読み取り・書き込みの両方の操作が一般的に遅くなります。