// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: runner/v1/runner.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	HealthService_HealthCheck_FullMethodName = "/runner.v1.HealthService/HealthCheck"
)

// HealthServiceClient is the client API for HealthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Health service
type HealthServiceClient interface {
	HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
}

type healthServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHealthServiceClient(cc grpc.ClientConnInterface) HealthServiceClient {
	return &healthServiceClient{cc}
}

func (c *healthServiceClient) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, HealthService_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HealthServiceServer is the server API for HealthService service.
// All implementations must embed UnimplementedHealthServiceServer
// for forward compatibility.
//
// Health service
type HealthServiceServer interface {
	HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	mustEmbedUnimplementedHealthServiceServer()
}

// UnimplementedHealthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHealthServiceServer struct{}

func (UnimplementedHealthServiceServer) HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedHealthServiceServer) mustEmbedUnimplementedHealthServiceServer() {}
func (UnimplementedHealthServiceServer) testEmbeddedByValue()                       {}

// UnsafeHealthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HealthServiceServer will
// result in compilation errors.
type UnsafeHealthServiceServer interface {
	mustEmbedUnimplementedHealthServiceServer()
}

func RegisterHealthServiceServer(s grpc.ServiceRegistrar, srv HealthServiceServer) {
	// If the following call pancis, it indicates UnimplementedHealthServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HealthService_ServiceDesc, srv)
}

func _HealthService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthServiceServer).HealthCheck(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HealthService_ServiceDesc is the grpc.ServiceDesc for HealthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HealthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "runner.v1.HealthService",
	HandlerType: (*HealthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HealthCheck",
			Handler:    _HealthService_HealthCheck_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "runner/v1/runner.proto",
}

const (
	RunnerService_RunnerInfo_FullMethodName = "/runner.v1.RunnerService/RunnerInfo"
)

// RunnerServiceClient is the client API for RunnerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Runner service
type RunnerServiceClient interface {
	RunnerInfo(ctx context.Context, in *RunnerInfoRequest, opts ...grpc.CallOption) (*RunnerInfoResponse, error)
}

type runnerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRunnerServiceClient(cc grpc.ClientConnInterface) RunnerServiceClient {
	return &runnerServiceClient{cc}
}

func (c *runnerServiceClient) RunnerInfo(ctx context.Context, in *RunnerInfoRequest, opts ...grpc.CallOption) (*RunnerInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RunnerInfoResponse)
	err := c.cc.Invoke(ctx, RunnerService_RunnerInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RunnerServiceServer is the server API for RunnerService service.
// All implementations must embed UnimplementedRunnerServiceServer
// for forward compatibility.
//
// Runner service
type RunnerServiceServer interface {
	RunnerInfo(context.Context, *RunnerInfoRequest) (*RunnerInfoResponse, error)
	mustEmbedUnimplementedRunnerServiceServer()
}

// UnimplementedRunnerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRunnerServiceServer struct{}

func (UnimplementedRunnerServiceServer) RunnerInfo(context.Context, *RunnerInfoRequest) (*RunnerInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunnerInfo not implemented")
}
func (UnimplementedRunnerServiceServer) mustEmbedUnimplementedRunnerServiceServer() {}
func (UnimplementedRunnerServiceServer) testEmbeddedByValue()                       {}

// UnsafeRunnerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RunnerServiceServer will
// result in compilation errors.
type UnsafeRunnerServiceServer interface {
	mustEmbedUnimplementedRunnerServiceServer()
}

func RegisterRunnerServiceServer(s grpc.ServiceRegistrar, srv RunnerServiceServer) {
	// If the following call pancis, it indicates UnimplementedRunnerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RunnerService_ServiceDesc, srv)
}

func _RunnerService_RunnerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunnerInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServiceServer).RunnerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RunnerService_RunnerInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServiceServer).RunnerInfo(ctx, req.(*RunnerInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RunnerService_ServiceDesc is the grpc.ServiceDesc for RunnerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RunnerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "runner.v1.RunnerService",
	HandlerType: (*RunnerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RunnerInfo",
			Handler:    _RunnerService_RunnerInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "runner/v1/runner.proto",
}

const (
	SandboxService_CreateSandbox_FullMethodName          = "/runner.v1.SandboxService/CreateSandbox"
	SandboxService_DestroySandbox_FullMethodName         = "/runner.v1.SandboxService/DestroySandbox"
	SandboxService_CreateBackup_FullMethodName           = "/runner.v1.SandboxService/CreateBackup"
	SandboxService_StartSandbox_FullMethodName           = "/runner.v1.SandboxService/StartSandbox"
	SandboxService_StopSandbox_FullMethodName            = "/runner.v1.SandboxService/StopSandbox"
	SandboxService_SandboxInfo_FullMethodName            = "/runner.v1.SandboxService/SandboxInfo"
	SandboxService_RemoveDestroyedSandbox_FullMethodName = "/runner.v1.SandboxService/RemoveDestroyedSandbox"
	SandboxService_SandboxDaemonVersion_FullMethodName   = "/runner.v1.SandboxService/SandboxDaemonVersion"
)

// SandboxServiceClient is the client API for SandboxService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Sandbox service
type SandboxServiceClient interface {
	CreateSandbox(ctx context.Context, in *CreateSandboxRequest, opts ...grpc.CallOption) (*CreateSandboxResponse, error)
	DestroySandbox(ctx context.Context, in *DestroySandboxRequest, opts ...grpc.CallOption) (*DestroySandboxResponse, error)
	CreateBackup(ctx context.Context, in *CreateBackupRequest, opts ...grpc.CallOption) (*CreateBackupResponse, error)
	StartSandbox(ctx context.Context, in *StartSandboxRequest, opts ...grpc.CallOption) (*StartSandboxResponse, error)
	StopSandbox(ctx context.Context, in *StopSandboxRequest, opts ...grpc.CallOption) (*StopSandboxResponse, error)
	SandboxInfo(ctx context.Context, in *SandboxInfoRequest, opts ...grpc.CallOption) (*SandboxInfoResponse, error)
	RemoveDestroyedSandbox(ctx context.Context, in *RemoveDestroyedSandboxRequest, opts ...grpc.CallOption) (*RemoveDestroyedSandboxResponse, error)
	SandboxDaemonVersion(ctx context.Context, in *SandboxDaemonVersionRequest, opts ...grpc.CallOption) (*SandboxDaemonVersionResponse, error)
}

type sandboxServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSandboxServiceClient(cc grpc.ClientConnInterface) SandboxServiceClient {
	return &sandboxServiceClient{cc}
}

func (c *sandboxServiceClient) CreateSandbox(ctx context.Context, in *CreateSandboxRequest, opts ...grpc.CallOption) (*CreateSandboxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateSandboxResponse)
	err := c.cc.Invoke(ctx, SandboxService_CreateSandbox_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sandboxServiceClient) DestroySandbox(ctx context.Context, in *DestroySandboxRequest, opts ...grpc.CallOption) (*DestroySandboxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DestroySandboxResponse)
	err := c.cc.Invoke(ctx, SandboxService_DestroySandbox_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sandboxServiceClient) CreateBackup(ctx context.Context, in *CreateBackupRequest, opts ...grpc.CallOption) (*CreateBackupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateBackupResponse)
	err := c.cc.Invoke(ctx, SandboxService_CreateBackup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sandboxServiceClient) StartSandbox(ctx context.Context, in *StartSandboxRequest, opts ...grpc.CallOption) (*StartSandboxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartSandboxResponse)
	err := c.cc.Invoke(ctx, SandboxService_StartSandbox_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sandboxServiceClient) StopSandbox(ctx context.Context, in *StopSandboxRequest, opts ...grpc.CallOption) (*StopSandboxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopSandboxResponse)
	err := c.cc.Invoke(ctx, SandboxService_StopSandbox_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sandboxServiceClient) SandboxInfo(ctx context.Context, in *SandboxInfoRequest, opts ...grpc.CallOption) (*SandboxInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SandboxInfoResponse)
	err := c.cc.Invoke(ctx, SandboxService_SandboxInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sandboxServiceClient) RemoveDestroyedSandbox(ctx context.Context, in *RemoveDestroyedSandboxRequest, opts ...grpc.CallOption) (*RemoveDestroyedSandboxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveDestroyedSandboxResponse)
	err := c.cc.Invoke(ctx, SandboxService_RemoveDestroyedSandbox_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sandboxServiceClient) SandboxDaemonVersion(ctx context.Context, in *SandboxDaemonVersionRequest, opts ...grpc.CallOption) (*SandboxDaemonVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SandboxDaemonVersionResponse)
	err := c.cc.Invoke(ctx, SandboxService_SandboxDaemonVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SandboxServiceServer is the server API for SandboxService service.
// All implementations must embed UnimplementedSandboxServiceServer
// for forward compatibility.
//
// Sandbox service
type SandboxServiceServer interface {
	CreateSandbox(context.Context, *CreateSandboxRequest) (*CreateSandboxResponse, error)
	DestroySandbox(context.Context, *DestroySandboxRequest) (*DestroySandboxResponse, error)
	CreateBackup(context.Context, *CreateBackupRequest) (*CreateBackupResponse, error)
	StartSandbox(context.Context, *StartSandboxRequest) (*StartSandboxResponse, error)
	StopSandbox(context.Context, *StopSandboxRequest) (*StopSandboxResponse, error)
	SandboxInfo(context.Context, *SandboxInfoRequest) (*SandboxInfoResponse, error)
	RemoveDestroyedSandbox(context.Context, *RemoveDestroyedSandboxRequest) (*RemoveDestroyedSandboxResponse, error)
	SandboxDaemonVersion(context.Context, *SandboxDaemonVersionRequest) (*SandboxDaemonVersionResponse, error)
	mustEmbedUnimplementedSandboxServiceServer()
}

// UnimplementedSandboxServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSandboxServiceServer struct{}

func (UnimplementedSandboxServiceServer) CreateSandbox(context.Context, *CreateSandboxRequest) (*CreateSandboxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSandbox not implemented")
}
func (UnimplementedSandboxServiceServer) DestroySandbox(context.Context, *DestroySandboxRequest) (*DestroySandboxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroySandbox not implemented")
}
func (UnimplementedSandboxServiceServer) CreateBackup(context.Context, *CreateBackupRequest) (*CreateBackupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBackup not implemented")
}
func (UnimplementedSandboxServiceServer) StartSandbox(context.Context, *StartSandboxRequest) (*StartSandboxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartSandbox not implemented")
}
func (UnimplementedSandboxServiceServer) StopSandbox(context.Context, *StopSandboxRequest) (*StopSandboxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopSandbox not implemented")
}
func (UnimplementedSandboxServiceServer) SandboxInfo(context.Context, *SandboxInfoRequest) (*SandboxInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SandboxInfo not implemented")
}
func (UnimplementedSandboxServiceServer) RemoveDestroyedSandbox(context.Context, *RemoveDestroyedSandboxRequest) (*RemoveDestroyedSandboxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveDestroyedSandbox not implemented")
}
func (UnimplementedSandboxServiceServer) SandboxDaemonVersion(context.Context, *SandboxDaemonVersionRequest) (*SandboxDaemonVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SandboxDaemonVersion not implemented")
}
func (UnimplementedSandboxServiceServer) mustEmbedUnimplementedSandboxServiceServer() {}
func (UnimplementedSandboxServiceServer) testEmbeddedByValue()                        {}

// UnsafeSandboxServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SandboxServiceServer will
// result in compilation errors.
type UnsafeSandboxServiceServer interface {
	mustEmbedUnimplementedSandboxServiceServer()
}

func RegisterSandboxServiceServer(s grpc.ServiceRegistrar, srv SandboxServiceServer) {
	// If the following call pancis, it indicates UnimplementedSandboxServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SandboxService_ServiceDesc, srv)
}

func _SandboxService_CreateSandbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSandboxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SandboxServiceServer).CreateSandbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SandboxService_CreateSandbox_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SandboxServiceServer).CreateSandbox(ctx, req.(*CreateSandboxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SandboxService_DestroySandbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DestroySandboxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SandboxServiceServer).DestroySandbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SandboxService_DestroySandbox_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SandboxServiceServer).DestroySandbox(ctx, req.(*DestroySandboxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SandboxService_CreateBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBackupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SandboxServiceServer).CreateBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SandboxService_CreateBackup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SandboxServiceServer).CreateBackup(ctx, req.(*CreateBackupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SandboxService_StartSandbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartSandboxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SandboxServiceServer).StartSandbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SandboxService_StartSandbox_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SandboxServiceServer).StartSandbox(ctx, req.(*StartSandboxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SandboxService_StopSandbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopSandboxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SandboxServiceServer).StopSandbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SandboxService_StopSandbox_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SandboxServiceServer).StopSandbox(ctx, req.(*StopSandboxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SandboxService_SandboxInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SandboxInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SandboxServiceServer).SandboxInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SandboxService_SandboxInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SandboxServiceServer).SandboxInfo(ctx, req.(*SandboxInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SandboxService_RemoveDestroyedSandbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveDestroyedSandboxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SandboxServiceServer).RemoveDestroyedSandbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SandboxService_RemoveDestroyedSandbox_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SandboxServiceServer).RemoveDestroyedSandbox(ctx, req.(*RemoveDestroyedSandboxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SandboxService_SandboxDaemonVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SandboxDaemonVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SandboxServiceServer).SandboxDaemonVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SandboxService_SandboxDaemonVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SandboxServiceServer).SandboxDaemonVersion(ctx, req.(*SandboxDaemonVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SandboxService_ServiceDesc is the grpc.ServiceDesc for SandboxService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SandboxService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "runner.v1.SandboxService",
	HandlerType: (*SandboxServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSandbox",
			Handler:    _SandboxService_CreateSandbox_Handler,
		},
		{
			MethodName: "DestroySandbox",
			Handler:    _SandboxService_DestroySandbox_Handler,
		},
		{
			MethodName: "CreateBackup",
			Handler:    _SandboxService_CreateBackup_Handler,
		},
		{
			MethodName: "StartSandbox",
			Handler:    _SandboxService_StartSandbox_Handler,
		},
		{
			MethodName: "StopSandbox",
			Handler:    _SandboxService_StopSandbox_Handler,
		},
		{
			MethodName: "SandboxInfo",
			Handler:    _SandboxService_SandboxInfo_Handler,
		},
		{
			MethodName: "RemoveDestroyedSandbox",
			Handler:    _SandboxService_RemoveDestroyedSandbox_Handler,
		},
		{
			MethodName: "SandboxDaemonVersion",
			Handler:    _SandboxService_SandboxDaemonVersion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "runner/v1/runner.proto",
}

const (
	SnapshotService_PullSnapshot_FullMethodName    = "/runner.v1.SnapshotService/PullSnapshot"
	SnapshotService_BuildSnapshot_FullMethodName   = "/runner.v1.SnapshotService/BuildSnapshot"
	SnapshotService_SnapshotExists_FullMethodName  = "/runner.v1.SnapshotService/SnapshotExists"
	SnapshotService_RemoveSnapshot_FullMethodName  = "/runner.v1.SnapshotService/RemoveSnapshot"
	SnapshotService_GetSnapshotLogs_FullMethodName = "/runner.v1.SnapshotService/GetSnapshotLogs"
)

// SnapshotServiceClient is the client API for SnapshotService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Snapshot service
type SnapshotServiceClient interface {
	PullSnapshot(ctx context.Context, in *PullSnapshotRequest, opts ...grpc.CallOption) (*PullSnapshotResponse, error)
	BuildSnapshot(ctx context.Context, in *BuildSnapshotRequest, opts ...grpc.CallOption) (*BuildSnapshotResponse, error)
	SnapshotExists(ctx context.Context, in *SnapshotExistsRequest, opts ...grpc.CallOption) (*SnapshotExistsResponse, error)
	RemoveSnapshot(ctx context.Context, in *RemoveSnapshotRequest, opts ...grpc.CallOption) (*RemoveSnapshotResponse, error)
	GetSnapshotLogs(ctx context.Context, in *GetSnapshotLogsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GetSnapshotLogsResponse], error)
}

type snapshotServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSnapshotServiceClient(cc grpc.ClientConnInterface) SnapshotServiceClient {
	return &snapshotServiceClient{cc}
}

func (c *snapshotServiceClient) PullSnapshot(ctx context.Context, in *PullSnapshotRequest, opts ...grpc.CallOption) (*PullSnapshotResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PullSnapshotResponse)
	err := c.cc.Invoke(ctx, SnapshotService_PullSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *snapshotServiceClient) BuildSnapshot(ctx context.Context, in *BuildSnapshotRequest, opts ...grpc.CallOption) (*BuildSnapshotResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BuildSnapshotResponse)
	err := c.cc.Invoke(ctx, SnapshotService_BuildSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *snapshotServiceClient) SnapshotExists(ctx context.Context, in *SnapshotExistsRequest, opts ...grpc.CallOption) (*SnapshotExistsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SnapshotExistsResponse)
	err := c.cc.Invoke(ctx, SnapshotService_SnapshotExists_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *snapshotServiceClient) RemoveSnapshot(ctx context.Context, in *RemoveSnapshotRequest, opts ...grpc.CallOption) (*RemoveSnapshotResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveSnapshotResponse)
	err := c.cc.Invoke(ctx, SnapshotService_RemoveSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *snapshotServiceClient) GetSnapshotLogs(ctx context.Context, in *GetSnapshotLogsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GetSnapshotLogsResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &SnapshotService_ServiceDesc.Streams[0], SnapshotService_GetSnapshotLogs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetSnapshotLogsRequest, GetSnapshotLogsResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SnapshotService_GetSnapshotLogsClient = grpc.ServerStreamingClient[GetSnapshotLogsResponse]

// SnapshotServiceServer is the server API for SnapshotService service.
// All implementations must embed UnimplementedSnapshotServiceServer
// for forward compatibility.
//
// Snapshot service
type SnapshotServiceServer interface {
	PullSnapshot(context.Context, *PullSnapshotRequest) (*PullSnapshotResponse, error)
	BuildSnapshot(context.Context, *BuildSnapshotRequest) (*BuildSnapshotResponse, error)
	SnapshotExists(context.Context, *SnapshotExistsRequest) (*SnapshotExistsResponse, error)
	RemoveSnapshot(context.Context, *RemoveSnapshotRequest) (*RemoveSnapshotResponse, error)
	GetSnapshotLogs(*GetSnapshotLogsRequest, grpc.ServerStreamingServer[GetSnapshotLogsResponse]) error
	mustEmbedUnimplementedSnapshotServiceServer()
}

// UnimplementedSnapshotServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSnapshotServiceServer struct{}

func (UnimplementedSnapshotServiceServer) PullSnapshot(context.Context, *PullSnapshotRequest) (*PullSnapshotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PullSnapshot not implemented")
}
func (UnimplementedSnapshotServiceServer) BuildSnapshot(context.Context, *BuildSnapshotRequest) (*BuildSnapshotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuildSnapshot not implemented")
}
func (UnimplementedSnapshotServiceServer) SnapshotExists(context.Context, *SnapshotExistsRequest) (*SnapshotExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SnapshotExists not implemented")
}
func (UnimplementedSnapshotServiceServer) RemoveSnapshot(context.Context, *RemoveSnapshotRequest) (*RemoveSnapshotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveSnapshot not implemented")
}
func (UnimplementedSnapshotServiceServer) GetSnapshotLogs(*GetSnapshotLogsRequest, grpc.ServerStreamingServer[GetSnapshotLogsResponse]) error {
	return status.Errorf(codes.Unimplemented, "method GetSnapshotLogs not implemented")
}
func (UnimplementedSnapshotServiceServer) mustEmbedUnimplementedSnapshotServiceServer() {}
func (UnimplementedSnapshotServiceServer) testEmbeddedByValue()                         {}

// UnsafeSnapshotServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SnapshotServiceServer will
// result in compilation errors.
type UnsafeSnapshotServiceServer interface {
	mustEmbedUnimplementedSnapshotServiceServer()
}

func RegisterSnapshotServiceServer(s grpc.ServiceRegistrar, srv SnapshotServiceServer) {
	// If the following call pancis, it indicates UnimplementedSnapshotServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SnapshotService_ServiceDesc, srv)
}

func _SnapshotService_PullSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PullSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SnapshotServiceServer).PullSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SnapshotService_PullSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SnapshotServiceServer).PullSnapshot(ctx, req.(*PullSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SnapshotService_BuildSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuildSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SnapshotServiceServer).BuildSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SnapshotService_BuildSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SnapshotServiceServer).BuildSnapshot(ctx, req.(*BuildSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SnapshotService_SnapshotExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SnapshotExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SnapshotServiceServer).SnapshotExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SnapshotService_SnapshotExists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SnapshotServiceServer).SnapshotExists(ctx, req.(*SnapshotExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SnapshotService_RemoveSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SnapshotServiceServer).RemoveSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SnapshotService_RemoveSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SnapshotServiceServer).RemoveSnapshot(ctx, req.(*RemoveSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SnapshotService_GetSnapshotLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetSnapshotLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SnapshotServiceServer).GetSnapshotLogs(m, &grpc.GenericServerStream[GetSnapshotLogsRequest, GetSnapshotLogsResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SnapshotService_GetSnapshotLogsServer = grpc.ServerStreamingServer[GetSnapshotLogsResponse]

// SnapshotService_ServiceDesc is the grpc.ServiceDesc for SnapshotService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SnapshotService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "runner.v1.SnapshotService",
	HandlerType: (*SnapshotServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PullSnapshot",
			Handler:    _SnapshotService_PullSnapshot_Handler,
		},
		{
			MethodName: "BuildSnapshot",
			Handler:    _SnapshotService_BuildSnapshot_Handler,
		},
		{
			MethodName: "SnapshotExists",
			Handler:    _SnapshotService_SnapshotExists_Handler,
		},
		{
			MethodName: "RemoveSnapshot",
			Handler:    _SnapshotService_RemoveSnapshot_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetSnapshotLogs",
			Handler:       _SnapshotService_GetSnapshotLogs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "runner/v1/runner.proto",
}
