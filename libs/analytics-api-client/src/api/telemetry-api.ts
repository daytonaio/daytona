/* tslint:disable */
/* eslint-disable */
/**
 * Daytona Analytics API
 * Daytona Analytics API - Read-only telemetry and usage data
 *
 * The version of the OpenAPI document: v0.0.0-dev
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from '../configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from '../common'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base'
// @ts-ignore
import type { ModelsLogEntry } from '../models'
// @ts-ignore
import type { ModelsMetricPoint } from '../models'
// @ts-ignore
import type { ModelsSpan } from '../models'
// @ts-ignore
import type { ModelsTraceSummary } from '../models'
/**
 * TelemetryApi - axios parameter creator
 * @export
 */
export const TelemetryApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Returns paginated log entries with optional severity and search filters
     * @summary Get sandbox logs
     * @param {string} organizationId Organization ID
     * @param {string} sandboxId Sandbox ID
     * @param {string} from Start time (RFC3339)
     * @param {string} to End time (RFC3339)
     * @param {string} [severity] Comma-separated severity levels
     * @param {string} [search] Search text (ILIKE)
     * @param {number} [limit] Page size
     * @param {number} [offset] Offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organizationOrganizationIdSandboxSandboxIdTelemetryLogsGet: async (
      organizationId: string,
      sandboxId: string,
      from: string,
      to: string,
      severity?: string,
      search?: string,
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'organizationId' is not null or undefined
      assertParamExists('organizationOrganizationIdSandboxSandboxIdTelemetryLogsGet', 'organizationId', organizationId)
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('organizationOrganizationIdSandboxSandboxIdTelemetryLogsGet', 'sandboxId', sandboxId)
      // verify required parameter 'from' is not null or undefined
      assertParamExists('organizationOrganizationIdSandboxSandboxIdTelemetryLogsGet', 'from', from)
      // verify required parameter 'to' is not null or undefined
      assertParamExists('organizationOrganizationIdSandboxSandboxIdTelemetryLogsGet', 'to', to)
      const localVarPath = `/organization/{organizationId}/sandbox/{sandboxId}/telemetry/logs`
        .replace(`{${'organizationId'}}`, encodeURIComponent(String(organizationId)))
        .replace(`{${'sandboxId'}}`, encodeURIComponent(String(sandboxId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration)

      if (from !== undefined) {
        localVarQueryParameter['from'] = from
      }

      if (to !== undefined) {
        localVarQueryParameter['to'] = to
      }

      if (severity !== undefined) {
        localVarQueryParameter['severity'] = severity
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns gauge metrics aggregated in 1-minute intervals
     * @summary Get sandbox metrics
     * @param {string} organizationId Organization ID
     * @param {string} sandboxId Sandbox ID
     * @param {string} from Start time (RFC3339)
     * @param {string} to End time (RFC3339)
     * @param {string} [metricNames] Comma-separated metric names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organizationOrganizationIdSandboxSandboxIdTelemetryMetricsGet: async (
      organizationId: string,
      sandboxId: string,
      from: string,
      to: string,
      metricNames?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'organizationId' is not null or undefined
      assertParamExists(
        'organizationOrganizationIdSandboxSandboxIdTelemetryMetricsGet',
        'organizationId',
        organizationId,
      )
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('organizationOrganizationIdSandboxSandboxIdTelemetryMetricsGet', 'sandboxId', sandboxId)
      // verify required parameter 'from' is not null or undefined
      assertParamExists('organizationOrganizationIdSandboxSandboxIdTelemetryMetricsGet', 'from', from)
      // verify required parameter 'to' is not null or undefined
      assertParamExists('organizationOrganizationIdSandboxSandboxIdTelemetryMetricsGet', 'to', to)
      const localVarPath = `/organization/{organizationId}/sandbox/{sandboxId}/telemetry/metrics`
        .replace(`{${'organizationId'}}`, encodeURIComponent(String(organizationId)))
        .replace(`{${'sandboxId'}}`, encodeURIComponent(String(sandboxId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration)

      if (from !== undefined) {
        localVarQueryParameter['from'] = from
      }

      if (to !== undefined) {
        localVarQueryParameter['to'] = to
      }

      if (metricNames !== undefined) {
        localVarQueryParameter['metricNames'] = metricNames
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns paginated trace summaries with span counts and root span info
     * @summary Get sandbox traces
     * @param {string} organizationId Organization ID
     * @param {string} sandboxId Sandbox ID
     * @param {string} from Start time (RFC3339)
     * @param {string} to End time (RFC3339)
     * @param {number} [limit] Page size
     * @param {number} [offset] Offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organizationOrganizationIdSandboxSandboxIdTelemetryTracesGet: async (
      organizationId: string,
      sandboxId: string,
      from: string,
      to: string,
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'organizationId' is not null or undefined
      assertParamExists(
        'organizationOrganizationIdSandboxSandboxIdTelemetryTracesGet',
        'organizationId',
        organizationId,
      )
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('organizationOrganizationIdSandboxSandboxIdTelemetryTracesGet', 'sandboxId', sandboxId)
      // verify required parameter 'from' is not null or undefined
      assertParamExists('organizationOrganizationIdSandboxSandboxIdTelemetryTracesGet', 'from', from)
      // verify required parameter 'to' is not null or undefined
      assertParamExists('organizationOrganizationIdSandboxSandboxIdTelemetryTracesGet', 'to', to)
      const localVarPath = `/organization/{organizationId}/sandbox/{sandboxId}/telemetry/traces`
        .replace(`{${'organizationId'}}`, encodeURIComponent(String(organizationId)))
        .replace(`{${'sandboxId'}}`, encodeURIComponent(String(sandboxId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration)

      if (from !== undefined) {
        localVarQueryParameter['from'] = from
      }

      if (to !== undefined) {
        localVarQueryParameter['to'] = to
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns all spans belonging to a specific trace ID
     * @summary Get trace spans
     * @param {string} organizationId Organization ID
     * @param {string} sandboxId Sandbox ID
     * @param {string} traceId Trace ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organizationOrganizationIdSandboxSandboxIdTelemetryTracesTraceIdGet: async (
      organizationId: string,
      sandboxId: string,
      traceId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'organizationId' is not null or undefined
      assertParamExists(
        'organizationOrganizationIdSandboxSandboxIdTelemetryTracesTraceIdGet',
        'organizationId',
        organizationId,
      )
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('organizationOrganizationIdSandboxSandboxIdTelemetryTracesTraceIdGet', 'sandboxId', sandboxId)
      // verify required parameter 'traceId' is not null or undefined
      assertParamExists('organizationOrganizationIdSandboxSandboxIdTelemetryTracesTraceIdGet', 'traceId', traceId)
      const localVarPath = `/organization/{organizationId}/sandbox/{sandboxId}/telemetry/traces/{traceId}`
        .replace(`{${'organizationId'}}`, encodeURIComponent(String(organizationId)))
        .replace(`{${'sandboxId'}}`, encodeURIComponent(String(sandboxId)))
        .replace(`{${'traceId'}}`, encodeURIComponent(String(traceId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TelemetryApi - functional programming interface
 * @export
 */
export const TelemetryApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TelemetryApiAxiosParamCreator(configuration)
  return {
    /**
     * Returns paginated log entries with optional severity and search filters
     * @summary Get sandbox logs
     * @param {string} organizationId Organization ID
     * @param {string} sandboxId Sandbox ID
     * @param {string} from Start time (RFC3339)
     * @param {string} to End time (RFC3339)
     * @param {string} [severity] Comma-separated severity levels
     * @param {string} [search] Search text (ILIKE)
     * @param {number} [limit] Page size
     * @param {number} [offset] Offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async organizationOrganizationIdSandboxSandboxIdTelemetryLogsGet(
      organizationId: string,
      sandboxId: string,
      from: string,
      to: string,
      severity?: string,
      search?: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLogEntry>>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.organizationOrganizationIdSandboxSandboxIdTelemetryLogsGet(
          organizationId,
          sandboxId,
          from,
          to,
          severity,
          search,
          limit,
          offset,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TelemetryApi.organizationOrganizationIdSandboxSandboxIdTelemetryLogsGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Returns gauge metrics aggregated in 1-minute intervals
     * @summary Get sandbox metrics
     * @param {string} organizationId Organization ID
     * @param {string} sandboxId Sandbox ID
     * @param {string} from Start time (RFC3339)
     * @param {string} to End time (RFC3339)
     * @param {string} [metricNames] Comma-separated metric names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async organizationOrganizationIdSandboxSandboxIdTelemetryMetricsGet(
      organizationId: string,
      sandboxId: string,
      from: string,
      to: string,
      metricNames?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsMetricPoint>>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.organizationOrganizationIdSandboxSandboxIdTelemetryMetricsGet(
          organizationId,
          sandboxId,
          from,
          to,
          metricNames,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TelemetryApi.organizationOrganizationIdSandboxSandboxIdTelemetryMetricsGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Returns paginated trace summaries with span counts and root span info
     * @summary Get sandbox traces
     * @param {string} organizationId Organization ID
     * @param {string} sandboxId Sandbox ID
     * @param {string} from Start time (RFC3339)
     * @param {string} to End time (RFC3339)
     * @param {number} [limit] Page size
     * @param {number} [offset] Offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async organizationOrganizationIdSandboxSandboxIdTelemetryTracesGet(
      organizationId: string,
      sandboxId: string,
      from: string,
      to: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTraceSummary>>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.organizationOrganizationIdSandboxSandboxIdTelemetryTracesGet(
          organizationId,
          sandboxId,
          from,
          to,
          limit,
          offset,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TelemetryApi.organizationOrganizationIdSandboxSandboxIdTelemetryTracesGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Returns all spans belonging to a specific trace ID
     * @summary Get trace spans
     * @param {string} organizationId Organization ID
     * @param {string} sandboxId Sandbox ID
     * @param {string} traceId Trace ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async organizationOrganizationIdSandboxSandboxIdTelemetryTracesTraceIdGet(
      organizationId: string,
      sandboxId: string,
      traceId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpan>>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.organizationOrganizationIdSandboxSandboxIdTelemetryTracesTraceIdGet(
          organizationId,
          sandboxId,
          traceId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TelemetryApi.organizationOrganizationIdSandboxSandboxIdTelemetryTracesTraceIdGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * TelemetryApi - factory interface
 * @export
 */
export const TelemetryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = TelemetryApiFp(configuration)
  return {
    /**
     * Returns paginated log entries with optional severity and search filters
     * @summary Get sandbox logs
     * @param {string} organizationId Organization ID
     * @param {string} sandboxId Sandbox ID
     * @param {string} from Start time (RFC3339)
     * @param {string} to End time (RFC3339)
     * @param {string} [severity] Comma-separated severity levels
     * @param {string} [search] Search text (ILIKE)
     * @param {number} [limit] Page size
     * @param {number} [offset] Offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organizationOrganizationIdSandboxSandboxIdTelemetryLogsGet(
      organizationId: string,
      sandboxId: string,
      from: string,
      to: string,
      severity?: string,
      search?: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ModelsLogEntry>> {
      return localVarFp
        .organizationOrganizationIdSandboxSandboxIdTelemetryLogsGet(
          organizationId,
          sandboxId,
          from,
          to,
          severity,
          search,
          limit,
          offset,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns gauge metrics aggregated in 1-minute intervals
     * @summary Get sandbox metrics
     * @param {string} organizationId Organization ID
     * @param {string} sandboxId Sandbox ID
     * @param {string} from Start time (RFC3339)
     * @param {string} to End time (RFC3339)
     * @param {string} [metricNames] Comma-separated metric names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organizationOrganizationIdSandboxSandboxIdTelemetryMetricsGet(
      organizationId: string,
      sandboxId: string,
      from: string,
      to: string,
      metricNames?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ModelsMetricPoint>> {
      return localVarFp
        .organizationOrganizationIdSandboxSandboxIdTelemetryMetricsGet(
          organizationId,
          sandboxId,
          from,
          to,
          metricNames,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns paginated trace summaries with span counts and root span info
     * @summary Get sandbox traces
     * @param {string} organizationId Organization ID
     * @param {string} sandboxId Sandbox ID
     * @param {string} from Start time (RFC3339)
     * @param {string} to End time (RFC3339)
     * @param {number} [limit] Page size
     * @param {number} [offset] Offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organizationOrganizationIdSandboxSandboxIdTelemetryTracesGet(
      organizationId: string,
      sandboxId: string,
      from: string,
      to: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ModelsTraceSummary>> {
      return localVarFp
        .organizationOrganizationIdSandboxSandboxIdTelemetryTracesGet(
          organizationId,
          sandboxId,
          from,
          to,
          limit,
          offset,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns all spans belonging to a specific trace ID
     * @summary Get trace spans
     * @param {string} organizationId Organization ID
     * @param {string} sandboxId Sandbox ID
     * @param {string} traceId Trace ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organizationOrganizationIdSandboxSandboxIdTelemetryTracesTraceIdGet(
      organizationId: string,
      sandboxId: string,
      traceId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ModelsSpan>> {
      return localVarFp
        .organizationOrganizationIdSandboxSandboxIdTelemetryTracesTraceIdGet(
          organizationId,
          sandboxId,
          traceId,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * TelemetryApi - object-oriented interface
 * @export
 * @class TelemetryApi
 * @extends {BaseAPI}
 */
export class TelemetryApi extends BaseAPI {
  /**
   * Returns paginated log entries with optional severity and search filters
   * @summary Get sandbox logs
   * @param {string} organizationId Organization ID
   * @param {string} sandboxId Sandbox ID
   * @param {string} from Start time (RFC3339)
   * @param {string} to End time (RFC3339)
   * @param {string} [severity] Comma-separated severity levels
   * @param {string} [search] Search text (ILIKE)
   * @param {number} [limit] Page size
   * @param {number} [offset] Offset
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TelemetryApi
   */
  public organizationOrganizationIdSandboxSandboxIdTelemetryLogsGet(
    organizationId: string,
    sandboxId: string,
    from: string,
    to: string,
    severity?: string,
    search?: string,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return TelemetryApiFp(this.configuration)
      .organizationOrganizationIdSandboxSandboxIdTelemetryLogsGet(
        organizationId,
        sandboxId,
        from,
        to,
        severity,
        search,
        limit,
        offset,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns gauge metrics aggregated in 1-minute intervals
   * @summary Get sandbox metrics
   * @param {string} organizationId Organization ID
   * @param {string} sandboxId Sandbox ID
   * @param {string} from Start time (RFC3339)
   * @param {string} to End time (RFC3339)
   * @param {string} [metricNames] Comma-separated metric names
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TelemetryApi
   */
  public organizationOrganizationIdSandboxSandboxIdTelemetryMetricsGet(
    organizationId: string,
    sandboxId: string,
    from: string,
    to: string,
    metricNames?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return TelemetryApiFp(this.configuration)
      .organizationOrganizationIdSandboxSandboxIdTelemetryMetricsGet(
        organizationId,
        sandboxId,
        from,
        to,
        metricNames,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns paginated trace summaries with span counts and root span info
   * @summary Get sandbox traces
   * @param {string} organizationId Organization ID
   * @param {string} sandboxId Sandbox ID
   * @param {string} from Start time (RFC3339)
   * @param {string} to End time (RFC3339)
   * @param {number} [limit] Page size
   * @param {number} [offset] Offset
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TelemetryApi
   */
  public organizationOrganizationIdSandboxSandboxIdTelemetryTracesGet(
    organizationId: string,
    sandboxId: string,
    from: string,
    to: string,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return TelemetryApiFp(this.configuration)
      .organizationOrganizationIdSandboxSandboxIdTelemetryTracesGet(
        organizationId,
        sandboxId,
        from,
        to,
        limit,
        offset,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns all spans belonging to a specific trace ID
   * @summary Get trace spans
   * @param {string} organizationId Organization ID
   * @param {string} sandboxId Sandbox ID
   * @param {string} traceId Trace ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TelemetryApi
   */
  public organizationOrganizationIdSandboxSandboxIdTelemetryTracesTraceIdGet(
    organizationId: string,
    sandboxId: string,
    traceId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return TelemetryApiFp(this.configuration)
      .organizationOrganizationIdSandboxSandboxIdTelemetryTracesTraceIdGet(organizationId, sandboxId, traceId, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
