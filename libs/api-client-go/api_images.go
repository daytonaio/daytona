/*
Daytona

Daytona AI platform API Docs

API version: 1.0
Contact: support@daytona.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package daytonaapiclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type ImagesAPI interface {

	/*
		BuildImage Build a Docker image

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ImagesAPIBuildImageRequest
	*/
	BuildImage(ctx context.Context) ImagesAPIBuildImageRequest

	// BuildImageExecute executes the request
	//  @return ImageDto
	BuildImageExecute(r ImagesAPIBuildImageRequest) (*ImageDto, *http.Response, error)

	/*
		CreateImage Create a new image

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ImagesAPICreateImageRequest
	*/
	CreateImage(ctx context.Context) ImagesAPICreateImageRequest

	// CreateImageExecute executes the request
	//  @return ImageDto
	CreateImageExecute(r ImagesAPICreateImageRequest) (*ImageDto, *http.Response, error)

	/*
		GetAllImages List all images

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ImagesAPIGetAllImagesRequest
	*/
	GetAllImages(ctx context.Context) ImagesAPIGetAllImagesRequest

	// GetAllImagesExecute executes the request
	//  @return PaginatedImagesDto
	GetAllImagesExecute(r ImagesAPIGetAllImagesRequest) (*PaginatedImagesDto, *http.Response, error)

	/*
		GetImage Get image by ID

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id Image ID
		@return ImagesAPIGetImageRequest
	*/
	GetImage(ctx context.Context, id string) ImagesAPIGetImageRequest

	// GetImageExecute executes the request
	//  @return ImageDto
	GetImageExecute(r ImagesAPIGetImageRequest) (*ImageDto, *http.Response, error)

	/*
		GetImageBuildLogs Get image build logs

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id Image ID
		@return ImagesAPIGetImageBuildLogsRequest
	*/
	GetImageBuildLogs(ctx context.Context, id string) ImagesAPIGetImageBuildLogsRequest

	// GetImageBuildLogsExecute executes the request
	GetImageBuildLogsExecute(r ImagesAPIGetImageBuildLogsRequest) (*http.Response, error)

	/*
		RemoveImage Delete image

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id Image ID
		@return ImagesAPIRemoveImageRequest
	*/
	RemoveImage(ctx context.Context, id string) ImagesAPIRemoveImageRequest

	// RemoveImageExecute executes the request
	RemoveImageExecute(r ImagesAPIRemoveImageRequest) (*http.Response, error)

	/*
		SetImageGeneralStatus Set image general status

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id Image ID
		@return ImagesAPISetImageGeneralStatusRequest
	*/
	SetImageGeneralStatus(ctx context.Context, id string) ImagesAPISetImageGeneralStatusRequest

	// SetImageGeneralStatusExecute executes the request
	//  @return ImageDto
	SetImageGeneralStatusExecute(r ImagesAPISetImageGeneralStatusRequest) (*ImageDto, *http.Response, error)

	/*
		ToggleImageState Toggle image state

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id Image ID
		@return ImagesAPIToggleImageStateRequest
	*/
	ToggleImageState(ctx context.Context, id string) ImagesAPIToggleImageStateRequest

	// ToggleImageStateExecute executes the request
	//  @return ImageDto
	ToggleImageStateExecute(r ImagesAPIToggleImageStateRequest) (*ImageDto, *http.Response, error)
}

// ImagesAPIService ImagesAPI service
type ImagesAPIService service

type ImagesAPIBuildImageRequest struct {
	ctx                    context.Context
	ApiService             ImagesAPI
	buildImage             *BuildImage
	xDaytonaOrganizationID *string
}

func (r ImagesAPIBuildImageRequest) BuildImage(buildImage BuildImage) ImagesAPIBuildImageRequest {
	r.buildImage = &buildImage
	return r
}

// Use with JWT to specify the organization ID
func (r ImagesAPIBuildImageRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ImagesAPIBuildImageRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ImagesAPIBuildImageRequest) Execute() (*ImageDto, *http.Response, error) {
	return r.ApiService.BuildImageExecute(r)
}

/*
BuildImage Build a Docker image

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ImagesAPIBuildImageRequest
*/
func (a *ImagesAPIService) BuildImage(ctx context.Context) ImagesAPIBuildImageRequest {
	return ImagesAPIBuildImageRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ImageDto
func (a *ImagesAPIService) BuildImageExecute(r ImagesAPIBuildImageRequest) (*ImageDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ImageDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesAPIService.BuildImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/build"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.buildImage == nil {
		return localVarReturnValue, nil, reportError("buildImage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.buildImage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImagesAPICreateImageRequest struct {
	ctx                    context.Context
	ApiService             ImagesAPI
	createImage            *CreateImage
	xDaytonaOrganizationID *string
}

func (r ImagesAPICreateImageRequest) CreateImage(createImage CreateImage) ImagesAPICreateImageRequest {
	r.createImage = &createImage
	return r
}

// Use with JWT to specify the organization ID
func (r ImagesAPICreateImageRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ImagesAPICreateImageRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ImagesAPICreateImageRequest) Execute() (*ImageDto, *http.Response, error) {
	return r.ApiService.CreateImageExecute(r)
}

/*
CreateImage Create a new image

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ImagesAPICreateImageRequest
*/
func (a *ImagesAPIService) CreateImage(ctx context.Context) ImagesAPICreateImageRequest {
	return ImagesAPICreateImageRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ImageDto
func (a *ImagesAPIService) CreateImageExecute(r ImagesAPICreateImageRequest) (*ImageDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ImageDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesAPIService.CreateImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createImage == nil {
		return localVarReturnValue, nil, reportError("createImage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.createImage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImagesAPIGetAllImagesRequest struct {
	ctx                    context.Context
	ApiService             ImagesAPI
	xDaytonaOrganizationID *string
	limit                  *float32
	page                   *float32
}

// Use with JWT to specify the organization ID
func (r ImagesAPIGetAllImagesRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ImagesAPIGetAllImagesRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

// Number of items per page
func (r ImagesAPIGetAllImagesRequest) Limit(limit float32) ImagesAPIGetAllImagesRequest {
	r.limit = &limit
	return r
}

// Page number
func (r ImagesAPIGetAllImagesRequest) Page(page float32) ImagesAPIGetAllImagesRequest {
	r.page = &page
	return r
}

func (r ImagesAPIGetAllImagesRequest) Execute() (*PaginatedImagesDto, *http.Response, error) {
	return r.ApiService.GetAllImagesExecute(r)
}

/*
GetAllImages List all images

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ImagesAPIGetAllImagesRequest
*/
func (a *ImagesAPIService) GetAllImages(ctx context.Context) ImagesAPIGetAllImagesRequest {
	return ImagesAPIGetAllImagesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedImagesDto
func (a *ImagesAPIService) GetAllImagesExecute(r ImagesAPIGetAllImagesRequest) (*PaginatedImagesDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedImagesDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesAPIService.GetAllImages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImagesAPIGetImageRequest struct {
	ctx                    context.Context
	ApiService             ImagesAPI
	id                     string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ImagesAPIGetImageRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ImagesAPIGetImageRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ImagesAPIGetImageRequest) Execute() (*ImageDto, *http.Response, error) {
	return r.ApiService.GetImageExecute(r)
}

/*
GetImage Get image by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Image ID
	@return ImagesAPIGetImageRequest
*/
func (a *ImagesAPIService) GetImage(ctx context.Context, id string) ImagesAPIGetImageRequest {
	return ImagesAPIGetImageRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ImageDto
func (a *ImagesAPIService) GetImageExecute(r ImagesAPIGetImageRequest) (*ImageDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ImageDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesAPIService.GetImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImagesAPIGetImageBuildLogsRequest struct {
	ctx                    context.Context
	ApiService             ImagesAPI
	id                     string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ImagesAPIGetImageBuildLogsRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ImagesAPIGetImageBuildLogsRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ImagesAPIGetImageBuildLogsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetImageBuildLogsExecute(r)
}

/*
GetImageBuildLogs Get image build logs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Image ID
	@return ImagesAPIGetImageBuildLogsRequest
*/
func (a *ImagesAPIService) GetImageBuildLogs(ctx context.Context, id string) ImagesAPIGetImageBuildLogsRequest {
	return ImagesAPIGetImageBuildLogsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *ImagesAPIService) GetImageBuildLogsExecute(r ImagesAPIGetImageBuildLogsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesAPIService.GetImageBuildLogs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{id}/build-logs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImagesAPIRemoveImageRequest struct {
	ctx                    context.Context
	ApiService             ImagesAPI
	id                     string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ImagesAPIRemoveImageRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ImagesAPIRemoveImageRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ImagesAPIRemoveImageRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveImageExecute(r)
}

/*
RemoveImage Delete image

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Image ID
	@return ImagesAPIRemoveImageRequest
*/
func (a *ImagesAPIService) RemoveImage(ctx context.Context, id string) ImagesAPIRemoveImageRequest {
	return ImagesAPIRemoveImageRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *ImagesAPIService) RemoveImageExecute(r ImagesAPIRemoveImageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesAPIService.RemoveImage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImagesAPISetImageGeneralStatusRequest struct {
	ctx                    context.Context
	ApiService             ImagesAPI
	id                     string
	setImageGeneralStatus  *SetImageGeneralStatus
	xDaytonaOrganizationID *string
}

func (r ImagesAPISetImageGeneralStatusRequest) SetImageGeneralStatus(setImageGeneralStatus SetImageGeneralStatus) ImagesAPISetImageGeneralStatusRequest {
	r.setImageGeneralStatus = &setImageGeneralStatus
	return r
}

// Use with JWT to specify the organization ID
func (r ImagesAPISetImageGeneralStatusRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ImagesAPISetImageGeneralStatusRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ImagesAPISetImageGeneralStatusRequest) Execute() (*ImageDto, *http.Response, error) {
	return r.ApiService.SetImageGeneralStatusExecute(r)
}

/*
SetImageGeneralStatus Set image general status

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Image ID
	@return ImagesAPISetImageGeneralStatusRequest
*/
func (a *ImagesAPIService) SetImageGeneralStatus(ctx context.Context, id string) ImagesAPISetImageGeneralStatusRequest {
	return ImagesAPISetImageGeneralStatusRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ImageDto
func (a *ImagesAPIService) SetImageGeneralStatusExecute(r ImagesAPISetImageGeneralStatusRequest) (*ImageDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ImageDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesAPIService.SetImageGeneralStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{id}/general"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.setImageGeneralStatus == nil {
		return localVarReturnValue, nil, reportError("setImageGeneralStatus is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.setImageGeneralStatus
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImagesAPIToggleImageStateRequest struct {
	ctx                    context.Context
	ApiService             ImagesAPI
	id                     string
	toggleState            *ToggleState
	xDaytonaOrganizationID *string
}

func (r ImagesAPIToggleImageStateRequest) ToggleState(toggleState ToggleState) ImagesAPIToggleImageStateRequest {
	r.toggleState = &toggleState
	return r
}

// Use with JWT to specify the organization ID
func (r ImagesAPIToggleImageStateRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ImagesAPIToggleImageStateRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ImagesAPIToggleImageStateRequest) Execute() (*ImageDto, *http.Response, error) {
	return r.ApiService.ToggleImageStateExecute(r)
}

/*
ToggleImageState Toggle image state

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Image ID
	@return ImagesAPIToggleImageStateRequest
*/
func (a *ImagesAPIService) ToggleImageState(ctx context.Context, id string) ImagesAPIToggleImageStateRequest {
	return ImagesAPIToggleImageStateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ImageDto
func (a *ImagesAPIService) ToggleImageStateExecute(r ImagesAPIToggleImageStateRequest) (*ImageDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ImageDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesAPIService.ToggleImageState")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{id}/toggle"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toggleState == nil {
		return localVarReturnValue, nil, reportError("toggleState is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.toggleState
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
