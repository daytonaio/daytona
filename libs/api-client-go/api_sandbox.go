/*
Daytona

Daytona AI platform API Docs

API version: 1.0
Contact: support@daytona.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apiclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type SandboxAPI interface {

	/*
		ArchiveSandbox Archive sandbox

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return SandboxAPIArchiveSandboxRequest
	*/
	ArchiveSandbox(ctx context.Context, sandboxId string) SandboxAPIArchiveSandboxRequest

	// ArchiveSandboxExecute executes the request
	ArchiveSandboxExecute(r SandboxAPIArchiveSandboxRequest) (*http.Response, error)

	/*
		CreateBackup Create sandbox backup

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId ID of the sandbox
		@return SandboxAPICreateBackupRequest
	*/
	CreateBackup(ctx context.Context, sandboxId string) SandboxAPICreateBackupRequest

	// CreateBackupExecute executes the request
	//  @return Sandbox
	CreateBackupExecute(r SandboxAPICreateBackupRequest) (*Sandbox, *http.Response, error)

	/*
		CreateSandbox Create a new sandbox

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return SandboxAPICreateSandboxRequest
	*/
	CreateSandbox(ctx context.Context) SandboxAPICreateSandboxRequest

	// CreateSandboxExecute executes the request
	//  @return Sandbox
	CreateSandboxExecute(r SandboxAPICreateSandboxRequest) (*Sandbox, *http.Response, error)

	/*
		DeleteSandbox Delete sandbox

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId ID of the sandbox
		@return SandboxAPIDeleteSandboxRequest
	*/
	DeleteSandbox(ctx context.Context, sandboxId string) SandboxAPIDeleteSandboxRequest

	// DeleteSandboxExecute executes the request
	DeleteSandboxExecute(r SandboxAPIDeleteSandboxRequest) (*http.Response, error)

	/*
		GetBuildLogs Get build logs

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId ID of the sandbox
		@return SandboxAPIGetBuildLogsRequest
	*/
	GetBuildLogs(ctx context.Context, sandboxId string) SandboxAPIGetBuildLogsRequest

	// GetBuildLogsExecute executes the request
	GetBuildLogsExecute(r SandboxAPIGetBuildLogsRequest) (*http.Response, error)

	/*
		GetPortPreviewUrl Get preview URL for a sandbox port

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId ID of the sandbox
		@param port Port number to get preview URL for
		@return SandboxAPIGetPortPreviewUrlRequest
	*/
	GetPortPreviewUrl(ctx context.Context, sandboxId string, port float32) SandboxAPIGetPortPreviewUrlRequest

	// GetPortPreviewUrlExecute executes the request
	//  @return PortPreviewUrl
	GetPortPreviewUrlExecute(r SandboxAPIGetPortPreviewUrlRequest) (*PortPreviewUrl, *http.Response, error)

	/*
		GetSandbox Get sandbox details

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId ID of the sandbox
		@return SandboxAPIGetSandboxRequest
	*/
	GetSandbox(ctx context.Context, sandboxId string) SandboxAPIGetSandboxRequest

	// GetSandboxExecute executes the request
	//  @return Sandbox
	GetSandboxExecute(r SandboxAPIGetSandboxRequest) (*Sandbox, *http.Response, error)

	/*
		ListSandboxes List all sandboxes

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return SandboxAPIListSandboxesRequest
	*/
	ListSandboxes(ctx context.Context) SandboxAPIListSandboxesRequest

	// ListSandboxesExecute executes the request
	//  @return []Sandbox
	ListSandboxesExecute(r SandboxAPIListSandboxesRequest) ([]Sandbox, *http.Response, error)

	/*
		ReplaceLabels Replace sandbox labels

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId ID of the sandbox
		@return SandboxAPIReplaceLabelsRequest
	*/
	ReplaceLabels(ctx context.Context, sandboxId string) SandboxAPIReplaceLabelsRequest

	// ReplaceLabelsExecute executes the request
	//  @return SandboxLabels
	ReplaceLabelsExecute(r SandboxAPIReplaceLabelsRequest) (*SandboxLabels, *http.Response, error)

	/*
		SetAutoArchiveInterval Set sandbox auto-archive interval

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId ID of the sandbox
		@param interval Auto-archive interval in minutes (0 means the maximum interval will be used)
		@return SandboxAPISetAutoArchiveIntervalRequest
	*/
	SetAutoArchiveInterval(ctx context.Context, sandboxId string, interval float32) SandboxAPISetAutoArchiveIntervalRequest

	// SetAutoArchiveIntervalExecute executes the request
	SetAutoArchiveIntervalExecute(r SandboxAPISetAutoArchiveIntervalRequest) (*http.Response, error)

	/*
		SetAutoDeleteInterval Set sandbox auto-delete interval

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId ID of the sandbox
		@param interval Auto-delete interval in minutes (negative value means disabled, 0 means delete immediately upon stopping)
		@return SandboxAPISetAutoDeleteIntervalRequest
	*/
	SetAutoDeleteInterval(ctx context.Context, sandboxId string, interval float32) SandboxAPISetAutoDeleteIntervalRequest

	// SetAutoDeleteIntervalExecute executes the request
	SetAutoDeleteIntervalExecute(r SandboxAPISetAutoDeleteIntervalRequest) (*http.Response, error)

	/*
		SetAutostopInterval Set sandbox auto-stop interval

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId ID of the sandbox
		@param interval Auto-stop interval in minutes (0 to disable)
		@return SandboxAPISetAutostopIntervalRequest
	*/
	SetAutostopInterval(ctx context.Context, sandboxId string, interval float32) SandboxAPISetAutostopIntervalRequest

	// SetAutostopIntervalExecute executes the request
	SetAutostopIntervalExecute(r SandboxAPISetAutostopIntervalRequest) (*http.Response, error)

	/*
		StartSandbox Start sandbox

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId ID of the sandbox
		@return SandboxAPIStartSandboxRequest
	*/
	StartSandbox(ctx context.Context, sandboxId string) SandboxAPIStartSandboxRequest

	// StartSandboxExecute executes the request
	//  @return Sandbox
	StartSandboxExecute(r SandboxAPIStartSandboxRequest) (*Sandbox, *http.Response, error)

	/*
		StopSandbox Stop sandbox

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId ID of the sandbox
		@return SandboxAPIStopSandboxRequest
	*/
	StopSandbox(ctx context.Context, sandboxId string) SandboxAPIStopSandboxRequest

	// StopSandboxExecute executes the request
	StopSandboxExecute(r SandboxAPIStopSandboxRequest) (*http.Response, error)

	/*
		UpdatePublicStatus Update public status

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId ID of the sandbox
		@param isPublic Public status to set
		@return SandboxAPIUpdatePublicStatusRequest
	*/
	UpdatePublicStatus(ctx context.Context, sandboxId string, isPublic bool) SandboxAPIUpdatePublicStatusRequest

	// UpdatePublicStatusExecute executes the request
	UpdatePublicStatusExecute(r SandboxAPIUpdatePublicStatusRequest) (*http.Response, error)
}

// SandboxAPIService SandboxAPI service
type SandboxAPIService service

type SandboxAPIArchiveSandboxRequest struct {
	ctx                    context.Context
	ApiService             SandboxAPI
	sandboxId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r SandboxAPIArchiveSandboxRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) SandboxAPIArchiveSandboxRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r SandboxAPIArchiveSandboxRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveSandboxExecute(r)
}

/*
ArchiveSandbox Archive sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return SandboxAPIArchiveSandboxRequest
*/
func (a *SandboxAPIService) ArchiveSandbox(ctx context.Context, sandboxId string) SandboxAPIArchiveSandboxRequest {
	return SandboxAPIArchiveSandboxRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *SandboxAPIService) ArchiveSandboxExecute(r SandboxAPIArchiveSandboxRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxAPIService.ArchiveSandbox")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sandbox/{sandboxId}/archive"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SandboxAPICreateBackupRequest struct {
	ctx                    context.Context
	ApiService             SandboxAPI
	sandboxId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r SandboxAPICreateBackupRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) SandboxAPICreateBackupRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r SandboxAPICreateBackupRequest) Execute() (*Sandbox, *http.Response, error) {
	return r.ApiService.CreateBackupExecute(r)
}

/*
CreateBackup Create sandbox backup

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId ID of the sandbox
	@return SandboxAPICreateBackupRequest
*/
func (a *SandboxAPIService) CreateBackup(ctx context.Context, sandboxId string) SandboxAPICreateBackupRequest {
	return SandboxAPICreateBackupRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return Sandbox
func (a *SandboxAPIService) CreateBackupExecute(r SandboxAPICreateBackupRequest) (*Sandbox, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Sandbox
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxAPIService.CreateBackup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sandbox/{sandboxId}/backup"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SandboxAPICreateSandboxRequest struct {
	ctx                    context.Context
	ApiService             SandboxAPI
	createSandbox          *CreateSandbox
	xDaytonaOrganizationID *string
}

func (r SandboxAPICreateSandboxRequest) CreateSandbox(createSandbox CreateSandbox) SandboxAPICreateSandboxRequest {
	r.createSandbox = &createSandbox
	return r
}

// Use with JWT to specify the organization ID
func (r SandboxAPICreateSandboxRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) SandboxAPICreateSandboxRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r SandboxAPICreateSandboxRequest) Execute() (*Sandbox, *http.Response, error) {
	return r.ApiService.CreateSandboxExecute(r)
}

/*
CreateSandbox Create a new sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SandboxAPICreateSandboxRequest
*/
func (a *SandboxAPIService) CreateSandbox(ctx context.Context) SandboxAPICreateSandboxRequest {
	return SandboxAPICreateSandboxRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Sandbox
func (a *SandboxAPIService) CreateSandboxExecute(r SandboxAPICreateSandboxRequest) (*Sandbox, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Sandbox
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxAPIService.CreateSandbox")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sandbox"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createSandbox == nil {
		return localVarReturnValue, nil, reportError("createSandbox is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.createSandbox
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SandboxAPIDeleteSandboxRequest struct {
	ctx                    context.Context
	ApiService             SandboxAPI
	sandboxId              string
	force                  *bool
	xDaytonaOrganizationID *string
}

func (r SandboxAPIDeleteSandboxRequest) Force(force bool) SandboxAPIDeleteSandboxRequest {
	r.force = &force
	return r
}

// Use with JWT to specify the organization ID
func (r SandboxAPIDeleteSandboxRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) SandboxAPIDeleteSandboxRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r SandboxAPIDeleteSandboxRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSandboxExecute(r)
}

/*
DeleteSandbox Delete sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId ID of the sandbox
	@return SandboxAPIDeleteSandboxRequest
*/
func (a *SandboxAPIService) DeleteSandbox(ctx context.Context, sandboxId string) SandboxAPIDeleteSandboxRequest {
	return SandboxAPIDeleteSandboxRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *SandboxAPIService) DeleteSandboxExecute(r SandboxAPIDeleteSandboxRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxAPIService.DeleteSandbox")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sandbox/{sandboxId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.force == nil {
		return nil, reportError("force is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SandboxAPIGetBuildLogsRequest struct {
	ctx                    context.Context
	ApiService             SandboxAPI
	sandboxId              string
	xDaytonaOrganizationID *string
	follow                 *bool
}

// Use with JWT to specify the organization ID
func (r SandboxAPIGetBuildLogsRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) SandboxAPIGetBuildLogsRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

// Whether to follow the logs stream
func (r SandboxAPIGetBuildLogsRequest) Follow(follow bool) SandboxAPIGetBuildLogsRequest {
	r.follow = &follow
	return r
}

func (r SandboxAPIGetBuildLogsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetBuildLogsExecute(r)
}

/*
GetBuildLogs Get build logs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId ID of the sandbox
	@return SandboxAPIGetBuildLogsRequest
*/
func (a *SandboxAPIService) GetBuildLogs(ctx context.Context, sandboxId string) SandboxAPIGetBuildLogsRequest {
	return SandboxAPIGetBuildLogsRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *SandboxAPIService) GetBuildLogsExecute(r SandboxAPIGetBuildLogsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxAPIService.GetBuildLogs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sandbox/{sandboxId}/build-logs"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.follow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "follow", r.follow, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SandboxAPIGetPortPreviewUrlRequest struct {
	ctx                    context.Context
	ApiService             SandboxAPI
	sandboxId              string
	port                   float32
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r SandboxAPIGetPortPreviewUrlRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) SandboxAPIGetPortPreviewUrlRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r SandboxAPIGetPortPreviewUrlRequest) Execute() (*PortPreviewUrl, *http.Response, error) {
	return r.ApiService.GetPortPreviewUrlExecute(r)
}

/*
GetPortPreviewUrl Get preview URL for a sandbox port

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId ID of the sandbox
	@param port Port number to get preview URL for
	@return SandboxAPIGetPortPreviewUrlRequest
*/
func (a *SandboxAPIService) GetPortPreviewUrl(ctx context.Context, sandboxId string, port float32) SandboxAPIGetPortPreviewUrlRequest {
	return SandboxAPIGetPortPreviewUrlRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
		port:       port,
	}
}

// Execute executes the request
//
//	@return PortPreviewUrl
func (a *SandboxAPIService) GetPortPreviewUrlExecute(r SandboxAPIGetPortPreviewUrlRequest) (*PortPreviewUrl, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PortPreviewUrl
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxAPIService.GetPortPreviewUrl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sandbox/{sandboxId}/ports/{port}/preview-url"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"port"+"}", url.PathEscape(parameterValueToString(r.port, "port")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SandboxAPIGetSandboxRequest struct {
	ctx                    context.Context
	ApiService             SandboxAPI
	sandboxId              string
	xDaytonaOrganizationID *string
	verbose                *bool
}

// Use with JWT to specify the organization ID
func (r SandboxAPIGetSandboxRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) SandboxAPIGetSandboxRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

// Include verbose output
func (r SandboxAPIGetSandboxRequest) Verbose(verbose bool) SandboxAPIGetSandboxRequest {
	r.verbose = &verbose
	return r
}

func (r SandboxAPIGetSandboxRequest) Execute() (*Sandbox, *http.Response, error) {
	return r.ApiService.GetSandboxExecute(r)
}

/*
GetSandbox Get sandbox details

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId ID of the sandbox
	@return SandboxAPIGetSandboxRequest
*/
func (a *SandboxAPIService) GetSandbox(ctx context.Context, sandboxId string) SandboxAPIGetSandboxRequest {
	return SandboxAPIGetSandboxRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return Sandbox
func (a *SandboxAPIService) GetSandboxExecute(r SandboxAPIGetSandboxRequest) (*Sandbox, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Sandbox
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxAPIService.GetSandbox")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sandbox/{sandboxId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.verbose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verbose", r.verbose, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SandboxAPIListSandboxesRequest struct {
	ctx                    context.Context
	ApiService             SandboxAPI
	xDaytonaOrganizationID *string
	verbose                *bool
	labels                 *string
	includeErroredDeleted  *bool
}

// Use with JWT to specify the organization ID
func (r SandboxAPIListSandboxesRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) SandboxAPIListSandboxesRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

// Include verbose output
func (r SandboxAPIListSandboxesRequest) Verbose(verbose bool) SandboxAPIListSandboxesRequest {
	r.verbose = &verbose
	return r
}

// JSON encoded labels to filter by
func (r SandboxAPIListSandboxesRequest) Labels(labels string) SandboxAPIListSandboxesRequest {
	r.labels = &labels
	return r
}

// Include errored and deleted sandboxes
func (r SandboxAPIListSandboxesRequest) IncludeErroredDeleted(includeErroredDeleted bool) SandboxAPIListSandboxesRequest {
	r.includeErroredDeleted = &includeErroredDeleted
	return r
}

func (r SandboxAPIListSandboxesRequest) Execute() ([]Sandbox, *http.Response, error) {
	return r.ApiService.ListSandboxesExecute(r)
}

/*
ListSandboxes List all sandboxes

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SandboxAPIListSandboxesRequest
*/
func (a *SandboxAPIService) ListSandboxes(ctx context.Context) SandboxAPIListSandboxesRequest {
	return SandboxAPIListSandboxesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Sandbox
func (a *SandboxAPIService) ListSandboxesExecute(r SandboxAPIListSandboxesRequest) ([]Sandbox, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Sandbox
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxAPIService.ListSandboxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sandbox"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.verbose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verbose", r.verbose, "form", "")
	}
	if r.labels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "labels", r.labels, "form", "")
	}
	if r.includeErroredDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeErroredDeleted", r.includeErroredDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SandboxAPIReplaceLabelsRequest struct {
	ctx                    context.Context
	ApiService             SandboxAPI
	sandboxId              string
	sandboxLabels          *SandboxLabels
	xDaytonaOrganizationID *string
}

func (r SandboxAPIReplaceLabelsRequest) SandboxLabels(sandboxLabels SandboxLabels) SandboxAPIReplaceLabelsRequest {
	r.sandboxLabels = &sandboxLabels
	return r
}

// Use with JWT to specify the organization ID
func (r SandboxAPIReplaceLabelsRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) SandboxAPIReplaceLabelsRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r SandboxAPIReplaceLabelsRequest) Execute() (*SandboxLabels, *http.Response, error) {
	return r.ApiService.ReplaceLabelsExecute(r)
}

/*
ReplaceLabels Replace sandbox labels

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId ID of the sandbox
	@return SandboxAPIReplaceLabelsRequest
*/
func (a *SandboxAPIService) ReplaceLabels(ctx context.Context, sandboxId string) SandboxAPIReplaceLabelsRequest {
	return SandboxAPIReplaceLabelsRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return SandboxLabels
func (a *SandboxAPIService) ReplaceLabelsExecute(r SandboxAPIReplaceLabelsRequest) (*SandboxLabels, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SandboxLabels
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxAPIService.ReplaceLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sandbox/{sandboxId}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sandboxLabels == nil {
		return localVarReturnValue, nil, reportError("sandboxLabels is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.sandboxLabels
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SandboxAPISetAutoArchiveIntervalRequest struct {
	ctx                    context.Context
	ApiService             SandboxAPI
	sandboxId              string
	interval               float32
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r SandboxAPISetAutoArchiveIntervalRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) SandboxAPISetAutoArchiveIntervalRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r SandboxAPISetAutoArchiveIntervalRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetAutoArchiveIntervalExecute(r)
}

/*
SetAutoArchiveInterval Set sandbox auto-archive interval

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId ID of the sandbox
	@param interval Auto-archive interval in minutes (0 means the maximum interval will be used)
	@return SandboxAPISetAutoArchiveIntervalRequest
*/
func (a *SandboxAPIService) SetAutoArchiveInterval(ctx context.Context, sandboxId string, interval float32) SandboxAPISetAutoArchiveIntervalRequest {
	return SandboxAPISetAutoArchiveIntervalRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
		interval:   interval,
	}
}

// Execute executes the request
func (a *SandboxAPIService) SetAutoArchiveIntervalExecute(r SandboxAPISetAutoArchiveIntervalRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxAPIService.SetAutoArchiveInterval")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sandbox/{sandboxId}/autoarchive/{interval}"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interval"+"}", url.PathEscape(parameterValueToString(r.interval, "interval")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SandboxAPISetAutoDeleteIntervalRequest struct {
	ctx                    context.Context
	ApiService             SandboxAPI
	sandboxId              string
	interval               float32
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r SandboxAPISetAutoDeleteIntervalRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) SandboxAPISetAutoDeleteIntervalRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r SandboxAPISetAutoDeleteIntervalRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetAutoDeleteIntervalExecute(r)
}

/*
SetAutoDeleteInterval Set sandbox auto-delete interval

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId ID of the sandbox
	@param interval Auto-delete interval in minutes (negative value means disabled, 0 means delete immediately upon stopping)
	@return SandboxAPISetAutoDeleteIntervalRequest
*/
func (a *SandboxAPIService) SetAutoDeleteInterval(ctx context.Context, sandboxId string, interval float32) SandboxAPISetAutoDeleteIntervalRequest {
	return SandboxAPISetAutoDeleteIntervalRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
		interval:   interval,
	}
}

// Execute executes the request
func (a *SandboxAPIService) SetAutoDeleteIntervalExecute(r SandboxAPISetAutoDeleteIntervalRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxAPIService.SetAutoDeleteInterval")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sandbox/{sandboxId}/autodelete/{interval}"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interval"+"}", url.PathEscape(parameterValueToString(r.interval, "interval")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SandboxAPISetAutostopIntervalRequest struct {
	ctx                    context.Context
	ApiService             SandboxAPI
	sandboxId              string
	interval               float32
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r SandboxAPISetAutostopIntervalRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) SandboxAPISetAutostopIntervalRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r SandboxAPISetAutostopIntervalRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetAutostopIntervalExecute(r)
}

/*
SetAutostopInterval Set sandbox auto-stop interval

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId ID of the sandbox
	@param interval Auto-stop interval in minutes (0 to disable)
	@return SandboxAPISetAutostopIntervalRequest
*/
func (a *SandboxAPIService) SetAutostopInterval(ctx context.Context, sandboxId string, interval float32) SandboxAPISetAutostopIntervalRequest {
	return SandboxAPISetAutostopIntervalRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
		interval:   interval,
	}
}

// Execute executes the request
func (a *SandboxAPIService) SetAutostopIntervalExecute(r SandboxAPISetAutostopIntervalRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxAPIService.SetAutostopInterval")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sandbox/{sandboxId}/autostop/{interval}"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interval"+"}", url.PathEscape(parameterValueToString(r.interval, "interval")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SandboxAPIStartSandboxRequest struct {
	ctx                    context.Context
	ApiService             SandboxAPI
	sandboxId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r SandboxAPIStartSandboxRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) SandboxAPIStartSandboxRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r SandboxAPIStartSandboxRequest) Execute() (*Sandbox, *http.Response, error) {
	return r.ApiService.StartSandboxExecute(r)
}

/*
StartSandbox Start sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId ID of the sandbox
	@return SandboxAPIStartSandboxRequest
*/
func (a *SandboxAPIService) StartSandbox(ctx context.Context, sandboxId string) SandboxAPIStartSandboxRequest {
	return SandboxAPIStartSandboxRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return Sandbox
func (a *SandboxAPIService) StartSandboxExecute(r SandboxAPIStartSandboxRequest) (*Sandbox, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Sandbox
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxAPIService.StartSandbox")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sandbox/{sandboxId}/start"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SandboxAPIStopSandboxRequest struct {
	ctx                    context.Context
	ApiService             SandboxAPI
	sandboxId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r SandboxAPIStopSandboxRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) SandboxAPIStopSandboxRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r SandboxAPIStopSandboxRequest) Execute() (*http.Response, error) {
	return r.ApiService.StopSandboxExecute(r)
}

/*
StopSandbox Stop sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId ID of the sandbox
	@return SandboxAPIStopSandboxRequest
*/
func (a *SandboxAPIService) StopSandbox(ctx context.Context, sandboxId string) SandboxAPIStopSandboxRequest {
	return SandboxAPIStopSandboxRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *SandboxAPIService) StopSandboxExecute(r SandboxAPIStopSandboxRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxAPIService.StopSandbox")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sandbox/{sandboxId}/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SandboxAPIUpdatePublicStatusRequest struct {
	ctx                    context.Context
	ApiService             SandboxAPI
	sandboxId              string
	isPublic               bool
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r SandboxAPIUpdatePublicStatusRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) SandboxAPIUpdatePublicStatusRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r SandboxAPIUpdatePublicStatusRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdatePublicStatusExecute(r)
}

/*
UpdatePublicStatus Update public status

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId ID of the sandbox
	@param isPublic Public status to set
	@return SandboxAPIUpdatePublicStatusRequest
*/
func (a *SandboxAPIService) UpdatePublicStatus(ctx context.Context, sandboxId string, isPublic bool) SandboxAPIUpdatePublicStatusRequest {
	return SandboxAPIUpdatePublicStatusRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
		isPublic:   isPublic,
	}
}

// Execute executes the request
func (a *SandboxAPIService) UpdatePublicStatusExecute(r SandboxAPIUpdatePublicStatusRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxAPIService.UpdatePublicStatus")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sandbox/{sandboxId}/public/{isPublic}"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"isPublic"+"}", url.PathEscape(parameterValueToString(r.isPublic, "isPublic")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
