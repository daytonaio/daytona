/*
Daytona

Daytona AI platform API Docs

API version: 1.0
Contact: support@daytona.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apiclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


type ToolboxAPI interface {

	/*
	ClickMouseDeprecated [DEPRECATED] Click mouse

	Click mouse at specified coordinates

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIClickMouseDeprecatedRequest

	Deprecated
	*/
	ClickMouseDeprecated(ctx context.Context, sandboxId string) ToolboxAPIClickMouseDeprecatedRequest

	// ClickMouseDeprecatedExecute executes the request
	//  @return MouseClickResponse
	// Deprecated
	ClickMouseDeprecatedExecute(r ToolboxAPIClickMouseDeprecatedRequest) (*MouseClickResponse, *http.Response, error)

	/*
	CreateFolderDeprecated [DEPRECATED] Create folder

	Create folder inside sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPICreateFolderDeprecatedRequest

	Deprecated
	*/
	CreateFolderDeprecated(ctx context.Context, sandboxId string) ToolboxAPICreateFolderDeprecatedRequest

	// CreateFolderDeprecatedExecute executes the request
	// Deprecated
	CreateFolderDeprecatedExecute(r ToolboxAPICreateFolderDeprecatedRequest) (*http.Response, error)

	/*
	CreatePTYSessionDeprecated [DEPRECATED] Create PTY session

	Create a new PTY session in the sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPICreatePTYSessionDeprecatedRequest

	Deprecated
	*/
	CreatePTYSessionDeprecated(ctx context.Context, sandboxId string) ToolboxAPICreatePTYSessionDeprecatedRequest

	// CreatePTYSessionDeprecatedExecute executes the request
	//  @return PtyCreateResponse
	// Deprecated
	CreatePTYSessionDeprecatedExecute(r ToolboxAPICreatePTYSessionDeprecatedRequest) (*PtyCreateResponse, *http.Response, error)

	/*
	CreateSessionDeprecated [DEPRECATED] Create session

	Create a new session in the sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPICreateSessionDeprecatedRequest

	Deprecated
	*/
	CreateSessionDeprecated(ctx context.Context, sandboxId string) ToolboxAPICreateSessionDeprecatedRequest

	// CreateSessionDeprecatedExecute executes the request
	// Deprecated
	CreateSessionDeprecatedExecute(r ToolboxAPICreateSessionDeprecatedRequest) (*http.Response, error)

	/*
	DeleteFileDeprecated [DEPRECATED] Delete file

	Delete file inside sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIDeleteFileDeprecatedRequest

	Deprecated
	*/
	DeleteFileDeprecated(ctx context.Context, sandboxId string) ToolboxAPIDeleteFileDeprecatedRequest

	// DeleteFileDeprecatedExecute executes the request
	// Deprecated
	DeleteFileDeprecatedExecute(r ToolboxAPIDeleteFileDeprecatedRequest) (*http.Response, error)

	/*
	DeletePTYSessionDeprecated [DEPRECATED] Delete PTY session

	Delete a PTY session and terminate the associated process

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@param sessionId
	@return ToolboxAPIDeletePTYSessionDeprecatedRequest

	Deprecated
	*/
	DeletePTYSessionDeprecated(ctx context.Context, sandboxId string, sessionId string) ToolboxAPIDeletePTYSessionDeprecatedRequest

	// DeletePTYSessionDeprecatedExecute executes the request
	// Deprecated
	DeletePTYSessionDeprecatedExecute(r ToolboxAPIDeletePTYSessionDeprecatedRequest) (*http.Response, error)

	/*
	DeleteSessionDeprecated [DEPRECATED] Delete session

	Delete a specific session

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@param sessionId
	@return ToolboxAPIDeleteSessionDeprecatedRequest

	Deprecated
	*/
	DeleteSessionDeprecated(ctx context.Context, sandboxId string, sessionId string) ToolboxAPIDeleteSessionDeprecatedRequest

	// DeleteSessionDeprecatedExecute executes the request
	// Deprecated
	DeleteSessionDeprecatedExecute(r ToolboxAPIDeleteSessionDeprecatedRequest) (*http.Response, error)

	/*
	DownloadFileDeprecated [DEPRECATED] Download file

	Download file from sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIDownloadFileDeprecatedRequest

	Deprecated
	*/
	DownloadFileDeprecated(ctx context.Context, sandboxId string) ToolboxAPIDownloadFileDeprecatedRequest

	// DownloadFileDeprecatedExecute executes the request
	//  @return *os.File
	// Deprecated
	DownloadFileDeprecatedExecute(r ToolboxAPIDownloadFileDeprecatedRequest) (*os.File, *http.Response, error)

	/*
	DownloadFilesDeprecated [DEPRECATED] Download multiple files

	Streams back a multipart/form-data bundle of the requested paths

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIDownloadFilesDeprecatedRequest

	Deprecated
	*/
	DownloadFilesDeprecated(ctx context.Context, sandboxId string) ToolboxAPIDownloadFilesDeprecatedRequest

	// DownloadFilesDeprecatedExecute executes the request
	//  @return *os.File
	// Deprecated
	DownloadFilesDeprecatedExecute(r ToolboxAPIDownloadFilesDeprecatedRequest) (*os.File, *http.Response, error)

	/*
	DragMouseDeprecated [DEPRECATED] Drag mouse

	Drag mouse from start to end coordinates

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIDragMouseDeprecatedRequest

	Deprecated
	*/
	DragMouseDeprecated(ctx context.Context, sandboxId string) ToolboxAPIDragMouseDeprecatedRequest

	// DragMouseDeprecatedExecute executes the request
	//  @return MouseDragResponse
	// Deprecated
	DragMouseDeprecatedExecute(r ToolboxAPIDragMouseDeprecatedRequest) (*MouseDragResponse, *http.Response, error)

	/*
	ExecuteCommandDeprecated [DEPRECATED] Execute command

	Execute command synchronously inside sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIExecuteCommandDeprecatedRequest

	Deprecated
	*/
	ExecuteCommandDeprecated(ctx context.Context, sandboxId string) ToolboxAPIExecuteCommandDeprecatedRequest

	// ExecuteCommandDeprecatedExecute executes the request
	//  @return ExecuteResponse
	// Deprecated
	ExecuteCommandDeprecatedExecute(r ToolboxAPIExecuteCommandDeprecatedRequest) (*ExecuteResponse, *http.Response, error)

	/*
	ExecuteSessionCommandDeprecated [DEPRECATED] Execute command in session

	Execute a command in a specific session

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@param sessionId
	@return ToolboxAPIExecuteSessionCommandDeprecatedRequest

	Deprecated
	*/
	ExecuteSessionCommandDeprecated(ctx context.Context, sandboxId string, sessionId string) ToolboxAPIExecuteSessionCommandDeprecatedRequest

	// ExecuteSessionCommandDeprecatedExecute executes the request
	//  @return SessionExecuteResponse
	// Deprecated
	ExecuteSessionCommandDeprecatedExecute(r ToolboxAPIExecuteSessionCommandDeprecatedRequest) (*SessionExecuteResponse, *http.Response, error)

	/*
	FindInFilesDeprecated [DEPRECATED] Search for text/pattern in files

	Search for text/pattern inside sandbox files

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIFindInFilesDeprecatedRequest

	Deprecated
	*/
	FindInFilesDeprecated(ctx context.Context, sandboxId string) ToolboxAPIFindInFilesDeprecatedRequest

	// FindInFilesDeprecatedExecute executes the request
	//  @return []Match
	// Deprecated
	FindInFilesDeprecatedExecute(r ToolboxAPIFindInFilesDeprecatedRequest) ([]Match, *http.Response, error)

	/*
	GetComputerUseStatusDeprecated [DEPRECATED] Get computer use status

	Get status of all VNC desktop processes

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGetComputerUseStatusDeprecatedRequest

	Deprecated
	*/
	GetComputerUseStatusDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGetComputerUseStatusDeprecatedRequest

	// GetComputerUseStatusDeprecatedExecute executes the request
	//  @return ComputerUseStatusResponse
	// Deprecated
	GetComputerUseStatusDeprecatedExecute(r ToolboxAPIGetComputerUseStatusDeprecatedRequest) (*ComputerUseStatusResponse, *http.Response, error)

	/*
	GetDisplayInfoDeprecated [DEPRECATED] Get display info

	Get information about displays

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGetDisplayInfoDeprecatedRequest

	Deprecated
	*/
	GetDisplayInfoDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGetDisplayInfoDeprecatedRequest

	// GetDisplayInfoDeprecatedExecute executes the request
	//  @return DisplayInfoResponse
	// Deprecated
	GetDisplayInfoDeprecatedExecute(r ToolboxAPIGetDisplayInfoDeprecatedRequest) (*DisplayInfoResponse, *http.Response, error)

	/*
	GetFileInfoDeprecated [DEPRECATED] Get file info

	Get file info inside sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGetFileInfoDeprecatedRequest

	Deprecated
	*/
	GetFileInfoDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGetFileInfoDeprecatedRequest

	// GetFileInfoDeprecatedExecute executes the request
	//  @return FileInfo
	// Deprecated
	GetFileInfoDeprecatedExecute(r ToolboxAPIGetFileInfoDeprecatedRequest) (*FileInfo, *http.Response, error)

	/*
	GetMousePositionDeprecated [DEPRECATED] Get mouse position

	Get current mouse cursor position

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGetMousePositionDeprecatedRequest

	Deprecated
	*/
	GetMousePositionDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGetMousePositionDeprecatedRequest

	// GetMousePositionDeprecatedExecute executes the request
	//  @return MousePosition
	// Deprecated
	GetMousePositionDeprecatedExecute(r ToolboxAPIGetMousePositionDeprecatedRequest) (*MousePosition, *http.Response, error)

	/*
	GetPTYSessionDeprecated [DEPRECATED] Get PTY session

	Get PTY session information by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@param sessionId
	@return ToolboxAPIGetPTYSessionDeprecatedRequest

	Deprecated
	*/
	GetPTYSessionDeprecated(ctx context.Context, sandboxId string, sessionId string) ToolboxAPIGetPTYSessionDeprecatedRequest

	// GetPTYSessionDeprecatedExecute executes the request
	//  @return PtySessionInfo
	// Deprecated
	GetPTYSessionDeprecatedExecute(r ToolboxAPIGetPTYSessionDeprecatedRequest) (*PtySessionInfo, *http.Response, error)

	/*
	GetProcessErrorsDeprecated [DEPRECATED] Get process errors

	Get error logs for a specific VNC process

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param processName
	@param sandboxId
	@return ToolboxAPIGetProcessErrorsDeprecatedRequest

	Deprecated
	*/
	GetProcessErrorsDeprecated(ctx context.Context, processName string, sandboxId string) ToolboxAPIGetProcessErrorsDeprecatedRequest

	// GetProcessErrorsDeprecatedExecute executes the request
	//  @return ProcessErrorsResponse
	// Deprecated
	GetProcessErrorsDeprecatedExecute(r ToolboxAPIGetProcessErrorsDeprecatedRequest) (*ProcessErrorsResponse, *http.Response, error)

	/*
	GetProcessLogsDeprecated [DEPRECATED] Get process logs

	Get logs for a specific VNC process

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param processName
	@param sandboxId
	@return ToolboxAPIGetProcessLogsDeprecatedRequest

	Deprecated
	*/
	GetProcessLogsDeprecated(ctx context.Context, processName string, sandboxId string) ToolboxAPIGetProcessLogsDeprecatedRequest

	// GetProcessLogsDeprecatedExecute executes the request
	//  @return ProcessLogsResponse
	// Deprecated
	GetProcessLogsDeprecatedExecute(r ToolboxAPIGetProcessLogsDeprecatedRequest) (*ProcessLogsResponse, *http.Response, error)

	/*
	GetProcessStatusDeprecated [DEPRECATED] Get process status

	Get status of a specific VNC process

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param processName
	@param sandboxId
	@return ToolboxAPIGetProcessStatusDeprecatedRequest

	Deprecated
	*/
	GetProcessStatusDeprecated(ctx context.Context, processName string, sandboxId string) ToolboxAPIGetProcessStatusDeprecatedRequest

	// GetProcessStatusDeprecatedExecute executes the request
	//  @return ProcessStatusResponse
	// Deprecated
	GetProcessStatusDeprecatedExecute(r ToolboxAPIGetProcessStatusDeprecatedRequest) (*ProcessStatusResponse, *http.Response, error)

	/*
	GetProjectDirDeprecated [DEPRECATED] Get sandbox project dir

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGetProjectDirDeprecatedRequest

	Deprecated
	*/
	GetProjectDirDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGetProjectDirDeprecatedRequest

	// GetProjectDirDeprecatedExecute executes the request
	//  @return ProjectDirResponse
	// Deprecated
	GetProjectDirDeprecatedExecute(r ToolboxAPIGetProjectDirDeprecatedRequest) (*ProjectDirResponse, *http.Response, error)

	/*
	GetSessionCommandDeprecated [DEPRECATED] Get session command

	Get session command by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@param sessionId
	@param commandId
	@return ToolboxAPIGetSessionCommandDeprecatedRequest

	Deprecated
	*/
	GetSessionCommandDeprecated(ctx context.Context, sandboxId string, sessionId string, commandId string) ToolboxAPIGetSessionCommandDeprecatedRequest

	// GetSessionCommandDeprecatedExecute executes the request
	//  @return Command
	// Deprecated
	GetSessionCommandDeprecatedExecute(r ToolboxAPIGetSessionCommandDeprecatedRequest) (*Command, *http.Response, error)

	/*
	GetSessionCommandLogsDeprecated [DEPRECATED] Get command logs

	Get logs for a specific command in a session

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@param sessionId
	@param commandId
	@return ToolboxAPIGetSessionCommandLogsDeprecatedRequest

	Deprecated
	*/
	GetSessionCommandLogsDeprecated(ctx context.Context, sandboxId string, sessionId string, commandId string) ToolboxAPIGetSessionCommandLogsDeprecatedRequest

	// GetSessionCommandLogsDeprecatedExecute executes the request
	//  @return string
	// Deprecated
	GetSessionCommandLogsDeprecatedExecute(r ToolboxAPIGetSessionCommandLogsDeprecatedRequest) (string, *http.Response, error)

	/*
	GetSessionDeprecated [DEPRECATED] Get session

	Get session by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@param sessionId
	@return ToolboxAPIGetSessionDeprecatedRequest

	Deprecated
	*/
	GetSessionDeprecated(ctx context.Context, sandboxId string, sessionId string) ToolboxAPIGetSessionDeprecatedRequest

	// GetSessionDeprecatedExecute executes the request
	//  @return Session
	// Deprecated
	GetSessionDeprecatedExecute(r ToolboxAPIGetSessionDeprecatedRequest) (*Session, *http.Response, error)

	/*
	GetUserHomeDirDeprecated [DEPRECATED] Get sandbox user home dir

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGetUserHomeDirDeprecatedRequest

	Deprecated
	*/
	GetUserHomeDirDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGetUserHomeDirDeprecatedRequest

	// GetUserHomeDirDeprecatedExecute executes the request
	//  @return UserHomeDirResponse
	// Deprecated
	GetUserHomeDirDeprecatedExecute(r ToolboxAPIGetUserHomeDirDeprecatedRequest) (*UserHomeDirResponse, *http.Response, error)

	/*
	GetWindowsDeprecated [DEPRECATED] Get windows

	Get list of open windows

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGetWindowsDeprecatedRequest

	Deprecated
	*/
	GetWindowsDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGetWindowsDeprecatedRequest

	// GetWindowsDeprecatedExecute executes the request
	//  @return WindowsResponse
	// Deprecated
	GetWindowsDeprecatedExecute(r ToolboxAPIGetWindowsDeprecatedRequest) (*WindowsResponse, *http.Response, error)

	/*
	GetWorkDirDeprecated [DEPRECATED] Get sandbox work-dir

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGetWorkDirDeprecatedRequest

	Deprecated
	*/
	GetWorkDirDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGetWorkDirDeprecatedRequest

	// GetWorkDirDeprecatedExecute executes the request
	//  @return WorkDirResponse
	// Deprecated
	GetWorkDirDeprecatedExecute(r ToolboxAPIGetWorkDirDeprecatedRequest) (*WorkDirResponse, *http.Response, error)

	/*
	GitAddFilesDeprecated [DEPRECATED] Add files

	Add files to git commit

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGitAddFilesDeprecatedRequest

	Deprecated
	*/
	GitAddFilesDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGitAddFilesDeprecatedRequest

	// GitAddFilesDeprecatedExecute executes the request
	// Deprecated
	GitAddFilesDeprecatedExecute(r ToolboxAPIGitAddFilesDeprecatedRequest) (*http.Response, error)

	/*
	GitCheckoutBranchDeprecated [DEPRECATED] Checkout branch

	Checkout branch or commit in git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGitCheckoutBranchDeprecatedRequest

	Deprecated
	*/
	GitCheckoutBranchDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGitCheckoutBranchDeprecatedRequest

	// GitCheckoutBranchDeprecatedExecute executes the request
	// Deprecated
	GitCheckoutBranchDeprecatedExecute(r ToolboxAPIGitCheckoutBranchDeprecatedRequest) (*http.Response, error)

	/*
	GitCloneRepositoryDeprecated [DEPRECATED] Clone repository

	Clone git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGitCloneRepositoryDeprecatedRequest

	Deprecated
	*/
	GitCloneRepositoryDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGitCloneRepositoryDeprecatedRequest

	// GitCloneRepositoryDeprecatedExecute executes the request
	// Deprecated
	GitCloneRepositoryDeprecatedExecute(r ToolboxAPIGitCloneRepositoryDeprecatedRequest) (*http.Response, error)

	/*
	GitCommitChangesDeprecated [DEPRECATED] Commit changes

	Commit changes to git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGitCommitChangesDeprecatedRequest

	Deprecated
	*/
	GitCommitChangesDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGitCommitChangesDeprecatedRequest

	// GitCommitChangesDeprecatedExecute executes the request
	//  @return GitCommitResponse
	// Deprecated
	GitCommitChangesDeprecatedExecute(r ToolboxAPIGitCommitChangesDeprecatedRequest) (*GitCommitResponse, *http.Response, error)

	/*
	GitCreateBranchDeprecated [DEPRECATED] Create branch

	Create branch on git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGitCreateBranchDeprecatedRequest

	Deprecated
	*/
	GitCreateBranchDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGitCreateBranchDeprecatedRequest

	// GitCreateBranchDeprecatedExecute executes the request
	// Deprecated
	GitCreateBranchDeprecatedExecute(r ToolboxAPIGitCreateBranchDeprecatedRequest) (*http.Response, error)

	/*
	GitDeleteBranchDeprecated [DEPRECATED] Delete branch

	Delete branch on git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGitDeleteBranchDeprecatedRequest

	Deprecated
	*/
	GitDeleteBranchDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGitDeleteBranchDeprecatedRequest

	// GitDeleteBranchDeprecatedExecute executes the request
	// Deprecated
	GitDeleteBranchDeprecatedExecute(r ToolboxAPIGitDeleteBranchDeprecatedRequest) (*http.Response, error)

	/*
	GitGetHistoryDeprecated [DEPRECATED] Get commit history

	Get commit history from git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGitGetHistoryDeprecatedRequest

	Deprecated
	*/
	GitGetHistoryDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGitGetHistoryDeprecatedRequest

	// GitGetHistoryDeprecatedExecute executes the request
	//  @return []GitCommitInfo
	// Deprecated
	GitGetHistoryDeprecatedExecute(r ToolboxAPIGitGetHistoryDeprecatedRequest) ([]GitCommitInfo, *http.Response, error)

	/*
	GitGetStatusDeprecated [DEPRECATED] Get git status

	Get status from git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGitGetStatusDeprecatedRequest

	Deprecated
	*/
	GitGetStatusDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGitGetStatusDeprecatedRequest

	// GitGetStatusDeprecatedExecute executes the request
	//  @return GitStatus
	// Deprecated
	GitGetStatusDeprecatedExecute(r ToolboxAPIGitGetStatusDeprecatedRequest) (*GitStatus, *http.Response, error)

	/*
	GitListBranchesDeprecated [DEPRECATED] Get branch list

	Get branch list from git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGitListBranchesDeprecatedRequest

	Deprecated
	*/
	GitListBranchesDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGitListBranchesDeprecatedRequest

	// GitListBranchesDeprecatedExecute executes the request
	//  @return ListBranchResponse
	// Deprecated
	GitListBranchesDeprecatedExecute(r ToolboxAPIGitListBranchesDeprecatedRequest) (*ListBranchResponse, *http.Response, error)

	/*
	GitPullChangesDeprecated [DEPRECATED] Pull changes

	Pull changes from remote

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGitPullChangesDeprecatedRequest

	Deprecated
	*/
	GitPullChangesDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGitPullChangesDeprecatedRequest

	// GitPullChangesDeprecatedExecute executes the request
	// Deprecated
	GitPullChangesDeprecatedExecute(r ToolboxAPIGitPullChangesDeprecatedRequest) (*http.Response, error)

	/*
	GitPushChangesDeprecated [DEPRECATED] Push changes

	Push changes to remote

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGitPushChangesDeprecatedRequest

	Deprecated
	*/
	GitPushChangesDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGitPushChangesDeprecatedRequest

	// GitPushChangesDeprecatedExecute executes the request
	// Deprecated
	GitPushChangesDeprecatedExecute(r ToolboxAPIGitPushChangesDeprecatedRequest) (*http.Response, error)

	/*
	ListFilesDeprecated [DEPRECATED] List files

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIListFilesDeprecatedRequest

	Deprecated
	*/
	ListFilesDeprecated(ctx context.Context, sandboxId string) ToolboxAPIListFilesDeprecatedRequest

	// ListFilesDeprecatedExecute executes the request
	//  @return []FileInfo
	// Deprecated
	ListFilesDeprecatedExecute(r ToolboxAPIListFilesDeprecatedRequest) ([]FileInfo, *http.Response, error)

	/*
	ListPTYSessionsDeprecated [DEPRECATED] List PTY sessions

	List all active PTY sessions in the sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIListPTYSessionsDeprecatedRequest

	Deprecated
	*/
	ListPTYSessionsDeprecated(ctx context.Context, sandboxId string) ToolboxAPIListPTYSessionsDeprecatedRequest

	// ListPTYSessionsDeprecatedExecute executes the request
	//  @return PtyListResponse
	// Deprecated
	ListPTYSessionsDeprecatedExecute(r ToolboxAPIListPTYSessionsDeprecatedRequest) (*PtyListResponse, *http.Response, error)

	/*
	ListSessionsDeprecated [DEPRECATED] List sessions

	List all active sessions in the sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIListSessionsDeprecatedRequest

	Deprecated
	*/
	ListSessionsDeprecated(ctx context.Context, sandboxId string) ToolboxAPIListSessionsDeprecatedRequest

	// ListSessionsDeprecatedExecute executes the request
	//  @return []Session
	// Deprecated
	ListSessionsDeprecatedExecute(r ToolboxAPIListSessionsDeprecatedRequest) ([]Session, *http.Response, error)

	/*
	LspCompletionsDeprecated [DEPRECATED] Get Lsp Completions

	The Completion request is sent from the client to the server to compute completion items at a given cursor position.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPILspCompletionsDeprecatedRequest

	Deprecated
	*/
	LspCompletionsDeprecated(ctx context.Context, sandboxId string) ToolboxAPILspCompletionsDeprecatedRequest

	// LspCompletionsDeprecatedExecute executes the request
	//  @return CompletionList
	// Deprecated
	LspCompletionsDeprecatedExecute(r ToolboxAPILspCompletionsDeprecatedRequest) (*CompletionList, *http.Response, error)

	/*
	LspDidCloseDeprecated [DEPRECATED] Call Lsp DidClose

	The document close notification is sent from the client to the server when the document got closed in the client.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPILspDidCloseDeprecatedRequest

	Deprecated
	*/
	LspDidCloseDeprecated(ctx context.Context, sandboxId string) ToolboxAPILspDidCloseDeprecatedRequest

	// LspDidCloseDeprecatedExecute executes the request
	// Deprecated
	LspDidCloseDeprecatedExecute(r ToolboxAPILspDidCloseDeprecatedRequest) (*http.Response, error)

	/*
	LspDidOpenDeprecated [DEPRECATED] Call Lsp DidOpen

	The document open notification is sent from the client to the server to signal newly opened text documents.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPILspDidOpenDeprecatedRequest

	Deprecated
	*/
	LspDidOpenDeprecated(ctx context.Context, sandboxId string) ToolboxAPILspDidOpenDeprecatedRequest

	// LspDidOpenDeprecatedExecute executes the request
	// Deprecated
	LspDidOpenDeprecatedExecute(r ToolboxAPILspDidOpenDeprecatedRequest) (*http.Response, error)

	/*
	LspDocumentSymbolsDeprecated [DEPRECATED] Call Lsp DocumentSymbols

	The document symbol request is sent from the client to the server.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPILspDocumentSymbolsDeprecatedRequest

	Deprecated
	*/
	LspDocumentSymbolsDeprecated(ctx context.Context, sandboxId string) ToolboxAPILspDocumentSymbolsDeprecatedRequest

	// LspDocumentSymbolsDeprecatedExecute executes the request
	//  @return []LspSymbol
	// Deprecated
	LspDocumentSymbolsDeprecatedExecute(r ToolboxAPILspDocumentSymbolsDeprecatedRequest) ([]LspSymbol, *http.Response, error)

	/*
	LspStartDeprecated [DEPRECATED] Start Lsp server

	Start Lsp server process inside sandbox project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPILspStartDeprecatedRequest

	Deprecated
	*/
	LspStartDeprecated(ctx context.Context, sandboxId string) ToolboxAPILspStartDeprecatedRequest

	// LspStartDeprecatedExecute executes the request
	// Deprecated
	LspStartDeprecatedExecute(r ToolboxAPILspStartDeprecatedRequest) (*http.Response, error)

	/*
	LspStopDeprecated [DEPRECATED] Stop Lsp server

	Stop Lsp server process inside sandbox project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPILspStopDeprecatedRequest

	Deprecated
	*/
	LspStopDeprecated(ctx context.Context, sandboxId string) ToolboxAPILspStopDeprecatedRequest

	// LspStopDeprecatedExecute executes the request
	// Deprecated
	LspStopDeprecatedExecute(r ToolboxAPILspStopDeprecatedRequest) (*http.Response, error)

	/*
	LspWorkspaceSymbolsDeprecated [DEPRECATED] Call Lsp WorkspaceSymbols

	The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPILspWorkspaceSymbolsDeprecatedRequest

	Deprecated
	*/
	LspWorkspaceSymbolsDeprecated(ctx context.Context, sandboxId string) ToolboxAPILspWorkspaceSymbolsDeprecatedRequest

	// LspWorkspaceSymbolsDeprecatedExecute executes the request
	//  @return []LspSymbol
	// Deprecated
	LspWorkspaceSymbolsDeprecatedExecute(r ToolboxAPILspWorkspaceSymbolsDeprecatedRequest) ([]LspSymbol, *http.Response, error)

	/*
	MoveFileDeprecated [DEPRECATED] Move file

	Move file inside sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIMoveFileDeprecatedRequest

	Deprecated
	*/
	MoveFileDeprecated(ctx context.Context, sandboxId string) ToolboxAPIMoveFileDeprecatedRequest

	// MoveFileDeprecatedExecute executes the request
	// Deprecated
	MoveFileDeprecatedExecute(r ToolboxAPIMoveFileDeprecatedRequest) (*http.Response, error)

	/*
	MoveMouseDeprecated [DEPRECATED] Move mouse

	Move mouse cursor to specified coordinates

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIMoveMouseDeprecatedRequest

	Deprecated
	*/
	MoveMouseDeprecated(ctx context.Context, sandboxId string) ToolboxAPIMoveMouseDeprecatedRequest

	// MoveMouseDeprecatedExecute executes the request
	//  @return MouseMoveResponse
	// Deprecated
	MoveMouseDeprecatedExecute(r ToolboxAPIMoveMouseDeprecatedRequest) (*MouseMoveResponse, *http.Response, error)

	/*
	PressHotkeyDeprecated [DEPRECATED] Press hotkey

	Press a hotkey combination

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIPressHotkeyDeprecatedRequest

	Deprecated
	*/
	PressHotkeyDeprecated(ctx context.Context, sandboxId string) ToolboxAPIPressHotkeyDeprecatedRequest

	// PressHotkeyDeprecatedExecute executes the request
	// Deprecated
	PressHotkeyDeprecatedExecute(r ToolboxAPIPressHotkeyDeprecatedRequest) (*http.Response, error)

	/*
	PressKeyDeprecated [DEPRECATED] Press key

	Press a key with optional modifiers

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIPressKeyDeprecatedRequest

	Deprecated
	*/
	PressKeyDeprecated(ctx context.Context, sandboxId string) ToolboxAPIPressKeyDeprecatedRequest

	// PressKeyDeprecatedExecute executes the request
	// Deprecated
	PressKeyDeprecatedExecute(r ToolboxAPIPressKeyDeprecatedRequest) (*http.Response, error)

	/*
	ReplaceInFilesDeprecated [DEPRECATED] Replace in files

	Replace text/pattern in multiple files inside sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIReplaceInFilesDeprecatedRequest

	Deprecated
	*/
	ReplaceInFilesDeprecated(ctx context.Context, sandboxId string) ToolboxAPIReplaceInFilesDeprecatedRequest

	// ReplaceInFilesDeprecatedExecute executes the request
	//  @return []ReplaceResult
	// Deprecated
	ReplaceInFilesDeprecatedExecute(r ToolboxAPIReplaceInFilesDeprecatedRequest) ([]ReplaceResult, *http.Response, error)

	/*
	ResizePTYSessionDeprecated [DEPRECATED] Resize PTY session

	Resize a PTY session

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@param sessionId
	@return ToolboxAPIResizePTYSessionDeprecatedRequest

	Deprecated
	*/
	ResizePTYSessionDeprecated(ctx context.Context, sandboxId string, sessionId string) ToolboxAPIResizePTYSessionDeprecatedRequest

	// ResizePTYSessionDeprecatedExecute executes the request
	//  @return PtySessionInfo
	// Deprecated
	ResizePTYSessionDeprecatedExecute(r ToolboxAPIResizePTYSessionDeprecatedRequest) (*PtySessionInfo, *http.Response, error)

	/*
	RestartProcessDeprecated [DEPRECATED] Restart process

	Restart a specific VNC process

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param processName
	@param sandboxId
	@return ToolboxAPIRestartProcessDeprecatedRequest

	Deprecated
	*/
	RestartProcessDeprecated(ctx context.Context, processName string, sandboxId string) ToolboxAPIRestartProcessDeprecatedRequest

	// RestartProcessDeprecatedExecute executes the request
	//  @return ProcessRestartResponse
	// Deprecated
	RestartProcessDeprecatedExecute(r ToolboxAPIRestartProcessDeprecatedRequest) (*ProcessRestartResponse, *http.Response, error)

	/*
	ScrollMouseDeprecated [DEPRECATED] Scroll mouse

	Scroll mouse at specified coordinates

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIScrollMouseDeprecatedRequest

	Deprecated
	*/
	ScrollMouseDeprecated(ctx context.Context, sandboxId string) ToolboxAPIScrollMouseDeprecatedRequest

	// ScrollMouseDeprecatedExecute executes the request
	//  @return MouseScrollResponse
	// Deprecated
	ScrollMouseDeprecatedExecute(r ToolboxAPIScrollMouseDeprecatedRequest) (*MouseScrollResponse, *http.Response, error)

	/*
	SearchFilesDeprecated [DEPRECATED] Search files

	Search for files inside sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPISearchFilesDeprecatedRequest

	Deprecated
	*/
	SearchFilesDeprecated(ctx context.Context, sandboxId string) ToolboxAPISearchFilesDeprecatedRequest

	// SearchFilesDeprecatedExecute executes the request
	//  @return SearchFilesResponse
	// Deprecated
	SearchFilesDeprecatedExecute(r ToolboxAPISearchFilesDeprecatedRequest) (*SearchFilesResponse, *http.Response, error)

	/*
	SetFilePermissionsDeprecated [DEPRECATED] Set file permissions

	Set file owner/group/permissions inside sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPISetFilePermissionsDeprecatedRequest

	Deprecated
	*/
	SetFilePermissionsDeprecated(ctx context.Context, sandboxId string) ToolboxAPISetFilePermissionsDeprecatedRequest

	// SetFilePermissionsDeprecatedExecute executes the request
	// Deprecated
	SetFilePermissionsDeprecatedExecute(r ToolboxAPISetFilePermissionsDeprecatedRequest) (*http.Response, error)

	/*
	StartComputerUseDeprecated [DEPRECATED] Start computer use processes

	Start all VNC desktop processes (Xvfb, xfce4, x11vnc, novnc)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIStartComputerUseDeprecatedRequest

	Deprecated
	*/
	StartComputerUseDeprecated(ctx context.Context, sandboxId string) ToolboxAPIStartComputerUseDeprecatedRequest

	// StartComputerUseDeprecatedExecute executes the request
	//  @return ComputerUseStartResponse
	// Deprecated
	StartComputerUseDeprecatedExecute(r ToolboxAPIStartComputerUseDeprecatedRequest) (*ComputerUseStartResponse, *http.Response, error)

	/*
	StopComputerUseDeprecated [DEPRECATED] Stop computer use processes

	Stop all VNC desktop processes (Xvfb, xfce4, x11vnc, novnc)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIStopComputerUseDeprecatedRequest

	Deprecated
	*/
	StopComputerUseDeprecated(ctx context.Context, sandboxId string) ToolboxAPIStopComputerUseDeprecatedRequest

	// StopComputerUseDeprecatedExecute executes the request
	//  @return ComputerUseStopResponse
	// Deprecated
	StopComputerUseDeprecatedExecute(r ToolboxAPIStopComputerUseDeprecatedRequest) (*ComputerUseStopResponse, *http.Response, error)

	/*
	TakeCompressedRegionScreenshotDeprecated [DEPRECATED] Take compressed region screenshot

	Take a compressed screenshot of a specific region

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest

	Deprecated
	*/
	TakeCompressedRegionScreenshotDeprecated(ctx context.Context, sandboxId string) ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest

	// TakeCompressedRegionScreenshotDeprecatedExecute executes the request
	//  @return CompressedScreenshotResponse
	// Deprecated
	TakeCompressedRegionScreenshotDeprecatedExecute(r ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest) (*CompressedScreenshotResponse, *http.Response, error)

	/*
	TakeCompressedScreenshotDeprecated [DEPRECATED] Take compressed screenshot

	Take a compressed screenshot with format, quality, and scale options

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPITakeCompressedScreenshotDeprecatedRequest

	Deprecated
	*/
	TakeCompressedScreenshotDeprecated(ctx context.Context, sandboxId string) ToolboxAPITakeCompressedScreenshotDeprecatedRequest

	// TakeCompressedScreenshotDeprecatedExecute executes the request
	//  @return CompressedScreenshotResponse
	// Deprecated
	TakeCompressedScreenshotDeprecatedExecute(r ToolboxAPITakeCompressedScreenshotDeprecatedRequest) (*CompressedScreenshotResponse, *http.Response, error)

	/*
	TakeRegionScreenshotDeprecated [DEPRECATED] Take region screenshot

	Take a screenshot of a specific region

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPITakeRegionScreenshotDeprecatedRequest

	Deprecated
	*/
	TakeRegionScreenshotDeprecated(ctx context.Context, sandboxId string) ToolboxAPITakeRegionScreenshotDeprecatedRequest

	// TakeRegionScreenshotDeprecatedExecute executes the request
	//  @return RegionScreenshotResponse
	// Deprecated
	TakeRegionScreenshotDeprecatedExecute(r ToolboxAPITakeRegionScreenshotDeprecatedRequest) (*RegionScreenshotResponse, *http.Response, error)

	/*
	TakeScreenshotDeprecated [DEPRECATED] Take screenshot

	Take a screenshot of the entire screen

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPITakeScreenshotDeprecatedRequest

	Deprecated
	*/
	TakeScreenshotDeprecated(ctx context.Context, sandboxId string) ToolboxAPITakeScreenshotDeprecatedRequest

	// TakeScreenshotDeprecatedExecute executes the request
	//  @return ScreenshotResponse
	// Deprecated
	TakeScreenshotDeprecatedExecute(r ToolboxAPITakeScreenshotDeprecatedRequest) (*ScreenshotResponse, *http.Response, error)

	/*
	TypeTextDeprecated [DEPRECATED] Type text

	Type text using keyboard

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPITypeTextDeprecatedRequest

	Deprecated
	*/
	TypeTextDeprecated(ctx context.Context, sandboxId string) ToolboxAPITypeTextDeprecatedRequest

	// TypeTextDeprecatedExecute executes the request
	// Deprecated
	TypeTextDeprecatedExecute(r ToolboxAPITypeTextDeprecatedRequest) (*http.Response, error)

	/*
	UploadFileDeprecated [DEPRECATED] Upload file

	Upload file inside sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIUploadFileDeprecatedRequest

	Deprecated
	*/
	UploadFileDeprecated(ctx context.Context, sandboxId string) ToolboxAPIUploadFileDeprecatedRequest

	// UploadFileDeprecatedExecute executes the request
	// Deprecated
	UploadFileDeprecatedExecute(r ToolboxAPIUploadFileDeprecatedRequest) (*http.Response, error)

	/*
	UploadFilesDeprecated [DEPRECATED] Upload multiple files

	Upload multiple files inside sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIUploadFilesDeprecatedRequest

	Deprecated
	*/
	UploadFilesDeprecated(ctx context.Context, sandboxId string) ToolboxAPIUploadFilesDeprecatedRequest

	// UploadFilesDeprecatedExecute executes the request
	// Deprecated
	UploadFilesDeprecatedExecute(r ToolboxAPIUploadFilesDeprecatedRequest) (*http.Response, error)
}

// ToolboxAPIService ToolboxAPI service
type ToolboxAPIService service

type ToolboxAPIClickMouseDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	mouseClickRequest *MouseClickRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIClickMouseDeprecatedRequest) MouseClickRequest(mouseClickRequest MouseClickRequest) ToolboxAPIClickMouseDeprecatedRequest {
	r.mouseClickRequest = &mouseClickRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIClickMouseDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIClickMouseDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIClickMouseDeprecatedRequest) Execute() (*MouseClickResponse, *http.Response, error) {
	return r.ApiService.ClickMouseDeprecatedExecute(r)
}

/*
ClickMouseDeprecated [DEPRECATED] Click mouse

Click mouse at specified coordinates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIClickMouseDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) ClickMouseDeprecated(ctx context.Context, sandboxId string) ToolboxAPIClickMouseDeprecatedRequest {
	return ToolboxAPIClickMouseDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return MouseClickResponse
// Deprecated
func (a *ToolboxAPIService) ClickMouseDeprecatedExecute(r ToolboxAPIClickMouseDeprecatedRequest) (*MouseClickResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MouseClickResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.ClickMouseDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/mouse/click"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mouseClickRequest == nil {
		return localVarReturnValue, nil, reportError("mouseClickRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.mouseClickRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPICreateFolderDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	path *string
	mode *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPICreateFolderDeprecatedRequest) Path(path string) ToolboxAPICreateFolderDeprecatedRequest {
	r.path = &path
	return r
}

func (r ToolboxAPICreateFolderDeprecatedRequest) Mode(mode string) ToolboxAPICreateFolderDeprecatedRequest {
	r.mode = &mode
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPICreateFolderDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPICreateFolderDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPICreateFolderDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateFolderDeprecatedExecute(r)
}

/*
CreateFolderDeprecated [DEPRECATED] Create folder

Create folder inside sandbox

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPICreateFolderDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) CreateFolderDeprecated(ctx context.Context, sandboxId string) ToolboxAPICreateFolderDeprecatedRequest {
	return ToolboxAPICreateFolderDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) CreateFolderDeprecatedExecute(r ToolboxAPICreateFolderDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.CreateFolderDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files/folder"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return nil, reportError("path is required and must be specified")
	}
	if r.mode == nil {
		return nil, reportError("mode is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPICreatePTYSessionDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	ptyCreateRequest *PtyCreateRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPICreatePTYSessionDeprecatedRequest) PtyCreateRequest(ptyCreateRequest PtyCreateRequest) ToolboxAPICreatePTYSessionDeprecatedRequest {
	r.ptyCreateRequest = &ptyCreateRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPICreatePTYSessionDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPICreatePTYSessionDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPICreatePTYSessionDeprecatedRequest) Execute() (*PtyCreateResponse, *http.Response, error) {
	return r.ApiService.CreatePTYSessionDeprecatedExecute(r)
}

/*
CreatePTYSessionDeprecated [DEPRECATED] Create PTY session

Create a new PTY session in the sandbox

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPICreatePTYSessionDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) CreatePTYSessionDeprecated(ctx context.Context, sandboxId string) ToolboxAPICreatePTYSessionDeprecatedRequest {
	return ToolboxAPICreatePTYSessionDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return PtyCreateResponse
// Deprecated
func (a *ToolboxAPIService) CreatePTYSessionDeprecatedExecute(r ToolboxAPICreatePTYSessionDeprecatedRequest) (*PtyCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PtyCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.CreatePTYSessionDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/process/pty"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ptyCreateRequest == nil {
		return localVarReturnValue, nil, reportError("ptyCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.ptyCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPICreateSessionDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	createSessionRequest *CreateSessionRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPICreateSessionDeprecatedRequest) CreateSessionRequest(createSessionRequest CreateSessionRequest) ToolboxAPICreateSessionDeprecatedRequest {
	r.createSessionRequest = &createSessionRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPICreateSessionDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPICreateSessionDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPICreateSessionDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateSessionDeprecatedExecute(r)
}

/*
CreateSessionDeprecated [DEPRECATED] Create session

Create a new session in the sandbox

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPICreateSessionDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) CreateSessionDeprecated(ctx context.Context, sandboxId string) ToolboxAPICreateSessionDeprecatedRequest {
	return ToolboxAPICreateSessionDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) CreateSessionDeprecatedExecute(r ToolboxAPICreateSessionDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.CreateSessionDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/process/session"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createSessionRequest == nil {
		return nil, reportError("createSessionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.createSessionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIDeleteFileDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	path *string
	xDaytonaOrganizationID *string
	recursive *bool
}

func (r ToolboxAPIDeleteFileDeprecatedRequest) Path(path string) ToolboxAPIDeleteFileDeprecatedRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIDeleteFileDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIDeleteFileDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIDeleteFileDeprecatedRequest) Recursive(recursive bool) ToolboxAPIDeleteFileDeprecatedRequest {
	r.recursive = &recursive
	return r
}

func (r ToolboxAPIDeleteFileDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFileDeprecatedExecute(r)
}

/*
DeleteFileDeprecated [DEPRECATED] Delete file

Delete file inside sandbox

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIDeleteFileDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) DeleteFileDeprecated(ctx context.Context, sandboxId string) ToolboxAPIDeleteFileDeprecatedRequest {
	return ToolboxAPIDeleteFileDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) DeleteFileDeprecatedExecute(r ToolboxAPIDeleteFileDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.DeleteFileDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return nil, reportError("path is required and must be specified")
	}

	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recursive", r.recursive, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIDeletePTYSessionDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	sessionId string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIDeletePTYSessionDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIDeletePTYSessionDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIDeletePTYSessionDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePTYSessionDeprecatedExecute(r)
}

/*
DeletePTYSessionDeprecated [DEPRECATED] Delete PTY session

Delete a PTY session and terminate the associated process

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @param sessionId
 @return ToolboxAPIDeletePTYSessionDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) DeletePTYSessionDeprecated(ctx context.Context, sandboxId string, sessionId string) ToolboxAPIDeletePTYSessionDeprecatedRequest {
	return ToolboxAPIDeletePTYSessionDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
		sessionId: sessionId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) DeletePTYSessionDeprecatedExecute(r ToolboxAPIDeletePTYSessionDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.DeletePTYSessionDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/process/pty/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIDeleteSessionDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	sessionId string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIDeleteSessionDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIDeleteSessionDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIDeleteSessionDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSessionDeprecatedExecute(r)
}

/*
DeleteSessionDeprecated [DEPRECATED] Delete session

Delete a specific session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @param sessionId
 @return ToolboxAPIDeleteSessionDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) DeleteSessionDeprecated(ctx context.Context, sandboxId string, sessionId string) ToolboxAPIDeleteSessionDeprecatedRequest {
	return ToolboxAPIDeleteSessionDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
		sessionId: sessionId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) DeleteSessionDeprecatedExecute(r ToolboxAPIDeleteSessionDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.DeleteSessionDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/process/session/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIDownloadFileDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	path *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIDownloadFileDeprecatedRequest) Path(path string) ToolboxAPIDownloadFileDeprecatedRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIDownloadFileDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIDownloadFileDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIDownloadFileDeprecatedRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.DownloadFileDeprecatedExecute(r)
}

/*
DownloadFileDeprecated [DEPRECATED] Download file

Download file from sandbox

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIDownloadFileDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) DownloadFileDeprecated(ctx context.Context, sandboxId string) ToolboxAPIDownloadFileDeprecatedRequest {
	return ToolboxAPIDownloadFileDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return *os.File
// Deprecated
func (a *ToolboxAPIService) DownloadFileDeprecatedExecute(r ToolboxAPIDownloadFileDeprecatedRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.DownloadFileDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files/download"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIDownloadFilesDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	downloadFiles *DownloadFiles
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIDownloadFilesDeprecatedRequest) DownloadFiles(downloadFiles DownloadFiles) ToolboxAPIDownloadFilesDeprecatedRequest {
	r.downloadFiles = &downloadFiles
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIDownloadFilesDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIDownloadFilesDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIDownloadFilesDeprecatedRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.DownloadFilesDeprecatedExecute(r)
}

/*
DownloadFilesDeprecated [DEPRECATED] Download multiple files

Streams back a multipart/form-data bundle of the requested paths

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIDownloadFilesDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) DownloadFilesDeprecated(ctx context.Context, sandboxId string) ToolboxAPIDownloadFilesDeprecatedRequest {
	return ToolboxAPIDownloadFilesDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return *os.File
// Deprecated
func (a *ToolboxAPIService) DownloadFilesDeprecatedExecute(r ToolboxAPIDownloadFilesDeprecatedRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.DownloadFilesDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files/bulk-download"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.downloadFiles == nil {
		return localVarReturnValue, nil, reportError("downloadFiles is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.downloadFiles
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIDragMouseDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	mouseDragRequest *MouseDragRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIDragMouseDeprecatedRequest) MouseDragRequest(mouseDragRequest MouseDragRequest) ToolboxAPIDragMouseDeprecatedRequest {
	r.mouseDragRequest = &mouseDragRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIDragMouseDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIDragMouseDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIDragMouseDeprecatedRequest) Execute() (*MouseDragResponse, *http.Response, error) {
	return r.ApiService.DragMouseDeprecatedExecute(r)
}

/*
DragMouseDeprecated [DEPRECATED] Drag mouse

Drag mouse from start to end coordinates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIDragMouseDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) DragMouseDeprecated(ctx context.Context, sandboxId string) ToolboxAPIDragMouseDeprecatedRequest {
	return ToolboxAPIDragMouseDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return MouseDragResponse
// Deprecated
func (a *ToolboxAPIService) DragMouseDeprecatedExecute(r ToolboxAPIDragMouseDeprecatedRequest) (*MouseDragResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MouseDragResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.DragMouseDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/mouse/drag"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mouseDragRequest == nil {
		return localVarReturnValue, nil, reportError("mouseDragRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.mouseDragRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIExecuteCommandDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	executeRequest *ExecuteRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIExecuteCommandDeprecatedRequest) ExecuteRequest(executeRequest ExecuteRequest) ToolboxAPIExecuteCommandDeprecatedRequest {
	r.executeRequest = &executeRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIExecuteCommandDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIExecuteCommandDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIExecuteCommandDeprecatedRequest) Execute() (*ExecuteResponse, *http.Response, error) {
	return r.ApiService.ExecuteCommandDeprecatedExecute(r)
}

/*
ExecuteCommandDeprecated [DEPRECATED] Execute command

Execute command synchronously inside sandbox

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIExecuteCommandDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) ExecuteCommandDeprecated(ctx context.Context, sandboxId string) ToolboxAPIExecuteCommandDeprecatedRequest {
	return ToolboxAPIExecuteCommandDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return ExecuteResponse
// Deprecated
func (a *ToolboxAPIService) ExecuteCommandDeprecatedExecute(r ToolboxAPIExecuteCommandDeprecatedRequest) (*ExecuteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExecuteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.ExecuteCommandDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/process/execute"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.executeRequest == nil {
		return localVarReturnValue, nil, reportError("executeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.executeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIExecuteSessionCommandDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	sessionId string
	sessionExecuteRequest *SessionExecuteRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIExecuteSessionCommandDeprecatedRequest) SessionExecuteRequest(sessionExecuteRequest SessionExecuteRequest) ToolboxAPIExecuteSessionCommandDeprecatedRequest {
	r.sessionExecuteRequest = &sessionExecuteRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIExecuteSessionCommandDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIExecuteSessionCommandDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIExecuteSessionCommandDeprecatedRequest) Execute() (*SessionExecuteResponse, *http.Response, error) {
	return r.ApiService.ExecuteSessionCommandDeprecatedExecute(r)
}

/*
ExecuteSessionCommandDeprecated [DEPRECATED] Execute command in session

Execute a command in a specific session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @param sessionId
 @return ToolboxAPIExecuteSessionCommandDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) ExecuteSessionCommandDeprecated(ctx context.Context, sandboxId string, sessionId string) ToolboxAPIExecuteSessionCommandDeprecatedRequest {
	return ToolboxAPIExecuteSessionCommandDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return SessionExecuteResponse
// Deprecated
func (a *ToolboxAPIService) ExecuteSessionCommandDeprecatedExecute(r ToolboxAPIExecuteSessionCommandDeprecatedRequest) (*SessionExecuteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionExecuteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.ExecuteSessionCommandDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/process/session/{sessionId}/exec"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionExecuteRequest == nil {
		return localVarReturnValue, nil, reportError("sessionExecuteRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.sessionExecuteRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIFindInFilesDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	path *string
	pattern *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIFindInFilesDeprecatedRequest) Path(path string) ToolboxAPIFindInFilesDeprecatedRequest {
	r.path = &path
	return r
}

func (r ToolboxAPIFindInFilesDeprecatedRequest) Pattern(pattern string) ToolboxAPIFindInFilesDeprecatedRequest {
	r.pattern = &pattern
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIFindInFilesDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIFindInFilesDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIFindInFilesDeprecatedRequest) Execute() ([]Match, *http.Response, error) {
	return r.ApiService.FindInFilesDeprecatedExecute(r)
}

/*
FindInFilesDeprecated [DEPRECATED] Search for text/pattern in files

Search for text/pattern inside sandbox files

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIFindInFilesDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) FindInFilesDeprecated(ctx context.Context, sandboxId string) ToolboxAPIFindInFilesDeprecatedRequest {
	return ToolboxAPIFindInFilesDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return []Match
// Deprecated
func (a *ToolboxAPIService) FindInFilesDeprecatedExecute(r ToolboxAPIFindInFilesDeprecatedRequest) ([]Match, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Match
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.FindInFilesDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files/find"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}
	if r.pattern == nil {
		return localVarReturnValue, nil, reportError("pattern is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pattern", r.pattern, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetComputerUseStatusDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetComputerUseStatusDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetComputerUseStatusDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetComputerUseStatusDeprecatedRequest) Execute() (*ComputerUseStatusResponse, *http.Response, error) {
	return r.ApiService.GetComputerUseStatusDeprecatedExecute(r)
}

/*
GetComputerUseStatusDeprecated [DEPRECATED] Get computer use status

Get status of all VNC desktop processes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIGetComputerUseStatusDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GetComputerUseStatusDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGetComputerUseStatusDeprecatedRequest {
	return ToolboxAPIGetComputerUseStatusDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return ComputerUseStatusResponse
// Deprecated
func (a *ToolboxAPIService) GetComputerUseStatusDeprecatedExecute(r ToolboxAPIGetComputerUseStatusDeprecatedRequest) (*ComputerUseStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComputerUseStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetComputerUseStatusDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/status"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetDisplayInfoDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetDisplayInfoDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetDisplayInfoDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetDisplayInfoDeprecatedRequest) Execute() (*DisplayInfoResponse, *http.Response, error) {
	return r.ApiService.GetDisplayInfoDeprecatedExecute(r)
}

/*
GetDisplayInfoDeprecated [DEPRECATED] Get display info

Get information about displays

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIGetDisplayInfoDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GetDisplayInfoDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGetDisplayInfoDeprecatedRequest {
	return ToolboxAPIGetDisplayInfoDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return DisplayInfoResponse
// Deprecated
func (a *ToolboxAPIService) GetDisplayInfoDeprecatedExecute(r ToolboxAPIGetDisplayInfoDeprecatedRequest) (*DisplayInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DisplayInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetDisplayInfoDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/display/info"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetFileInfoDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	path *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGetFileInfoDeprecatedRequest) Path(path string) ToolboxAPIGetFileInfoDeprecatedRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetFileInfoDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetFileInfoDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetFileInfoDeprecatedRequest) Execute() (*FileInfo, *http.Response, error) {
	return r.ApiService.GetFileInfoDeprecatedExecute(r)
}

/*
GetFileInfoDeprecated [DEPRECATED] Get file info

Get file info inside sandbox

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIGetFileInfoDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GetFileInfoDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGetFileInfoDeprecatedRequest {
	return ToolboxAPIGetFileInfoDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return FileInfo
// Deprecated
func (a *ToolboxAPIService) GetFileInfoDeprecatedExecute(r ToolboxAPIGetFileInfoDeprecatedRequest) (*FileInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetFileInfoDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files/info"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetMousePositionDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetMousePositionDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetMousePositionDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetMousePositionDeprecatedRequest) Execute() (*MousePosition, *http.Response, error) {
	return r.ApiService.GetMousePositionDeprecatedExecute(r)
}

/*
GetMousePositionDeprecated [DEPRECATED] Get mouse position

Get current mouse cursor position

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIGetMousePositionDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GetMousePositionDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGetMousePositionDeprecatedRequest {
	return ToolboxAPIGetMousePositionDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return MousePosition
// Deprecated
func (a *ToolboxAPIService) GetMousePositionDeprecatedExecute(r ToolboxAPIGetMousePositionDeprecatedRequest) (*MousePosition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MousePosition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetMousePositionDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/mouse/position"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetPTYSessionDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	sessionId string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetPTYSessionDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetPTYSessionDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetPTYSessionDeprecatedRequest) Execute() (*PtySessionInfo, *http.Response, error) {
	return r.ApiService.GetPTYSessionDeprecatedExecute(r)
}

/*
GetPTYSessionDeprecated [DEPRECATED] Get PTY session

Get PTY session information by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @param sessionId
 @return ToolboxAPIGetPTYSessionDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GetPTYSessionDeprecated(ctx context.Context, sandboxId string, sessionId string) ToolboxAPIGetPTYSessionDeprecatedRequest {
	return ToolboxAPIGetPTYSessionDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return PtySessionInfo
// Deprecated
func (a *ToolboxAPIService) GetPTYSessionDeprecatedExecute(r ToolboxAPIGetPTYSessionDeprecatedRequest) (*PtySessionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PtySessionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetPTYSessionDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/process/pty/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetProcessErrorsDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	processName string
	sandboxId string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetProcessErrorsDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetProcessErrorsDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetProcessErrorsDeprecatedRequest) Execute() (*ProcessErrorsResponse, *http.Response, error) {
	return r.ApiService.GetProcessErrorsDeprecatedExecute(r)
}

/*
GetProcessErrorsDeprecated [DEPRECATED] Get process errors

Get error logs for a specific VNC process

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param processName
 @param sandboxId
 @return ToolboxAPIGetProcessErrorsDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GetProcessErrorsDeprecated(ctx context.Context, processName string, sandboxId string) ToolboxAPIGetProcessErrorsDeprecatedRequest {
	return ToolboxAPIGetProcessErrorsDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		processName: processName,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return ProcessErrorsResponse
// Deprecated
func (a *ToolboxAPIService) GetProcessErrorsDeprecatedExecute(r ToolboxAPIGetProcessErrorsDeprecatedRequest) (*ProcessErrorsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessErrorsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetProcessErrorsDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/process/{processName}/errors"
	localVarPath = strings.Replace(localVarPath, "{"+"processName"+"}", url.PathEscape(parameterValueToString(r.processName, "processName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetProcessLogsDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	processName string
	sandboxId string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetProcessLogsDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetProcessLogsDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetProcessLogsDeprecatedRequest) Execute() (*ProcessLogsResponse, *http.Response, error) {
	return r.ApiService.GetProcessLogsDeprecatedExecute(r)
}

/*
GetProcessLogsDeprecated [DEPRECATED] Get process logs

Get logs for a specific VNC process

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param processName
 @param sandboxId
 @return ToolboxAPIGetProcessLogsDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GetProcessLogsDeprecated(ctx context.Context, processName string, sandboxId string) ToolboxAPIGetProcessLogsDeprecatedRequest {
	return ToolboxAPIGetProcessLogsDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		processName: processName,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return ProcessLogsResponse
// Deprecated
func (a *ToolboxAPIService) GetProcessLogsDeprecatedExecute(r ToolboxAPIGetProcessLogsDeprecatedRequest) (*ProcessLogsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessLogsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetProcessLogsDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/process/{processName}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"processName"+"}", url.PathEscape(parameterValueToString(r.processName, "processName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetProcessStatusDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	processName string
	sandboxId string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetProcessStatusDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetProcessStatusDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetProcessStatusDeprecatedRequest) Execute() (*ProcessStatusResponse, *http.Response, error) {
	return r.ApiService.GetProcessStatusDeprecatedExecute(r)
}

/*
GetProcessStatusDeprecated [DEPRECATED] Get process status

Get status of a specific VNC process

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param processName
 @param sandboxId
 @return ToolboxAPIGetProcessStatusDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GetProcessStatusDeprecated(ctx context.Context, processName string, sandboxId string) ToolboxAPIGetProcessStatusDeprecatedRequest {
	return ToolboxAPIGetProcessStatusDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		processName: processName,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return ProcessStatusResponse
// Deprecated
func (a *ToolboxAPIService) GetProcessStatusDeprecatedExecute(r ToolboxAPIGetProcessStatusDeprecatedRequest) (*ProcessStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetProcessStatusDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/process/{processName}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"processName"+"}", url.PathEscape(parameterValueToString(r.processName, "processName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetProjectDirDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetProjectDirDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetProjectDirDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetProjectDirDeprecatedRequest) Execute() (*ProjectDirResponse, *http.Response, error) {
	return r.ApiService.GetProjectDirDeprecatedExecute(r)
}

/*
GetProjectDirDeprecated [DEPRECATED] Get sandbox project dir

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIGetProjectDirDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GetProjectDirDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGetProjectDirDeprecatedRequest {
	return ToolboxAPIGetProjectDirDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return ProjectDirResponse
// Deprecated
func (a *ToolboxAPIService) GetProjectDirDeprecatedExecute(r ToolboxAPIGetProjectDirDeprecatedRequest) (*ProjectDirResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProjectDirResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetProjectDirDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/project-dir"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetSessionCommandDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	sessionId string
	commandId string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetSessionCommandDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetSessionCommandDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetSessionCommandDeprecatedRequest) Execute() (*Command, *http.Response, error) {
	return r.ApiService.GetSessionCommandDeprecatedExecute(r)
}

/*
GetSessionCommandDeprecated [DEPRECATED] Get session command

Get session command by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @param sessionId
 @param commandId
 @return ToolboxAPIGetSessionCommandDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GetSessionCommandDeprecated(ctx context.Context, sandboxId string, sessionId string, commandId string) ToolboxAPIGetSessionCommandDeprecatedRequest {
	return ToolboxAPIGetSessionCommandDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
		sessionId: sessionId,
		commandId: commandId,
	}
}

// Execute executes the request
//  @return Command
// Deprecated
func (a *ToolboxAPIService) GetSessionCommandDeprecatedExecute(r ToolboxAPIGetSessionCommandDeprecatedRequest) (*Command, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Command
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetSessionCommandDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/process/session/{sessionId}/command/{commandId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commandId"+"}", url.PathEscape(parameterValueToString(r.commandId, "commandId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetSessionCommandLogsDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	sessionId string
	commandId string
	xDaytonaOrganizationID *string
	follow *bool
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetSessionCommandLogsDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetSessionCommandLogsDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

// Whether to stream the logs
func (r ToolboxAPIGetSessionCommandLogsDeprecatedRequest) Follow(follow bool) ToolboxAPIGetSessionCommandLogsDeprecatedRequest {
	r.follow = &follow
	return r
}

func (r ToolboxAPIGetSessionCommandLogsDeprecatedRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetSessionCommandLogsDeprecatedExecute(r)
}

/*
GetSessionCommandLogsDeprecated [DEPRECATED] Get command logs

Get logs for a specific command in a session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @param sessionId
 @param commandId
 @return ToolboxAPIGetSessionCommandLogsDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GetSessionCommandLogsDeprecated(ctx context.Context, sandboxId string, sessionId string, commandId string) ToolboxAPIGetSessionCommandLogsDeprecatedRequest {
	return ToolboxAPIGetSessionCommandLogsDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
		sessionId: sessionId,
		commandId: commandId,
	}
}

// Execute executes the request
//  @return string
// Deprecated
func (a *ToolboxAPIService) GetSessionCommandLogsDeprecatedExecute(r ToolboxAPIGetSessionCommandLogsDeprecatedRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetSessionCommandLogsDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/process/session/{sessionId}/command/{commandId}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commandId"+"}", url.PathEscape(parameterValueToString(r.commandId, "commandId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.follow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "follow", r.follow, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetSessionDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	sessionId string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetSessionDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetSessionDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetSessionDeprecatedRequest) Execute() (*Session, *http.Response, error) {
	return r.ApiService.GetSessionDeprecatedExecute(r)
}

/*
GetSessionDeprecated [DEPRECATED] Get session

Get session by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @param sessionId
 @return ToolboxAPIGetSessionDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GetSessionDeprecated(ctx context.Context, sandboxId string, sessionId string) ToolboxAPIGetSessionDeprecatedRequest {
	return ToolboxAPIGetSessionDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return Session
// Deprecated
func (a *ToolboxAPIService) GetSessionDeprecatedExecute(r ToolboxAPIGetSessionDeprecatedRequest) (*Session, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Session
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetSessionDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/process/session/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetUserHomeDirDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetUserHomeDirDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetUserHomeDirDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetUserHomeDirDeprecatedRequest) Execute() (*UserHomeDirResponse, *http.Response, error) {
	return r.ApiService.GetUserHomeDirDeprecatedExecute(r)
}

/*
GetUserHomeDirDeprecated [DEPRECATED] Get sandbox user home dir

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIGetUserHomeDirDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GetUserHomeDirDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGetUserHomeDirDeprecatedRequest {
	return ToolboxAPIGetUserHomeDirDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return UserHomeDirResponse
// Deprecated
func (a *ToolboxAPIService) GetUserHomeDirDeprecatedExecute(r ToolboxAPIGetUserHomeDirDeprecatedRequest) (*UserHomeDirResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserHomeDirResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetUserHomeDirDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/user-home-dir"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetWindowsDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetWindowsDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetWindowsDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetWindowsDeprecatedRequest) Execute() (*WindowsResponse, *http.Response, error) {
	return r.ApiService.GetWindowsDeprecatedExecute(r)
}

/*
GetWindowsDeprecated [DEPRECATED] Get windows

Get list of open windows

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIGetWindowsDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GetWindowsDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGetWindowsDeprecatedRequest {
	return ToolboxAPIGetWindowsDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return WindowsResponse
// Deprecated
func (a *ToolboxAPIService) GetWindowsDeprecatedExecute(r ToolboxAPIGetWindowsDeprecatedRequest) (*WindowsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WindowsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetWindowsDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/display/windows"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetWorkDirDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetWorkDirDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetWorkDirDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetWorkDirDeprecatedRequest) Execute() (*WorkDirResponse, *http.Response, error) {
	return r.ApiService.GetWorkDirDeprecatedExecute(r)
}

/*
GetWorkDirDeprecated [DEPRECATED] Get sandbox work-dir

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIGetWorkDirDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GetWorkDirDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGetWorkDirDeprecatedRequest {
	return ToolboxAPIGetWorkDirDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return WorkDirResponse
// Deprecated
func (a *ToolboxAPIService) GetWorkDirDeprecatedExecute(r ToolboxAPIGetWorkDirDeprecatedRequest) (*WorkDirResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkDirResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetWorkDirDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/work-dir"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGitAddFilesDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	gitAddRequest *GitAddRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitAddFilesDeprecatedRequest) GitAddRequest(gitAddRequest GitAddRequest) ToolboxAPIGitAddFilesDeprecatedRequest {
	r.gitAddRequest = &gitAddRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitAddFilesDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitAddFilesDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitAddFilesDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.GitAddFilesDeprecatedExecute(r)
}

/*
GitAddFilesDeprecated [DEPRECATED] Add files

Add files to git commit

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIGitAddFilesDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GitAddFilesDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGitAddFilesDeprecatedRequest {
	return ToolboxAPIGitAddFilesDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) GitAddFilesDeprecatedExecute(r ToolboxAPIGitAddFilesDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitAddFilesDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/git/add"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitAddRequest == nil {
		return nil, reportError("gitAddRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.gitAddRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIGitCheckoutBranchDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	gitCheckoutRequest *GitCheckoutRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitCheckoutBranchDeprecatedRequest) GitCheckoutRequest(gitCheckoutRequest GitCheckoutRequest) ToolboxAPIGitCheckoutBranchDeprecatedRequest {
	r.gitCheckoutRequest = &gitCheckoutRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitCheckoutBranchDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitCheckoutBranchDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitCheckoutBranchDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.GitCheckoutBranchDeprecatedExecute(r)
}

/*
GitCheckoutBranchDeprecated [DEPRECATED] Checkout branch

Checkout branch or commit in git repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIGitCheckoutBranchDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GitCheckoutBranchDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGitCheckoutBranchDeprecatedRequest {
	return ToolboxAPIGitCheckoutBranchDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) GitCheckoutBranchDeprecatedExecute(r ToolboxAPIGitCheckoutBranchDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitCheckoutBranchDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/git/checkout"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitCheckoutRequest == nil {
		return nil, reportError("gitCheckoutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.gitCheckoutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIGitCloneRepositoryDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	gitCloneRequest *GitCloneRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitCloneRepositoryDeprecatedRequest) GitCloneRequest(gitCloneRequest GitCloneRequest) ToolboxAPIGitCloneRepositoryDeprecatedRequest {
	r.gitCloneRequest = &gitCloneRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitCloneRepositoryDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitCloneRepositoryDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitCloneRepositoryDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.GitCloneRepositoryDeprecatedExecute(r)
}

/*
GitCloneRepositoryDeprecated [DEPRECATED] Clone repository

Clone git repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIGitCloneRepositoryDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GitCloneRepositoryDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGitCloneRepositoryDeprecatedRequest {
	return ToolboxAPIGitCloneRepositoryDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) GitCloneRepositoryDeprecatedExecute(r ToolboxAPIGitCloneRepositoryDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitCloneRepositoryDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/git/clone"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitCloneRequest == nil {
		return nil, reportError("gitCloneRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.gitCloneRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIGitCommitChangesDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	gitCommitRequest *GitCommitRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitCommitChangesDeprecatedRequest) GitCommitRequest(gitCommitRequest GitCommitRequest) ToolboxAPIGitCommitChangesDeprecatedRequest {
	r.gitCommitRequest = &gitCommitRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitCommitChangesDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitCommitChangesDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitCommitChangesDeprecatedRequest) Execute() (*GitCommitResponse, *http.Response, error) {
	return r.ApiService.GitCommitChangesDeprecatedExecute(r)
}

/*
GitCommitChangesDeprecated [DEPRECATED] Commit changes

Commit changes to git repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIGitCommitChangesDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GitCommitChangesDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGitCommitChangesDeprecatedRequest {
	return ToolboxAPIGitCommitChangesDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return GitCommitResponse
// Deprecated
func (a *ToolboxAPIService) GitCommitChangesDeprecatedExecute(r ToolboxAPIGitCommitChangesDeprecatedRequest) (*GitCommitResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GitCommitResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitCommitChangesDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/git/commit"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitCommitRequest == nil {
		return localVarReturnValue, nil, reportError("gitCommitRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.gitCommitRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGitCreateBranchDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	gitBranchRequest *GitBranchRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitCreateBranchDeprecatedRequest) GitBranchRequest(gitBranchRequest GitBranchRequest) ToolboxAPIGitCreateBranchDeprecatedRequest {
	r.gitBranchRequest = &gitBranchRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitCreateBranchDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitCreateBranchDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitCreateBranchDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.GitCreateBranchDeprecatedExecute(r)
}

/*
GitCreateBranchDeprecated [DEPRECATED] Create branch

Create branch on git repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIGitCreateBranchDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GitCreateBranchDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGitCreateBranchDeprecatedRequest {
	return ToolboxAPIGitCreateBranchDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) GitCreateBranchDeprecatedExecute(r ToolboxAPIGitCreateBranchDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitCreateBranchDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/git/branches"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitBranchRequest == nil {
		return nil, reportError("gitBranchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.gitBranchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIGitDeleteBranchDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	gitDeleteBranchRequest *GitDeleteBranchRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitDeleteBranchDeprecatedRequest) GitDeleteBranchRequest(gitDeleteBranchRequest GitDeleteBranchRequest) ToolboxAPIGitDeleteBranchDeprecatedRequest {
	r.gitDeleteBranchRequest = &gitDeleteBranchRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitDeleteBranchDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitDeleteBranchDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitDeleteBranchDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.GitDeleteBranchDeprecatedExecute(r)
}

/*
GitDeleteBranchDeprecated [DEPRECATED] Delete branch

Delete branch on git repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIGitDeleteBranchDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GitDeleteBranchDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGitDeleteBranchDeprecatedRequest {
	return ToolboxAPIGitDeleteBranchDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) GitDeleteBranchDeprecatedExecute(r ToolboxAPIGitDeleteBranchDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitDeleteBranchDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/git/branches"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitDeleteBranchRequest == nil {
		return nil, reportError("gitDeleteBranchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.gitDeleteBranchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIGitGetHistoryDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	path *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitGetHistoryDeprecatedRequest) Path(path string) ToolboxAPIGitGetHistoryDeprecatedRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitGetHistoryDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitGetHistoryDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitGetHistoryDeprecatedRequest) Execute() ([]GitCommitInfo, *http.Response, error) {
	return r.ApiService.GitGetHistoryDeprecatedExecute(r)
}

/*
GitGetHistoryDeprecated [DEPRECATED] Get commit history

Get commit history from git repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIGitGetHistoryDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GitGetHistoryDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGitGetHistoryDeprecatedRequest {
	return ToolboxAPIGitGetHistoryDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return []GitCommitInfo
// Deprecated
func (a *ToolboxAPIService) GitGetHistoryDeprecatedExecute(r ToolboxAPIGitGetHistoryDeprecatedRequest) ([]GitCommitInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GitCommitInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitGetHistoryDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/git/history"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGitGetStatusDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	path *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitGetStatusDeprecatedRequest) Path(path string) ToolboxAPIGitGetStatusDeprecatedRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitGetStatusDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitGetStatusDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitGetStatusDeprecatedRequest) Execute() (*GitStatus, *http.Response, error) {
	return r.ApiService.GitGetStatusDeprecatedExecute(r)
}

/*
GitGetStatusDeprecated [DEPRECATED] Get git status

Get status from git repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIGitGetStatusDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GitGetStatusDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGitGetStatusDeprecatedRequest {
	return ToolboxAPIGitGetStatusDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return GitStatus
// Deprecated
func (a *ToolboxAPIService) GitGetStatusDeprecatedExecute(r ToolboxAPIGitGetStatusDeprecatedRequest) (*GitStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GitStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitGetStatusDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/git/status"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGitListBranchesDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	path *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitListBranchesDeprecatedRequest) Path(path string) ToolboxAPIGitListBranchesDeprecatedRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitListBranchesDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitListBranchesDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitListBranchesDeprecatedRequest) Execute() (*ListBranchResponse, *http.Response, error) {
	return r.ApiService.GitListBranchesDeprecatedExecute(r)
}

/*
GitListBranchesDeprecated [DEPRECATED] Get branch list

Get branch list from git repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIGitListBranchesDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GitListBranchesDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGitListBranchesDeprecatedRequest {
	return ToolboxAPIGitListBranchesDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return ListBranchResponse
// Deprecated
func (a *ToolboxAPIService) GitListBranchesDeprecatedExecute(r ToolboxAPIGitListBranchesDeprecatedRequest) (*ListBranchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListBranchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitListBranchesDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/git/branches"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGitPullChangesDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	gitRepoRequest *GitRepoRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitPullChangesDeprecatedRequest) GitRepoRequest(gitRepoRequest GitRepoRequest) ToolboxAPIGitPullChangesDeprecatedRequest {
	r.gitRepoRequest = &gitRepoRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitPullChangesDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitPullChangesDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitPullChangesDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.GitPullChangesDeprecatedExecute(r)
}

/*
GitPullChangesDeprecated [DEPRECATED] Pull changes

Pull changes from remote

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIGitPullChangesDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GitPullChangesDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGitPullChangesDeprecatedRequest {
	return ToolboxAPIGitPullChangesDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) GitPullChangesDeprecatedExecute(r ToolboxAPIGitPullChangesDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitPullChangesDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/git/pull"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitRepoRequest == nil {
		return nil, reportError("gitRepoRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.gitRepoRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIGitPushChangesDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	gitRepoRequest *GitRepoRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitPushChangesDeprecatedRequest) GitRepoRequest(gitRepoRequest GitRepoRequest) ToolboxAPIGitPushChangesDeprecatedRequest {
	r.gitRepoRequest = &gitRepoRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitPushChangesDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitPushChangesDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitPushChangesDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.GitPushChangesDeprecatedExecute(r)
}

/*
GitPushChangesDeprecated [DEPRECATED] Push changes

Push changes to remote

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIGitPushChangesDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) GitPushChangesDeprecated(ctx context.Context, sandboxId string) ToolboxAPIGitPushChangesDeprecatedRequest {
	return ToolboxAPIGitPushChangesDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) GitPushChangesDeprecatedExecute(r ToolboxAPIGitPushChangesDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitPushChangesDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/git/push"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitRepoRequest == nil {
		return nil, reportError("gitRepoRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.gitRepoRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIListFilesDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	xDaytonaOrganizationID *string
	path *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIListFilesDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIListFilesDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIListFilesDeprecatedRequest) Path(path string) ToolboxAPIListFilesDeprecatedRequest {
	r.path = &path
	return r
}

func (r ToolboxAPIListFilesDeprecatedRequest) Execute() ([]FileInfo, *http.Response, error) {
	return r.ApiService.ListFilesDeprecatedExecute(r)
}

/*
ListFilesDeprecated [DEPRECATED] List files

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIListFilesDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) ListFilesDeprecated(ctx context.Context, sandboxId string) ToolboxAPIListFilesDeprecatedRequest {
	return ToolboxAPIListFilesDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return []FileInfo
// Deprecated
func (a *ToolboxAPIService) ListFilesDeprecatedExecute(r ToolboxAPIListFilesDeprecatedRequest) ([]FileInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FileInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.ListFilesDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIListPTYSessionsDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIListPTYSessionsDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIListPTYSessionsDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIListPTYSessionsDeprecatedRequest) Execute() (*PtyListResponse, *http.Response, error) {
	return r.ApiService.ListPTYSessionsDeprecatedExecute(r)
}

/*
ListPTYSessionsDeprecated [DEPRECATED] List PTY sessions

List all active PTY sessions in the sandbox

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIListPTYSessionsDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) ListPTYSessionsDeprecated(ctx context.Context, sandboxId string) ToolboxAPIListPTYSessionsDeprecatedRequest {
	return ToolboxAPIListPTYSessionsDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return PtyListResponse
// Deprecated
func (a *ToolboxAPIService) ListPTYSessionsDeprecatedExecute(r ToolboxAPIListPTYSessionsDeprecatedRequest) (*PtyListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PtyListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.ListPTYSessionsDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/process/pty"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIListSessionsDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIListSessionsDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIListSessionsDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIListSessionsDeprecatedRequest) Execute() ([]Session, *http.Response, error) {
	return r.ApiService.ListSessionsDeprecatedExecute(r)
}

/*
ListSessionsDeprecated [DEPRECATED] List sessions

List all active sessions in the sandbox

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIListSessionsDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) ListSessionsDeprecated(ctx context.Context, sandboxId string) ToolboxAPIListSessionsDeprecatedRequest {
	return ToolboxAPIListSessionsDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return []Session
// Deprecated
func (a *ToolboxAPIService) ListSessionsDeprecatedExecute(r ToolboxAPIListSessionsDeprecatedRequest) ([]Session, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Session
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.ListSessionsDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/process/session"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPILspCompletionsDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	lspCompletionParams *LspCompletionParams
	xDaytonaOrganizationID *string
}

func (r ToolboxAPILspCompletionsDeprecatedRequest) LspCompletionParams(lspCompletionParams LspCompletionParams) ToolboxAPILspCompletionsDeprecatedRequest {
	r.lspCompletionParams = &lspCompletionParams
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPILspCompletionsDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPILspCompletionsDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPILspCompletionsDeprecatedRequest) Execute() (*CompletionList, *http.Response, error) {
	return r.ApiService.LspCompletionsDeprecatedExecute(r)
}

/*
LspCompletionsDeprecated [DEPRECATED] Get Lsp Completions

The Completion request is sent from the client to the server to compute completion items at a given cursor position.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPILspCompletionsDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) LspCompletionsDeprecated(ctx context.Context, sandboxId string) ToolboxAPILspCompletionsDeprecatedRequest {
	return ToolboxAPILspCompletionsDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return CompletionList
// Deprecated
func (a *ToolboxAPIService) LspCompletionsDeprecatedExecute(r ToolboxAPILspCompletionsDeprecatedRequest) (*CompletionList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompletionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.LspCompletionsDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/lsp/completions"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lspCompletionParams == nil {
		return localVarReturnValue, nil, reportError("lspCompletionParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.lspCompletionParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPILspDidCloseDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	lspDocumentRequest *LspDocumentRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPILspDidCloseDeprecatedRequest) LspDocumentRequest(lspDocumentRequest LspDocumentRequest) ToolboxAPILspDidCloseDeprecatedRequest {
	r.lspDocumentRequest = &lspDocumentRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPILspDidCloseDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPILspDidCloseDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPILspDidCloseDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.LspDidCloseDeprecatedExecute(r)
}

/*
LspDidCloseDeprecated [DEPRECATED] Call Lsp DidClose

The document close notification is sent from the client to the server when the document got closed in the client.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPILspDidCloseDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) LspDidCloseDeprecated(ctx context.Context, sandboxId string) ToolboxAPILspDidCloseDeprecatedRequest {
	return ToolboxAPILspDidCloseDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) LspDidCloseDeprecatedExecute(r ToolboxAPILspDidCloseDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.LspDidCloseDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/lsp/did-close"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lspDocumentRequest == nil {
		return nil, reportError("lspDocumentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.lspDocumentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPILspDidOpenDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	lspDocumentRequest *LspDocumentRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPILspDidOpenDeprecatedRequest) LspDocumentRequest(lspDocumentRequest LspDocumentRequest) ToolboxAPILspDidOpenDeprecatedRequest {
	r.lspDocumentRequest = &lspDocumentRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPILspDidOpenDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPILspDidOpenDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPILspDidOpenDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.LspDidOpenDeprecatedExecute(r)
}

/*
LspDidOpenDeprecated [DEPRECATED] Call Lsp DidOpen

The document open notification is sent from the client to the server to signal newly opened text documents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPILspDidOpenDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) LspDidOpenDeprecated(ctx context.Context, sandboxId string) ToolboxAPILspDidOpenDeprecatedRequest {
	return ToolboxAPILspDidOpenDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) LspDidOpenDeprecatedExecute(r ToolboxAPILspDidOpenDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.LspDidOpenDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/lsp/did-open"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lspDocumentRequest == nil {
		return nil, reportError("lspDocumentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.lspDocumentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPILspDocumentSymbolsDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	languageId *string
	pathToProject *string
	uri *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPILspDocumentSymbolsDeprecatedRequest) LanguageId(languageId string) ToolboxAPILspDocumentSymbolsDeprecatedRequest {
	r.languageId = &languageId
	return r
}

func (r ToolboxAPILspDocumentSymbolsDeprecatedRequest) PathToProject(pathToProject string) ToolboxAPILspDocumentSymbolsDeprecatedRequest {
	r.pathToProject = &pathToProject
	return r
}

func (r ToolboxAPILspDocumentSymbolsDeprecatedRequest) Uri(uri string) ToolboxAPILspDocumentSymbolsDeprecatedRequest {
	r.uri = &uri
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPILspDocumentSymbolsDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPILspDocumentSymbolsDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPILspDocumentSymbolsDeprecatedRequest) Execute() ([]LspSymbol, *http.Response, error) {
	return r.ApiService.LspDocumentSymbolsDeprecatedExecute(r)
}

/*
LspDocumentSymbolsDeprecated [DEPRECATED] Call Lsp DocumentSymbols

The document symbol request is sent from the client to the server.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPILspDocumentSymbolsDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) LspDocumentSymbolsDeprecated(ctx context.Context, sandboxId string) ToolboxAPILspDocumentSymbolsDeprecatedRequest {
	return ToolboxAPILspDocumentSymbolsDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return []LspSymbol
// Deprecated
func (a *ToolboxAPIService) LspDocumentSymbolsDeprecatedExecute(r ToolboxAPILspDocumentSymbolsDeprecatedRequest) ([]LspSymbol, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LspSymbol
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.LspDocumentSymbolsDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/lsp/document-symbols"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.languageId == nil {
		return localVarReturnValue, nil, reportError("languageId is required and must be specified")
	}
	if r.pathToProject == nil {
		return localVarReturnValue, nil, reportError("pathToProject is required and must be specified")
	}
	if r.uri == nil {
		return localVarReturnValue, nil, reportError("uri is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "languageId", r.languageId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pathToProject", r.pathToProject, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "uri", r.uri, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPILspStartDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	lspServerRequest *LspServerRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPILspStartDeprecatedRequest) LspServerRequest(lspServerRequest LspServerRequest) ToolboxAPILspStartDeprecatedRequest {
	r.lspServerRequest = &lspServerRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPILspStartDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPILspStartDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPILspStartDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.LspStartDeprecatedExecute(r)
}

/*
LspStartDeprecated [DEPRECATED] Start Lsp server

Start Lsp server process inside sandbox project

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPILspStartDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) LspStartDeprecated(ctx context.Context, sandboxId string) ToolboxAPILspStartDeprecatedRequest {
	return ToolboxAPILspStartDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) LspStartDeprecatedExecute(r ToolboxAPILspStartDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.LspStartDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/lsp/start"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lspServerRequest == nil {
		return nil, reportError("lspServerRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.lspServerRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPILspStopDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	lspServerRequest *LspServerRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPILspStopDeprecatedRequest) LspServerRequest(lspServerRequest LspServerRequest) ToolboxAPILspStopDeprecatedRequest {
	r.lspServerRequest = &lspServerRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPILspStopDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPILspStopDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPILspStopDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.LspStopDeprecatedExecute(r)
}

/*
LspStopDeprecated [DEPRECATED] Stop Lsp server

Stop Lsp server process inside sandbox project

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPILspStopDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) LspStopDeprecated(ctx context.Context, sandboxId string) ToolboxAPILspStopDeprecatedRequest {
	return ToolboxAPILspStopDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) LspStopDeprecatedExecute(r ToolboxAPILspStopDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.LspStopDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/lsp/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lspServerRequest == nil {
		return nil, reportError("lspServerRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.lspServerRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPILspWorkspaceSymbolsDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	languageId *string
	pathToProject *string
	query *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPILspWorkspaceSymbolsDeprecatedRequest) LanguageId(languageId string) ToolboxAPILspWorkspaceSymbolsDeprecatedRequest {
	r.languageId = &languageId
	return r
}

func (r ToolboxAPILspWorkspaceSymbolsDeprecatedRequest) PathToProject(pathToProject string) ToolboxAPILspWorkspaceSymbolsDeprecatedRequest {
	r.pathToProject = &pathToProject
	return r
}

func (r ToolboxAPILspWorkspaceSymbolsDeprecatedRequest) Query(query string) ToolboxAPILspWorkspaceSymbolsDeprecatedRequest {
	r.query = &query
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPILspWorkspaceSymbolsDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPILspWorkspaceSymbolsDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPILspWorkspaceSymbolsDeprecatedRequest) Execute() ([]LspSymbol, *http.Response, error) {
	return r.ApiService.LspWorkspaceSymbolsDeprecatedExecute(r)
}

/*
LspWorkspaceSymbolsDeprecated [DEPRECATED] Call Lsp WorkspaceSymbols

The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPILspWorkspaceSymbolsDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) LspWorkspaceSymbolsDeprecated(ctx context.Context, sandboxId string) ToolboxAPILspWorkspaceSymbolsDeprecatedRequest {
	return ToolboxAPILspWorkspaceSymbolsDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return []LspSymbol
// Deprecated
func (a *ToolboxAPIService) LspWorkspaceSymbolsDeprecatedExecute(r ToolboxAPILspWorkspaceSymbolsDeprecatedRequest) ([]LspSymbol, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LspSymbol
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.LspWorkspaceSymbolsDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/lsp/workspace-symbols"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.languageId == nil {
		return localVarReturnValue, nil, reportError("languageId is required and must be specified")
	}
	if r.pathToProject == nil {
		return localVarReturnValue, nil, reportError("pathToProject is required and must be specified")
	}
	if r.query == nil {
		return localVarReturnValue, nil, reportError("query is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "languageId", r.languageId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pathToProject", r.pathToProject, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIMoveFileDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	source *string
	destination *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIMoveFileDeprecatedRequest) Source(source string) ToolboxAPIMoveFileDeprecatedRequest {
	r.source = &source
	return r
}

func (r ToolboxAPIMoveFileDeprecatedRequest) Destination(destination string) ToolboxAPIMoveFileDeprecatedRequest {
	r.destination = &destination
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIMoveFileDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIMoveFileDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIMoveFileDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.MoveFileDeprecatedExecute(r)
}

/*
MoveFileDeprecated [DEPRECATED] Move file

Move file inside sandbox

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIMoveFileDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) MoveFileDeprecated(ctx context.Context, sandboxId string) ToolboxAPIMoveFileDeprecatedRequest {
	return ToolboxAPIMoveFileDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) MoveFileDeprecatedExecute(r ToolboxAPIMoveFileDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.MoveFileDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files/move"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.source == nil {
		return nil, reportError("source is required and must be specified")
	}
	if r.destination == nil {
		return nil, reportError("destination is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "destination", r.destination, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIMoveMouseDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	mouseMoveRequest *MouseMoveRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIMoveMouseDeprecatedRequest) MouseMoveRequest(mouseMoveRequest MouseMoveRequest) ToolboxAPIMoveMouseDeprecatedRequest {
	r.mouseMoveRequest = &mouseMoveRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIMoveMouseDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIMoveMouseDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIMoveMouseDeprecatedRequest) Execute() (*MouseMoveResponse, *http.Response, error) {
	return r.ApiService.MoveMouseDeprecatedExecute(r)
}

/*
MoveMouseDeprecated [DEPRECATED] Move mouse

Move mouse cursor to specified coordinates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIMoveMouseDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) MoveMouseDeprecated(ctx context.Context, sandboxId string) ToolboxAPIMoveMouseDeprecatedRequest {
	return ToolboxAPIMoveMouseDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return MouseMoveResponse
// Deprecated
func (a *ToolboxAPIService) MoveMouseDeprecatedExecute(r ToolboxAPIMoveMouseDeprecatedRequest) (*MouseMoveResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MouseMoveResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.MoveMouseDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/mouse/move"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mouseMoveRequest == nil {
		return localVarReturnValue, nil, reportError("mouseMoveRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.mouseMoveRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIPressHotkeyDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	keyboardHotkeyRequest *KeyboardHotkeyRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIPressHotkeyDeprecatedRequest) KeyboardHotkeyRequest(keyboardHotkeyRequest KeyboardHotkeyRequest) ToolboxAPIPressHotkeyDeprecatedRequest {
	r.keyboardHotkeyRequest = &keyboardHotkeyRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIPressHotkeyDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIPressHotkeyDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIPressHotkeyDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.PressHotkeyDeprecatedExecute(r)
}

/*
PressHotkeyDeprecated [DEPRECATED] Press hotkey

Press a hotkey combination

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIPressHotkeyDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) PressHotkeyDeprecated(ctx context.Context, sandboxId string) ToolboxAPIPressHotkeyDeprecatedRequest {
	return ToolboxAPIPressHotkeyDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) PressHotkeyDeprecatedExecute(r ToolboxAPIPressHotkeyDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.PressHotkeyDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/keyboard/hotkey"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.keyboardHotkeyRequest == nil {
		return nil, reportError("keyboardHotkeyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.keyboardHotkeyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIPressKeyDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	keyboardPressRequest *KeyboardPressRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIPressKeyDeprecatedRequest) KeyboardPressRequest(keyboardPressRequest KeyboardPressRequest) ToolboxAPIPressKeyDeprecatedRequest {
	r.keyboardPressRequest = &keyboardPressRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIPressKeyDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIPressKeyDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIPressKeyDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.PressKeyDeprecatedExecute(r)
}

/*
PressKeyDeprecated [DEPRECATED] Press key

Press a key with optional modifiers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIPressKeyDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) PressKeyDeprecated(ctx context.Context, sandboxId string) ToolboxAPIPressKeyDeprecatedRequest {
	return ToolboxAPIPressKeyDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) PressKeyDeprecatedExecute(r ToolboxAPIPressKeyDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.PressKeyDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/keyboard/key"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.keyboardPressRequest == nil {
		return nil, reportError("keyboardPressRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.keyboardPressRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIReplaceInFilesDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	replaceRequest *ReplaceRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIReplaceInFilesDeprecatedRequest) ReplaceRequest(replaceRequest ReplaceRequest) ToolboxAPIReplaceInFilesDeprecatedRequest {
	r.replaceRequest = &replaceRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIReplaceInFilesDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIReplaceInFilesDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIReplaceInFilesDeprecatedRequest) Execute() ([]ReplaceResult, *http.Response, error) {
	return r.ApiService.ReplaceInFilesDeprecatedExecute(r)
}

/*
ReplaceInFilesDeprecated [DEPRECATED] Replace in files

Replace text/pattern in multiple files inside sandbox

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIReplaceInFilesDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) ReplaceInFilesDeprecated(ctx context.Context, sandboxId string) ToolboxAPIReplaceInFilesDeprecatedRequest {
	return ToolboxAPIReplaceInFilesDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return []ReplaceResult
// Deprecated
func (a *ToolboxAPIService) ReplaceInFilesDeprecatedExecute(r ToolboxAPIReplaceInFilesDeprecatedRequest) ([]ReplaceResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ReplaceResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.ReplaceInFilesDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files/replace"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.replaceRequest == nil {
		return localVarReturnValue, nil, reportError("replaceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.replaceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIResizePTYSessionDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	sessionId string
	ptyResizeRequest *PtyResizeRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIResizePTYSessionDeprecatedRequest) PtyResizeRequest(ptyResizeRequest PtyResizeRequest) ToolboxAPIResizePTYSessionDeprecatedRequest {
	r.ptyResizeRequest = &ptyResizeRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIResizePTYSessionDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIResizePTYSessionDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIResizePTYSessionDeprecatedRequest) Execute() (*PtySessionInfo, *http.Response, error) {
	return r.ApiService.ResizePTYSessionDeprecatedExecute(r)
}

/*
ResizePTYSessionDeprecated [DEPRECATED] Resize PTY session

Resize a PTY session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @param sessionId
 @return ToolboxAPIResizePTYSessionDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) ResizePTYSessionDeprecated(ctx context.Context, sandboxId string, sessionId string) ToolboxAPIResizePTYSessionDeprecatedRequest {
	return ToolboxAPIResizePTYSessionDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return PtySessionInfo
// Deprecated
func (a *ToolboxAPIService) ResizePTYSessionDeprecatedExecute(r ToolboxAPIResizePTYSessionDeprecatedRequest) (*PtySessionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PtySessionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.ResizePTYSessionDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/process/pty/{sessionId}/resize"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ptyResizeRequest == nil {
		return localVarReturnValue, nil, reportError("ptyResizeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.ptyResizeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIRestartProcessDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	processName string
	sandboxId string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIRestartProcessDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIRestartProcessDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIRestartProcessDeprecatedRequest) Execute() (*ProcessRestartResponse, *http.Response, error) {
	return r.ApiService.RestartProcessDeprecatedExecute(r)
}

/*
RestartProcessDeprecated [DEPRECATED] Restart process

Restart a specific VNC process

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param processName
 @param sandboxId
 @return ToolboxAPIRestartProcessDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) RestartProcessDeprecated(ctx context.Context, processName string, sandboxId string) ToolboxAPIRestartProcessDeprecatedRequest {
	return ToolboxAPIRestartProcessDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		processName: processName,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return ProcessRestartResponse
// Deprecated
func (a *ToolboxAPIService) RestartProcessDeprecatedExecute(r ToolboxAPIRestartProcessDeprecatedRequest) (*ProcessRestartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessRestartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.RestartProcessDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/process/{processName}/restart"
	localVarPath = strings.Replace(localVarPath, "{"+"processName"+"}", url.PathEscape(parameterValueToString(r.processName, "processName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIScrollMouseDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	mouseScrollRequest *MouseScrollRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIScrollMouseDeprecatedRequest) MouseScrollRequest(mouseScrollRequest MouseScrollRequest) ToolboxAPIScrollMouseDeprecatedRequest {
	r.mouseScrollRequest = &mouseScrollRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIScrollMouseDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIScrollMouseDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIScrollMouseDeprecatedRequest) Execute() (*MouseScrollResponse, *http.Response, error) {
	return r.ApiService.ScrollMouseDeprecatedExecute(r)
}

/*
ScrollMouseDeprecated [DEPRECATED] Scroll mouse

Scroll mouse at specified coordinates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIScrollMouseDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) ScrollMouseDeprecated(ctx context.Context, sandboxId string) ToolboxAPIScrollMouseDeprecatedRequest {
	return ToolboxAPIScrollMouseDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return MouseScrollResponse
// Deprecated
func (a *ToolboxAPIService) ScrollMouseDeprecatedExecute(r ToolboxAPIScrollMouseDeprecatedRequest) (*MouseScrollResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MouseScrollResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.ScrollMouseDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/mouse/scroll"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mouseScrollRequest == nil {
		return localVarReturnValue, nil, reportError("mouseScrollRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.mouseScrollRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPISearchFilesDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	path *string
	pattern *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPISearchFilesDeprecatedRequest) Path(path string) ToolboxAPISearchFilesDeprecatedRequest {
	r.path = &path
	return r
}

func (r ToolboxAPISearchFilesDeprecatedRequest) Pattern(pattern string) ToolboxAPISearchFilesDeprecatedRequest {
	r.pattern = &pattern
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPISearchFilesDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPISearchFilesDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPISearchFilesDeprecatedRequest) Execute() (*SearchFilesResponse, *http.Response, error) {
	return r.ApiService.SearchFilesDeprecatedExecute(r)
}

/*
SearchFilesDeprecated [DEPRECATED] Search files

Search for files inside sandbox

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPISearchFilesDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) SearchFilesDeprecated(ctx context.Context, sandboxId string) ToolboxAPISearchFilesDeprecatedRequest {
	return ToolboxAPISearchFilesDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return SearchFilesResponse
// Deprecated
func (a *ToolboxAPIService) SearchFilesDeprecatedExecute(r ToolboxAPISearchFilesDeprecatedRequest) (*SearchFilesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchFilesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.SearchFilesDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files/search"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}
	if r.pattern == nil {
		return localVarReturnValue, nil, reportError("pattern is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pattern", r.pattern, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPISetFilePermissionsDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	path *string
	xDaytonaOrganizationID *string
	owner *string
	group *string
	mode *string
}

func (r ToolboxAPISetFilePermissionsDeprecatedRequest) Path(path string) ToolboxAPISetFilePermissionsDeprecatedRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPISetFilePermissionsDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPISetFilePermissionsDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPISetFilePermissionsDeprecatedRequest) Owner(owner string) ToolboxAPISetFilePermissionsDeprecatedRequest {
	r.owner = &owner
	return r
}

func (r ToolboxAPISetFilePermissionsDeprecatedRequest) Group(group string) ToolboxAPISetFilePermissionsDeprecatedRequest {
	r.group = &group
	return r
}

func (r ToolboxAPISetFilePermissionsDeprecatedRequest) Mode(mode string) ToolboxAPISetFilePermissionsDeprecatedRequest {
	r.mode = &mode
	return r
}

func (r ToolboxAPISetFilePermissionsDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetFilePermissionsDeprecatedExecute(r)
}

/*
SetFilePermissionsDeprecated [DEPRECATED] Set file permissions

Set file owner/group/permissions inside sandbox

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPISetFilePermissionsDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) SetFilePermissionsDeprecated(ctx context.Context, sandboxId string) ToolboxAPISetFilePermissionsDeprecatedRequest {
	return ToolboxAPISetFilePermissionsDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) SetFilePermissionsDeprecatedExecute(r ToolboxAPISetFilePermissionsDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.SetFilePermissionsDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	if r.owner != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "owner", r.owner, "form", "")
	}
	if r.group != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group", r.group, "form", "")
	}
	if r.mode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIStartComputerUseDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIStartComputerUseDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIStartComputerUseDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIStartComputerUseDeprecatedRequest) Execute() (*ComputerUseStartResponse, *http.Response, error) {
	return r.ApiService.StartComputerUseDeprecatedExecute(r)
}

/*
StartComputerUseDeprecated [DEPRECATED] Start computer use processes

Start all VNC desktop processes (Xvfb, xfce4, x11vnc, novnc)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIStartComputerUseDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) StartComputerUseDeprecated(ctx context.Context, sandboxId string) ToolboxAPIStartComputerUseDeprecatedRequest {
	return ToolboxAPIStartComputerUseDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return ComputerUseStartResponse
// Deprecated
func (a *ToolboxAPIService) StartComputerUseDeprecatedExecute(r ToolboxAPIStartComputerUseDeprecatedRequest) (*ComputerUseStartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComputerUseStartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.StartComputerUseDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/start"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIStopComputerUseDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIStopComputerUseDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIStopComputerUseDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIStopComputerUseDeprecatedRequest) Execute() (*ComputerUseStopResponse, *http.Response, error) {
	return r.ApiService.StopComputerUseDeprecatedExecute(r)
}

/*
StopComputerUseDeprecated [DEPRECATED] Stop computer use processes

Stop all VNC desktop processes (Xvfb, xfce4, x11vnc, novnc)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIStopComputerUseDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) StopComputerUseDeprecated(ctx context.Context, sandboxId string) ToolboxAPIStopComputerUseDeprecatedRequest {
	return ToolboxAPIStopComputerUseDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return ComputerUseStopResponse
// Deprecated
func (a *ToolboxAPIService) StopComputerUseDeprecatedExecute(r ToolboxAPIStopComputerUseDeprecatedRequest) (*ComputerUseStopResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComputerUseStopResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.StopComputerUseDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	height *float32
	width *float32
	y *float32
	x *float32
	xDaytonaOrganizationID *string
	scale *float32
	quality *float32
	format *string
	showCursor *bool
}

func (r ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest) Height(height float32) ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest {
	r.height = &height
	return r
}

func (r ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest) Width(width float32) ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest {
	r.width = &width
	return r
}

func (r ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest) Y(y float32) ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest {
	r.y = &y
	return r
}

func (r ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest) X(x float32) ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest {
	r.x = &x
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest) Scale(scale float32) ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest {
	r.scale = &scale
	return r
}

func (r ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest) Quality(quality float32) ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest {
	r.quality = &quality
	return r
}

func (r ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest) Format(format string) ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest {
	r.format = &format
	return r
}

func (r ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest) ShowCursor(showCursor bool) ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest {
	r.showCursor = &showCursor
	return r
}

func (r ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest) Execute() (*CompressedScreenshotResponse, *http.Response, error) {
	return r.ApiService.TakeCompressedRegionScreenshotDeprecatedExecute(r)
}

/*
TakeCompressedRegionScreenshotDeprecated [DEPRECATED] Take compressed region screenshot

Take a compressed screenshot of a specific region

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) TakeCompressedRegionScreenshotDeprecated(ctx context.Context, sandboxId string) ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest {
	return ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return CompressedScreenshotResponse
// Deprecated
func (a *ToolboxAPIService) TakeCompressedRegionScreenshotDeprecatedExecute(r ToolboxAPITakeCompressedRegionScreenshotDeprecatedRequest) (*CompressedScreenshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompressedScreenshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.TakeCompressedRegionScreenshotDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/screenshot/region/compressed"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.height == nil {
		return localVarReturnValue, nil, reportError("height is required and must be specified")
	}
	if r.width == nil {
		return localVarReturnValue, nil, reportError("width is required and must be specified")
	}
	if r.y == nil {
		return localVarReturnValue, nil, reportError("y is required and must be specified")
	}
	if r.x == nil {
		return localVarReturnValue, nil, reportError("x is required and must be specified")
	}

	if r.scale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scale", r.scale, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.showCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_cursor", r.showCursor, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "y", r.y, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "x", r.x, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPITakeCompressedScreenshotDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	xDaytonaOrganizationID *string
	scale *float32
	quality *float32
	format *string
	showCursor *bool
}

// Use with JWT to specify the organization ID
func (r ToolboxAPITakeCompressedScreenshotDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPITakeCompressedScreenshotDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPITakeCompressedScreenshotDeprecatedRequest) Scale(scale float32) ToolboxAPITakeCompressedScreenshotDeprecatedRequest {
	r.scale = &scale
	return r
}

func (r ToolboxAPITakeCompressedScreenshotDeprecatedRequest) Quality(quality float32) ToolboxAPITakeCompressedScreenshotDeprecatedRequest {
	r.quality = &quality
	return r
}

func (r ToolboxAPITakeCompressedScreenshotDeprecatedRequest) Format(format string) ToolboxAPITakeCompressedScreenshotDeprecatedRequest {
	r.format = &format
	return r
}

func (r ToolboxAPITakeCompressedScreenshotDeprecatedRequest) ShowCursor(showCursor bool) ToolboxAPITakeCompressedScreenshotDeprecatedRequest {
	r.showCursor = &showCursor
	return r
}

func (r ToolboxAPITakeCompressedScreenshotDeprecatedRequest) Execute() (*CompressedScreenshotResponse, *http.Response, error) {
	return r.ApiService.TakeCompressedScreenshotDeprecatedExecute(r)
}

/*
TakeCompressedScreenshotDeprecated [DEPRECATED] Take compressed screenshot

Take a compressed screenshot with format, quality, and scale options

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPITakeCompressedScreenshotDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) TakeCompressedScreenshotDeprecated(ctx context.Context, sandboxId string) ToolboxAPITakeCompressedScreenshotDeprecatedRequest {
	return ToolboxAPITakeCompressedScreenshotDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return CompressedScreenshotResponse
// Deprecated
func (a *ToolboxAPIService) TakeCompressedScreenshotDeprecatedExecute(r ToolboxAPITakeCompressedScreenshotDeprecatedRequest) (*CompressedScreenshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompressedScreenshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.TakeCompressedScreenshotDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/screenshot/compressed"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scale", r.scale, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.showCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_cursor", r.showCursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPITakeRegionScreenshotDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	height *float32
	width *float32
	y *float32
	x *float32
	xDaytonaOrganizationID *string
	showCursor *bool
}

func (r ToolboxAPITakeRegionScreenshotDeprecatedRequest) Height(height float32) ToolboxAPITakeRegionScreenshotDeprecatedRequest {
	r.height = &height
	return r
}

func (r ToolboxAPITakeRegionScreenshotDeprecatedRequest) Width(width float32) ToolboxAPITakeRegionScreenshotDeprecatedRequest {
	r.width = &width
	return r
}

func (r ToolboxAPITakeRegionScreenshotDeprecatedRequest) Y(y float32) ToolboxAPITakeRegionScreenshotDeprecatedRequest {
	r.y = &y
	return r
}

func (r ToolboxAPITakeRegionScreenshotDeprecatedRequest) X(x float32) ToolboxAPITakeRegionScreenshotDeprecatedRequest {
	r.x = &x
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPITakeRegionScreenshotDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPITakeRegionScreenshotDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPITakeRegionScreenshotDeprecatedRequest) ShowCursor(showCursor bool) ToolboxAPITakeRegionScreenshotDeprecatedRequest {
	r.showCursor = &showCursor
	return r
}

func (r ToolboxAPITakeRegionScreenshotDeprecatedRequest) Execute() (*RegionScreenshotResponse, *http.Response, error) {
	return r.ApiService.TakeRegionScreenshotDeprecatedExecute(r)
}

/*
TakeRegionScreenshotDeprecated [DEPRECATED] Take region screenshot

Take a screenshot of a specific region

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPITakeRegionScreenshotDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) TakeRegionScreenshotDeprecated(ctx context.Context, sandboxId string) ToolboxAPITakeRegionScreenshotDeprecatedRequest {
	return ToolboxAPITakeRegionScreenshotDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return RegionScreenshotResponse
// Deprecated
func (a *ToolboxAPIService) TakeRegionScreenshotDeprecatedExecute(r ToolboxAPITakeRegionScreenshotDeprecatedRequest) (*RegionScreenshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegionScreenshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.TakeRegionScreenshotDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/screenshot/region"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.height == nil {
		return localVarReturnValue, nil, reportError("height is required and must be specified")
	}
	if r.width == nil {
		return localVarReturnValue, nil, reportError("width is required and must be specified")
	}
	if r.y == nil {
		return localVarReturnValue, nil, reportError("y is required and must be specified")
	}
	if r.x == nil {
		return localVarReturnValue, nil, reportError("x is required and must be specified")
	}

	if r.showCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_cursor", r.showCursor, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "y", r.y, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "x", r.x, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPITakeScreenshotDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	xDaytonaOrganizationID *string
	showCursor *bool
}

// Use with JWT to specify the organization ID
func (r ToolboxAPITakeScreenshotDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPITakeScreenshotDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPITakeScreenshotDeprecatedRequest) ShowCursor(showCursor bool) ToolboxAPITakeScreenshotDeprecatedRequest {
	r.showCursor = &showCursor
	return r
}

func (r ToolboxAPITakeScreenshotDeprecatedRequest) Execute() (*ScreenshotResponse, *http.Response, error) {
	return r.ApiService.TakeScreenshotDeprecatedExecute(r)
}

/*
TakeScreenshotDeprecated [DEPRECATED] Take screenshot

Take a screenshot of the entire screen

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPITakeScreenshotDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) TakeScreenshotDeprecated(ctx context.Context, sandboxId string) ToolboxAPITakeScreenshotDeprecatedRequest {
	return ToolboxAPITakeScreenshotDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
//  @return ScreenshotResponse
// Deprecated
func (a *ToolboxAPIService) TakeScreenshotDeprecatedExecute(r ToolboxAPITakeScreenshotDeprecatedRequest) (*ScreenshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScreenshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.TakeScreenshotDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/screenshot"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.showCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_cursor", r.showCursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPITypeTextDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	keyboardTypeRequest *KeyboardTypeRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPITypeTextDeprecatedRequest) KeyboardTypeRequest(keyboardTypeRequest KeyboardTypeRequest) ToolboxAPITypeTextDeprecatedRequest {
	r.keyboardTypeRequest = &keyboardTypeRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPITypeTextDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPITypeTextDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPITypeTextDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.TypeTextDeprecatedExecute(r)
}

/*
TypeTextDeprecated [DEPRECATED] Type text

Type text using keyboard

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPITypeTextDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) TypeTextDeprecated(ctx context.Context, sandboxId string) ToolboxAPITypeTextDeprecatedRequest {
	return ToolboxAPITypeTextDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) TypeTextDeprecatedExecute(r ToolboxAPITypeTextDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.TypeTextDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/keyboard/type"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.keyboardTypeRequest == nil {
		return nil, reportError("keyboardTypeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.keyboardTypeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIUploadFileDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	path *string
	xDaytonaOrganizationID *string
	file *os.File
}

func (r ToolboxAPIUploadFileDeprecatedRequest) Path(path string) ToolboxAPIUploadFileDeprecatedRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIUploadFileDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIUploadFileDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIUploadFileDeprecatedRequest) File(file *os.File) ToolboxAPIUploadFileDeprecatedRequest {
	r.file = file
	return r
}

func (r ToolboxAPIUploadFileDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.UploadFileDeprecatedExecute(r)
}

/*
UploadFileDeprecated [DEPRECATED] Upload file

Upload file inside sandbox

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIUploadFileDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) UploadFileDeprecated(ctx context.Context, sandboxId string) ToolboxAPIUploadFileDeprecatedRequest {
	return ToolboxAPIUploadFileDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) UploadFileDeprecatedExecute(r ToolboxAPIUploadFileDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.UploadFileDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files/upload"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIUploadFilesDeprecatedRequest struct {
	ctx context.Context
	ApiService ToolboxAPI
	sandboxId string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIUploadFilesDeprecatedRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIUploadFilesDeprecatedRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIUploadFilesDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.UploadFilesDeprecatedExecute(r)
}

/*
UploadFilesDeprecated [DEPRECATED] Upload multiple files

Upload multiple files inside sandbox

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sandboxId
 @return ToolboxAPIUploadFilesDeprecatedRequest

Deprecated
*/
func (a *ToolboxAPIService) UploadFilesDeprecated(ctx context.Context, sandboxId string) ToolboxAPIUploadFilesDeprecatedRequest {
	return ToolboxAPIUploadFilesDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		sandboxId: sandboxId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) UploadFilesDeprecatedExecute(r ToolboxAPIUploadFilesDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.UploadFilesDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files/bulk-upload"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
