/*
Daytona

Daytona AI platform API Docs

API version: 1.0
Contact: support@daytona.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apiclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

type ToolboxAPI interface {

	/*
		ClickMouse Click mouse

		Click mouse at specified coordinates

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIClickMouseRequest
	*/
	ClickMouse(ctx context.Context, sandboxId string) ToolboxAPIClickMouseRequest

	// ClickMouseExecute executes the request
	//  @return MouseClickResponse
	ClickMouseExecute(r ToolboxAPIClickMouseRequest) (*MouseClickResponse, *http.Response, error)

	/*
		CreateFolder Create folder

		Create folder inside sandbox

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPICreateFolderRequest
	*/
	CreateFolder(ctx context.Context, sandboxId string) ToolboxAPICreateFolderRequest

	// CreateFolderExecute executes the request
	CreateFolderExecute(r ToolboxAPICreateFolderRequest) (*http.Response, error)

	/*
		CreateSession Create session

		Create a new session in the sandbox

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPICreateSessionRequest
	*/
	CreateSession(ctx context.Context, sandboxId string) ToolboxAPICreateSessionRequest

	// CreateSessionExecute executes the request
	CreateSessionExecute(r ToolboxAPICreateSessionRequest) (*http.Response, error)

	/*
		DeleteFile Delete file

		Delete file inside sandbox

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIDeleteFileRequest
	*/
	DeleteFile(ctx context.Context, sandboxId string) ToolboxAPIDeleteFileRequest

	// DeleteFileExecute executes the request
	DeleteFileExecute(r ToolboxAPIDeleteFileRequest) (*http.Response, error)

	/*
		DeleteSession Delete session

		Delete a specific session

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@param sessionId
		@return ToolboxAPIDeleteSessionRequest
	*/
	DeleteSession(ctx context.Context, sandboxId string, sessionId string) ToolboxAPIDeleteSessionRequest

	// DeleteSessionExecute executes the request
	DeleteSessionExecute(r ToolboxAPIDeleteSessionRequest) (*http.Response, error)

	/*
		DownloadFile Download file

		Download file from sandbox

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIDownloadFileRequest
	*/
	DownloadFile(ctx context.Context, sandboxId string) ToolboxAPIDownloadFileRequest

	// DownloadFileExecute executes the request
	//  @return *os.File
	DownloadFileExecute(r ToolboxAPIDownloadFileRequest) (*os.File, *http.Response, error)

	/*
		DragMouse Drag mouse

		Drag mouse from start to end coordinates

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIDragMouseRequest
	*/
	DragMouse(ctx context.Context, sandboxId string) ToolboxAPIDragMouseRequest

	// DragMouseExecute executes the request
	//  @return MouseDragResponse
	DragMouseExecute(r ToolboxAPIDragMouseRequest) (*MouseDragResponse, *http.Response, error)

	/*
		ExecuteCommand Execute command

		Execute command synchronously inside sandbox

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIExecuteCommandRequest
	*/
	ExecuteCommand(ctx context.Context, sandboxId string) ToolboxAPIExecuteCommandRequest

	// ExecuteCommandExecute executes the request
	//  @return ExecuteResponse
	ExecuteCommandExecute(r ToolboxAPIExecuteCommandRequest) (*ExecuteResponse, *http.Response, error)

	/*
		ExecuteSessionCommand Execute command in session

		Execute a command in a specific session

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@param sessionId
		@return ToolboxAPIExecuteSessionCommandRequest
	*/
	ExecuteSessionCommand(ctx context.Context, sandboxId string, sessionId string) ToolboxAPIExecuteSessionCommandRequest

	// ExecuteSessionCommandExecute executes the request
	//  @return SessionExecuteResponse
	ExecuteSessionCommandExecute(r ToolboxAPIExecuteSessionCommandRequest) (*SessionExecuteResponse, *http.Response, error)

	/*
		FindInFiles Search for text/pattern in files

		Search for text/pattern inside sandbox files

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIFindInFilesRequest
	*/
	FindInFiles(ctx context.Context, sandboxId string) ToolboxAPIFindInFilesRequest

	// FindInFilesExecute executes the request
	//  @return []Match
	FindInFilesExecute(r ToolboxAPIFindInFilesRequest) ([]Match, *http.Response, error)

	/*
		GetComputerUseStatus Get computer use status

		Get status of all VNC desktop processes

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIGetComputerUseStatusRequest
	*/
	GetComputerUseStatus(ctx context.Context, sandboxId string) ToolboxAPIGetComputerUseStatusRequest

	// GetComputerUseStatusExecute executes the request
	//  @return ComputerUseStatusResponse
	GetComputerUseStatusExecute(r ToolboxAPIGetComputerUseStatusRequest) (*ComputerUseStatusResponse, *http.Response, error)

	/*
		GetDisplayInfo Get display info

		Get information about displays

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIGetDisplayInfoRequest
	*/
	GetDisplayInfo(ctx context.Context, sandboxId string) ToolboxAPIGetDisplayInfoRequest

	// GetDisplayInfoExecute executes the request
	//  @return DisplayInfoResponse
	GetDisplayInfoExecute(r ToolboxAPIGetDisplayInfoRequest) (*DisplayInfoResponse, *http.Response, error)

	/*
		GetFileInfo Get file info

		Get file info inside sandbox

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIGetFileInfoRequest
	*/
	GetFileInfo(ctx context.Context, sandboxId string) ToolboxAPIGetFileInfoRequest

	// GetFileInfoExecute executes the request
	//  @return FileInfo
	GetFileInfoExecute(r ToolboxAPIGetFileInfoRequest) (*FileInfo, *http.Response, error)

	/*
		GetMousePosition Get mouse position

		Get current mouse cursor position

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIGetMousePositionRequest
	*/
	GetMousePosition(ctx context.Context, sandboxId string) ToolboxAPIGetMousePositionRequest

	// GetMousePositionExecute executes the request
	//  @return MousePosition
	GetMousePositionExecute(r ToolboxAPIGetMousePositionRequest) (*MousePosition, *http.Response, error)

	/*
		GetProcessErrors Get process errors

		Get error logs for a specific VNC process

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param processName
		@param sandboxId
		@return ToolboxAPIGetProcessErrorsRequest
	*/
	GetProcessErrors(ctx context.Context, processName string, sandboxId string) ToolboxAPIGetProcessErrorsRequest

	// GetProcessErrorsExecute executes the request
	//  @return ProcessErrorsResponse
	GetProcessErrorsExecute(r ToolboxAPIGetProcessErrorsRequest) (*ProcessErrorsResponse, *http.Response, error)

	/*
		GetProcessLogs Get process logs

		Get logs for a specific VNC process

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param processName
		@param sandboxId
		@return ToolboxAPIGetProcessLogsRequest
	*/
	GetProcessLogs(ctx context.Context, processName string, sandboxId string) ToolboxAPIGetProcessLogsRequest

	// GetProcessLogsExecute executes the request
	//  @return ProcessLogsResponse
	GetProcessLogsExecute(r ToolboxAPIGetProcessLogsRequest) (*ProcessLogsResponse, *http.Response, error)

	/*
		GetProcessStatus Get process status

		Get status of a specific VNC process

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param processName
		@param sandboxId
		@return ToolboxAPIGetProcessStatusRequest
	*/
	GetProcessStatus(ctx context.Context, processName string, sandboxId string) ToolboxAPIGetProcessStatusRequest

	// GetProcessStatusExecute executes the request
	//  @return ProcessStatusResponse
	GetProcessStatusExecute(r ToolboxAPIGetProcessStatusRequest) (*ProcessStatusResponse, *http.Response, error)

	/*
		GetProjectDir Get sandbox project dir

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIGetProjectDirRequest
	*/
	GetProjectDir(ctx context.Context, sandboxId string) ToolboxAPIGetProjectDirRequest

	// GetProjectDirExecute executes the request
	//  @return ProjectDirResponse
	GetProjectDirExecute(r ToolboxAPIGetProjectDirRequest) (*ProjectDirResponse, *http.Response, error)

	/*
		GetSession Get session

		Get session by ID

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@param sessionId
		@return ToolboxAPIGetSessionRequest
	*/
	GetSession(ctx context.Context, sandboxId string, sessionId string) ToolboxAPIGetSessionRequest

	// GetSessionExecute executes the request
	//  @return Session
	GetSessionExecute(r ToolboxAPIGetSessionRequest) (*Session, *http.Response, error)

	/*
		GetSessionCommand Get session command

		Get session command by ID

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@param sessionId
		@param commandId
		@return ToolboxAPIGetSessionCommandRequest
	*/
	GetSessionCommand(ctx context.Context, sandboxId string, sessionId string, commandId string) ToolboxAPIGetSessionCommandRequest

	// GetSessionCommandExecute executes the request
	//  @return Command
	GetSessionCommandExecute(r ToolboxAPIGetSessionCommandRequest) (*Command, *http.Response, error)

	/*
		GetSessionCommandLogs Get command logs

		Get logs for a specific command in a session

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@param sessionId
		@param commandId
		@return ToolboxAPIGetSessionCommandLogsRequest
	*/
	GetSessionCommandLogs(ctx context.Context, sandboxId string, sessionId string, commandId string) ToolboxAPIGetSessionCommandLogsRequest

	// GetSessionCommandLogsExecute executes the request
	//  @return SessionCommandLogsResponse
	GetSessionCommandLogsExecute(r ToolboxAPIGetSessionCommandLogsRequest) (*SessionCommandLogsResponse, *http.Response, error)

	/*
		GetWindows Get windows

		Get list of open windows

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIGetWindowsRequest
	*/
	GetWindows(ctx context.Context, sandboxId string) ToolboxAPIGetWindowsRequest

	// GetWindowsExecute executes the request
	//  @return WindowsResponse
	GetWindowsExecute(r ToolboxAPIGetWindowsRequest) (*WindowsResponse, *http.Response, error)

	/*
		GitAddFiles Add files

		Add files to git commit

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIGitAddFilesRequest
	*/
	GitAddFiles(ctx context.Context, sandboxId string) ToolboxAPIGitAddFilesRequest

	// GitAddFilesExecute executes the request
	GitAddFilesExecute(r ToolboxAPIGitAddFilesRequest) (*http.Response, error)

	/*
		GitCheckoutBranch Checkout branch

		Checkout branch or commit in git repository

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIGitCheckoutBranchRequest
	*/
	GitCheckoutBranch(ctx context.Context, sandboxId string) ToolboxAPIGitCheckoutBranchRequest

	// GitCheckoutBranchExecute executes the request
	GitCheckoutBranchExecute(r ToolboxAPIGitCheckoutBranchRequest) (*http.Response, error)

	/*
		GitCloneRepository Clone repository

		Clone git repository

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIGitCloneRepositoryRequest
	*/
	GitCloneRepository(ctx context.Context, sandboxId string) ToolboxAPIGitCloneRepositoryRequest

	// GitCloneRepositoryExecute executes the request
	GitCloneRepositoryExecute(r ToolboxAPIGitCloneRepositoryRequest) (*http.Response, error)

	/*
		GitCommitChanges Commit changes

		Commit changes to git repository

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIGitCommitChangesRequest
	*/
	GitCommitChanges(ctx context.Context, sandboxId string) ToolboxAPIGitCommitChangesRequest

	// GitCommitChangesExecute executes the request
	//  @return GitCommitResponse
	GitCommitChangesExecute(r ToolboxAPIGitCommitChangesRequest) (*GitCommitResponse, *http.Response, error)

	/*
		GitCreateBranch Create branch

		Create branch on git repository

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIGitCreateBranchRequest
	*/
	GitCreateBranch(ctx context.Context, sandboxId string) ToolboxAPIGitCreateBranchRequest

	// GitCreateBranchExecute executes the request
	GitCreateBranchExecute(r ToolboxAPIGitCreateBranchRequest) (*http.Response, error)

	/*
		GitDeleteBranch Delete branch

		Delete branch on git repository

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIGitDeleteBranchRequest
	*/
	GitDeleteBranch(ctx context.Context, sandboxId string) ToolboxAPIGitDeleteBranchRequest

	// GitDeleteBranchExecute executes the request
	GitDeleteBranchExecute(r ToolboxAPIGitDeleteBranchRequest) (*http.Response, error)

	/*
		GitGetHistory Get commit history

		Get commit history from git repository

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIGitGetHistoryRequest
	*/
	GitGetHistory(ctx context.Context, sandboxId string) ToolboxAPIGitGetHistoryRequest

	// GitGetHistoryExecute executes the request
	//  @return []GitCommitInfo
	GitGetHistoryExecute(r ToolboxAPIGitGetHistoryRequest) ([]GitCommitInfo, *http.Response, error)

	/*
		GitGetStatus Get git status

		Get status from git repository

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIGitGetStatusRequest
	*/
	GitGetStatus(ctx context.Context, sandboxId string) ToolboxAPIGitGetStatusRequest

	// GitGetStatusExecute executes the request
	//  @return GitStatus
	GitGetStatusExecute(r ToolboxAPIGitGetStatusRequest) (*GitStatus, *http.Response, error)

	/*
		GitListBranches Get branch list

		Get branch list from git repository

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIGitListBranchesRequest
	*/
	GitListBranches(ctx context.Context, sandboxId string) ToolboxAPIGitListBranchesRequest

	// GitListBranchesExecute executes the request
	//  @return ListBranchResponse
	GitListBranchesExecute(r ToolboxAPIGitListBranchesRequest) (*ListBranchResponse, *http.Response, error)

	/*
		GitPullChanges Pull changes

		Pull changes from remote

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIGitPullChangesRequest
	*/
	GitPullChanges(ctx context.Context, sandboxId string) ToolboxAPIGitPullChangesRequest

	// GitPullChangesExecute executes the request
	GitPullChangesExecute(r ToolboxAPIGitPullChangesRequest) (*http.Response, error)

	/*
		GitPushChanges Push changes

		Push changes to remote

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIGitPushChangesRequest
	*/
	GitPushChanges(ctx context.Context, sandboxId string) ToolboxAPIGitPushChangesRequest

	// GitPushChangesExecute executes the request
	GitPushChangesExecute(r ToolboxAPIGitPushChangesRequest) (*http.Response, error)

	/*
		ListFiles List files

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIListFilesRequest
	*/
	ListFiles(ctx context.Context, sandboxId string) ToolboxAPIListFilesRequest

	// ListFilesExecute executes the request
	//  @return []FileInfo
	ListFilesExecute(r ToolboxAPIListFilesRequest) ([]FileInfo, *http.Response, error)

	/*
		ListSessions List sessions

		List all active sessions in the sandbox

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIListSessionsRequest
	*/
	ListSessions(ctx context.Context, sandboxId string) ToolboxAPIListSessionsRequest

	// ListSessionsExecute executes the request
	//  @return []Session
	ListSessionsExecute(r ToolboxAPIListSessionsRequest) ([]Session, *http.Response, error)

	/*
		LspCompletions Get Lsp Completions

		The Completion request is sent from the client to the server to compute completion items at a given cursor position.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPILspCompletionsRequest
	*/
	LspCompletions(ctx context.Context, sandboxId string) ToolboxAPILspCompletionsRequest

	// LspCompletionsExecute executes the request
	//  @return CompletionList
	LspCompletionsExecute(r ToolboxAPILspCompletionsRequest) (*CompletionList, *http.Response, error)

	/*
		LspDidClose Call Lsp DidClose

		The document close notification is sent from the client to the server when the document got closed in the client.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPILspDidCloseRequest
	*/
	LspDidClose(ctx context.Context, sandboxId string) ToolboxAPILspDidCloseRequest

	// LspDidCloseExecute executes the request
	LspDidCloseExecute(r ToolboxAPILspDidCloseRequest) (*http.Response, error)

	/*
		LspDidOpen Call Lsp DidOpen

		The document open notification is sent from the client to the server to signal newly opened text documents.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPILspDidOpenRequest
	*/
	LspDidOpen(ctx context.Context, sandboxId string) ToolboxAPILspDidOpenRequest

	// LspDidOpenExecute executes the request
	LspDidOpenExecute(r ToolboxAPILspDidOpenRequest) (*http.Response, error)

	/*
		LspDocumentSymbols Call Lsp DocumentSymbols

		The document symbol request is sent from the client to the server.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPILspDocumentSymbolsRequest
	*/
	LspDocumentSymbols(ctx context.Context, sandboxId string) ToolboxAPILspDocumentSymbolsRequest

	// LspDocumentSymbolsExecute executes the request
	//  @return []LspSymbol
	LspDocumentSymbolsExecute(r ToolboxAPILspDocumentSymbolsRequest) ([]LspSymbol, *http.Response, error)

	/*
		LspStart Start Lsp server

		Start Lsp server process inside sandbox project

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPILspStartRequest
	*/
	LspStart(ctx context.Context, sandboxId string) ToolboxAPILspStartRequest

	// LspStartExecute executes the request
	LspStartExecute(r ToolboxAPILspStartRequest) (*http.Response, error)

	/*
		LspStop Stop Lsp server

		Stop Lsp server process inside sandbox project

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPILspStopRequest
	*/
	LspStop(ctx context.Context, sandboxId string) ToolboxAPILspStopRequest

	// LspStopExecute executes the request
	LspStopExecute(r ToolboxAPILspStopRequest) (*http.Response, error)

	/*
		LspWorkspaceSymbols Call Lsp WorkspaceSymbols

		The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPILspWorkspaceSymbolsRequest
	*/
	LspWorkspaceSymbols(ctx context.Context, sandboxId string) ToolboxAPILspWorkspaceSymbolsRequest

	// LspWorkspaceSymbolsExecute executes the request
	//  @return []LspSymbol
	LspWorkspaceSymbolsExecute(r ToolboxAPILspWorkspaceSymbolsRequest) ([]LspSymbol, *http.Response, error)

	/*
		MoveFile Move file

		Move file inside sandbox

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIMoveFileRequest
	*/
	MoveFile(ctx context.Context, sandboxId string) ToolboxAPIMoveFileRequest

	// MoveFileExecute executes the request
	MoveFileExecute(r ToolboxAPIMoveFileRequest) (*http.Response, error)

	/*
		MoveMouse Move mouse

		Move mouse cursor to specified coordinates

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIMoveMouseRequest
	*/
	MoveMouse(ctx context.Context, sandboxId string) ToolboxAPIMoveMouseRequest

	// MoveMouseExecute executes the request
	//  @return MouseMoveResponse
	MoveMouseExecute(r ToolboxAPIMoveMouseRequest) (*MouseMoveResponse, *http.Response, error)

	/*
		PressHotkey Press hotkey

		Press a hotkey combination

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIPressHotkeyRequest
	*/
	PressHotkey(ctx context.Context, sandboxId string) ToolboxAPIPressHotkeyRequest

	// PressHotkeyExecute executes the request
	PressHotkeyExecute(r ToolboxAPIPressHotkeyRequest) (*http.Response, error)

	/*
		PressKey Press key

		Press a key with optional modifiers

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIPressKeyRequest
	*/
	PressKey(ctx context.Context, sandboxId string) ToolboxAPIPressKeyRequest

	// PressKeyExecute executes the request
	PressKeyExecute(r ToolboxAPIPressKeyRequest) (*http.Response, error)

	/*
		ReplaceInFiles Replace in files

		Replace text/pattern in multiple files inside sandbox

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIReplaceInFilesRequest
	*/
	ReplaceInFiles(ctx context.Context, sandboxId string) ToolboxAPIReplaceInFilesRequest

	// ReplaceInFilesExecute executes the request
	//  @return []ReplaceResult
	ReplaceInFilesExecute(r ToolboxAPIReplaceInFilesRequest) ([]ReplaceResult, *http.Response, error)

	/*
		RestartProcess Restart process

		Restart a specific VNC process

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param processName
		@param sandboxId
		@return ToolboxAPIRestartProcessRequest
	*/
	RestartProcess(ctx context.Context, processName string, sandboxId string) ToolboxAPIRestartProcessRequest

	// RestartProcessExecute executes the request
	//  @return ProcessRestartResponse
	RestartProcessExecute(r ToolboxAPIRestartProcessRequest) (*ProcessRestartResponse, *http.Response, error)

	/*
		ScrollMouse Scroll mouse

		Scroll mouse at specified coordinates

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIScrollMouseRequest
	*/
	ScrollMouse(ctx context.Context, sandboxId string) ToolboxAPIScrollMouseRequest

	// ScrollMouseExecute executes the request
	//  @return MouseScrollResponse
	ScrollMouseExecute(r ToolboxAPIScrollMouseRequest) (*MouseScrollResponse, *http.Response, error)

	/*
		SearchFiles Search files

		Search for files inside sandbox

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPISearchFilesRequest
	*/
	SearchFiles(ctx context.Context, sandboxId string) ToolboxAPISearchFilesRequest

	// SearchFilesExecute executes the request
	//  @return SearchFilesResponse
	SearchFilesExecute(r ToolboxAPISearchFilesRequest) (*SearchFilesResponse, *http.Response, error)

	/*
		SetFilePermissions Set file permissions

		Set file owner/group/permissions inside sandbox

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPISetFilePermissionsRequest
	*/
	SetFilePermissions(ctx context.Context, sandboxId string) ToolboxAPISetFilePermissionsRequest

	// SetFilePermissionsExecute executes the request
	SetFilePermissionsExecute(r ToolboxAPISetFilePermissionsRequest) (*http.Response, error)

	/*
		StartComputerUse Start computer use processes

		Start all VNC desktop processes (Xvfb, xfce4, x11vnc, novnc)

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIStartComputerUseRequest
	*/
	StartComputerUse(ctx context.Context, sandboxId string) ToolboxAPIStartComputerUseRequest

	// StartComputerUseExecute executes the request
	//  @return ComputerUseStartResponse
	StartComputerUseExecute(r ToolboxAPIStartComputerUseRequest) (*ComputerUseStartResponse, *http.Response, error)

	/*
		StopComputerUse Stop computer use processes

		Stop all VNC desktop processes (Xvfb, xfce4, x11vnc, novnc)

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIStopComputerUseRequest
	*/
	StopComputerUse(ctx context.Context, sandboxId string) ToolboxAPIStopComputerUseRequest

	// StopComputerUseExecute executes the request
	//  @return ComputerUseStopResponse
	StopComputerUseExecute(r ToolboxAPIStopComputerUseRequest) (*ComputerUseStopResponse, *http.Response, error)

	/*
		TakeCompressedRegionScreenshot Take compressed region screenshot

		Take a compressed screenshot of a specific region

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPITakeCompressedRegionScreenshotRequest
	*/
	TakeCompressedRegionScreenshot(ctx context.Context, sandboxId string) ToolboxAPITakeCompressedRegionScreenshotRequest

	// TakeCompressedRegionScreenshotExecute executes the request
	//  @return CompressedScreenshotResponse
	TakeCompressedRegionScreenshotExecute(r ToolboxAPITakeCompressedRegionScreenshotRequest) (*CompressedScreenshotResponse, *http.Response, error)

	/*
		TakeCompressedScreenshot Take compressed screenshot

		Take a compressed screenshot with format, quality, and scale options

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPITakeCompressedScreenshotRequest
	*/
	TakeCompressedScreenshot(ctx context.Context, sandboxId string) ToolboxAPITakeCompressedScreenshotRequest

	// TakeCompressedScreenshotExecute executes the request
	//  @return CompressedScreenshotResponse
	TakeCompressedScreenshotExecute(r ToolboxAPITakeCompressedScreenshotRequest) (*CompressedScreenshotResponse, *http.Response, error)

	/*
		TakeRegionScreenshot Take region screenshot

		Take a screenshot of a specific region

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPITakeRegionScreenshotRequest
	*/
	TakeRegionScreenshot(ctx context.Context, sandboxId string) ToolboxAPITakeRegionScreenshotRequest

	// TakeRegionScreenshotExecute executes the request
	//  @return RegionScreenshotResponse
	TakeRegionScreenshotExecute(r ToolboxAPITakeRegionScreenshotRequest) (*RegionScreenshotResponse, *http.Response, error)

	/*
		TakeScreenshot Take screenshot

		Take a screenshot of the entire screen

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPITakeScreenshotRequest
	*/
	TakeScreenshot(ctx context.Context, sandboxId string) ToolboxAPITakeScreenshotRequest

	// TakeScreenshotExecute executes the request
	//  @return ScreenshotResponse
	TakeScreenshotExecute(r ToolboxAPITakeScreenshotRequest) (*ScreenshotResponse, *http.Response, error)

	/*
		TypeText Type text

		Type text using keyboard

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPITypeTextRequest
	*/
	TypeText(ctx context.Context, sandboxId string) ToolboxAPITypeTextRequest

	// TypeTextExecute executes the request
	TypeTextExecute(r ToolboxAPITypeTextRequest) (*http.Response, error)

	/*
		UploadFile Upload file

		Upload file inside sandbox

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIUploadFileRequest

		Deprecated
	*/
	UploadFile(ctx context.Context, sandboxId string) ToolboxAPIUploadFileRequest

	// UploadFileExecute executes the request
	// Deprecated
	UploadFileExecute(r ToolboxAPIUploadFileRequest) (*http.Response, error)

	/*
		UploadFiles Upload multiple files

		Upload multiple files inside sandbox

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param sandboxId
		@return ToolboxAPIUploadFilesRequest
	*/
	UploadFiles(ctx context.Context, sandboxId string) ToolboxAPIUploadFilesRequest

	// UploadFilesExecute executes the request
	UploadFilesExecute(r ToolboxAPIUploadFilesRequest) (*http.Response, error)
}

// ToolboxAPIService ToolboxAPI service
type ToolboxAPIService service

type ToolboxAPIClickMouseRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	mouseClickRequest      *MouseClickRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIClickMouseRequest) MouseClickRequest(mouseClickRequest MouseClickRequest) ToolboxAPIClickMouseRequest {
	r.mouseClickRequest = &mouseClickRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIClickMouseRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIClickMouseRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIClickMouseRequest) Execute() (*MouseClickResponse, *http.Response, error) {
	return r.ApiService.ClickMouseExecute(r)
}

/*
ClickMouse Click mouse

Click mouse at specified coordinates

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIClickMouseRequest
*/
func (a *ToolboxAPIService) ClickMouse(ctx context.Context, sandboxId string) ToolboxAPIClickMouseRequest {
	return ToolboxAPIClickMouseRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return MouseClickResponse
func (a *ToolboxAPIService) ClickMouseExecute(r ToolboxAPIClickMouseRequest) (*MouseClickResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MouseClickResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.ClickMouse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/mouse/click"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mouseClickRequest == nil {
		return localVarReturnValue, nil, reportError("mouseClickRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.mouseClickRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPICreateFolderRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	path                   *string
	mode                   *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPICreateFolderRequest) Path(path string) ToolboxAPICreateFolderRequest {
	r.path = &path
	return r
}

func (r ToolboxAPICreateFolderRequest) Mode(mode string) ToolboxAPICreateFolderRequest {
	r.mode = &mode
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPICreateFolderRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPICreateFolderRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPICreateFolderRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateFolderExecute(r)
}

/*
CreateFolder Create folder

Create folder inside sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPICreateFolderRequest
*/
func (a *ToolboxAPIService) CreateFolder(ctx context.Context, sandboxId string) ToolboxAPICreateFolderRequest {
	return ToolboxAPICreateFolderRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) CreateFolderExecute(r ToolboxAPICreateFolderRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.CreateFolder")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files/folder"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return nil, reportError("path is required and must be specified")
	}
	if r.mode == nil {
		return nil, reportError("mode is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPICreateSessionRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	createSessionRequest   *CreateSessionRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPICreateSessionRequest) CreateSessionRequest(createSessionRequest CreateSessionRequest) ToolboxAPICreateSessionRequest {
	r.createSessionRequest = &createSessionRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPICreateSessionRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPICreateSessionRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPICreateSessionRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateSessionExecute(r)
}

/*
CreateSession Create session

Create a new session in the sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPICreateSessionRequest
*/
func (a *ToolboxAPIService) CreateSession(ctx context.Context, sandboxId string) ToolboxAPICreateSessionRequest {
	return ToolboxAPICreateSessionRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) CreateSessionExecute(r ToolboxAPICreateSessionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.CreateSession")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/process/session"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createSessionRequest == nil {
		return nil, reportError("createSessionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.createSessionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIDeleteFileRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	path                   *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIDeleteFileRequest) Path(path string) ToolboxAPIDeleteFileRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIDeleteFileRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIDeleteFileRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIDeleteFileRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFileExecute(r)
}

/*
DeleteFile Delete file

Delete file inside sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIDeleteFileRequest
*/
func (a *ToolboxAPIService) DeleteFile(ctx context.Context, sandboxId string) ToolboxAPIDeleteFileRequest {
	return ToolboxAPIDeleteFileRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) DeleteFileExecute(r ToolboxAPIDeleteFileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.DeleteFile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIDeleteSessionRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	sessionId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIDeleteSessionRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIDeleteSessionRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIDeleteSessionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSessionExecute(r)
}

/*
DeleteSession Delete session

Delete a specific session

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@param sessionId
	@return ToolboxAPIDeleteSessionRequest
*/
func (a *ToolboxAPIService) DeleteSession(ctx context.Context, sandboxId string, sessionId string) ToolboxAPIDeleteSessionRequest {
	return ToolboxAPIDeleteSessionRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
		sessionId:  sessionId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) DeleteSessionExecute(r ToolboxAPIDeleteSessionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.DeleteSession")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/process/session/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIDownloadFileRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	path                   *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIDownloadFileRequest) Path(path string) ToolboxAPIDownloadFileRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIDownloadFileRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIDownloadFileRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIDownloadFileRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.DownloadFileExecute(r)
}

/*
DownloadFile Download file

Download file from sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIDownloadFileRequest
*/
func (a *ToolboxAPIService) DownloadFile(ctx context.Context, sandboxId string) ToolboxAPIDownloadFileRequest {
	return ToolboxAPIDownloadFileRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *ToolboxAPIService) DownloadFileExecute(r ToolboxAPIDownloadFileRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.DownloadFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files/download"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIDragMouseRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	mouseDragRequest       *MouseDragRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIDragMouseRequest) MouseDragRequest(mouseDragRequest MouseDragRequest) ToolboxAPIDragMouseRequest {
	r.mouseDragRequest = &mouseDragRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIDragMouseRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIDragMouseRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIDragMouseRequest) Execute() (*MouseDragResponse, *http.Response, error) {
	return r.ApiService.DragMouseExecute(r)
}

/*
DragMouse Drag mouse

Drag mouse from start to end coordinates

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIDragMouseRequest
*/
func (a *ToolboxAPIService) DragMouse(ctx context.Context, sandboxId string) ToolboxAPIDragMouseRequest {
	return ToolboxAPIDragMouseRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return MouseDragResponse
func (a *ToolboxAPIService) DragMouseExecute(r ToolboxAPIDragMouseRequest) (*MouseDragResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MouseDragResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.DragMouse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/mouse/drag"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mouseDragRequest == nil {
		return localVarReturnValue, nil, reportError("mouseDragRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.mouseDragRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIExecuteCommandRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	executeRequest         *ExecuteRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIExecuteCommandRequest) ExecuteRequest(executeRequest ExecuteRequest) ToolboxAPIExecuteCommandRequest {
	r.executeRequest = &executeRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIExecuteCommandRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIExecuteCommandRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIExecuteCommandRequest) Execute() (*ExecuteResponse, *http.Response, error) {
	return r.ApiService.ExecuteCommandExecute(r)
}

/*
ExecuteCommand Execute command

Execute command synchronously inside sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIExecuteCommandRequest
*/
func (a *ToolboxAPIService) ExecuteCommand(ctx context.Context, sandboxId string) ToolboxAPIExecuteCommandRequest {
	return ToolboxAPIExecuteCommandRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return ExecuteResponse
func (a *ToolboxAPIService) ExecuteCommandExecute(r ToolboxAPIExecuteCommandRequest) (*ExecuteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExecuteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.ExecuteCommand")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/process/execute"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.executeRequest == nil {
		return localVarReturnValue, nil, reportError("executeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.executeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIExecuteSessionCommandRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	sessionId              string
	sessionExecuteRequest  *SessionExecuteRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIExecuteSessionCommandRequest) SessionExecuteRequest(sessionExecuteRequest SessionExecuteRequest) ToolboxAPIExecuteSessionCommandRequest {
	r.sessionExecuteRequest = &sessionExecuteRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIExecuteSessionCommandRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIExecuteSessionCommandRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIExecuteSessionCommandRequest) Execute() (*SessionExecuteResponse, *http.Response, error) {
	return r.ApiService.ExecuteSessionCommandExecute(r)
}

/*
ExecuteSessionCommand Execute command in session

Execute a command in a specific session

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@param sessionId
	@return ToolboxAPIExecuteSessionCommandRequest
*/
func (a *ToolboxAPIService) ExecuteSessionCommand(ctx context.Context, sandboxId string, sessionId string) ToolboxAPIExecuteSessionCommandRequest {
	return ToolboxAPIExecuteSessionCommandRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
		sessionId:  sessionId,
	}
}

// Execute executes the request
//
//	@return SessionExecuteResponse
func (a *ToolboxAPIService) ExecuteSessionCommandExecute(r ToolboxAPIExecuteSessionCommandRequest) (*SessionExecuteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SessionExecuteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.ExecuteSessionCommand")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/process/session/{sessionId}/exec"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionExecuteRequest == nil {
		return localVarReturnValue, nil, reportError("sessionExecuteRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.sessionExecuteRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIFindInFilesRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	path                   *string
	pattern                *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIFindInFilesRequest) Path(path string) ToolboxAPIFindInFilesRequest {
	r.path = &path
	return r
}

func (r ToolboxAPIFindInFilesRequest) Pattern(pattern string) ToolboxAPIFindInFilesRequest {
	r.pattern = &pattern
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIFindInFilesRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIFindInFilesRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIFindInFilesRequest) Execute() ([]Match, *http.Response, error) {
	return r.ApiService.FindInFilesExecute(r)
}

/*
FindInFiles Search for text/pattern in files

Search for text/pattern inside sandbox files

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIFindInFilesRequest
*/
func (a *ToolboxAPIService) FindInFiles(ctx context.Context, sandboxId string) ToolboxAPIFindInFilesRequest {
	return ToolboxAPIFindInFilesRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return []Match
func (a *ToolboxAPIService) FindInFilesExecute(r ToolboxAPIFindInFilesRequest) ([]Match, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Match
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.FindInFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files/find"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}
	if r.pattern == nil {
		return localVarReturnValue, nil, reportError("pattern is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pattern", r.pattern, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetComputerUseStatusRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetComputerUseStatusRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetComputerUseStatusRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetComputerUseStatusRequest) Execute() (*ComputerUseStatusResponse, *http.Response, error) {
	return r.ApiService.GetComputerUseStatusExecute(r)
}

/*
GetComputerUseStatus Get computer use status

Get status of all VNC desktop processes

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGetComputerUseStatusRequest
*/
func (a *ToolboxAPIService) GetComputerUseStatus(ctx context.Context, sandboxId string) ToolboxAPIGetComputerUseStatusRequest {
	return ToolboxAPIGetComputerUseStatusRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return ComputerUseStatusResponse
func (a *ToolboxAPIService) GetComputerUseStatusExecute(r ToolboxAPIGetComputerUseStatusRequest) (*ComputerUseStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ComputerUseStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetComputerUseStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/status"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetDisplayInfoRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetDisplayInfoRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetDisplayInfoRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetDisplayInfoRequest) Execute() (*DisplayInfoResponse, *http.Response, error) {
	return r.ApiService.GetDisplayInfoExecute(r)
}

/*
GetDisplayInfo Get display info

Get information about displays

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGetDisplayInfoRequest
*/
func (a *ToolboxAPIService) GetDisplayInfo(ctx context.Context, sandboxId string) ToolboxAPIGetDisplayInfoRequest {
	return ToolboxAPIGetDisplayInfoRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return DisplayInfoResponse
func (a *ToolboxAPIService) GetDisplayInfoExecute(r ToolboxAPIGetDisplayInfoRequest) (*DisplayInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DisplayInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetDisplayInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/display/info"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetFileInfoRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	path                   *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGetFileInfoRequest) Path(path string) ToolboxAPIGetFileInfoRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetFileInfoRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetFileInfoRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetFileInfoRequest) Execute() (*FileInfo, *http.Response, error) {
	return r.ApiService.GetFileInfoExecute(r)
}

/*
GetFileInfo Get file info

Get file info inside sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGetFileInfoRequest
*/
func (a *ToolboxAPIService) GetFileInfo(ctx context.Context, sandboxId string) ToolboxAPIGetFileInfoRequest {
	return ToolboxAPIGetFileInfoRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return FileInfo
func (a *ToolboxAPIService) GetFileInfoExecute(r ToolboxAPIGetFileInfoRequest) (*FileInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FileInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetFileInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files/info"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetMousePositionRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetMousePositionRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetMousePositionRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetMousePositionRequest) Execute() (*MousePosition, *http.Response, error) {
	return r.ApiService.GetMousePositionExecute(r)
}

/*
GetMousePosition Get mouse position

Get current mouse cursor position

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGetMousePositionRequest
*/
func (a *ToolboxAPIService) GetMousePosition(ctx context.Context, sandboxId string) ToolboxAPIGetMousePositionRequest {
	return ToolboxAPIGetMousePositionRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return MousePosition
func (a *ToolboxAPIService) GetMousePositionExecute(r ToolboxAPIGetMousePositionRequest) (*MousePosition, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MousePosition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetMousePosition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/mouse/position"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetProcessErrorsRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	processName            string
	sandboxId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetProcessErrorsRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetProcessErrorsRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetProcessErrorsRequest) Execute() (*ProcessErrorsResponse, *http.Response, error) {
	return r.ApiService.GetProcessErrorsExecute(r)
}

/*
GetProcessErrors Get process errors

Get error logs for a specific VNC process

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param processName
	@param sandboxId
	@return ToolboxAPIGetProcessErrorsRequest
*/
func (a *ToolboxAPIService) GetProcessErrors(ctx context.Context, processName string, sandboxId string) ToolboxAPIGetProcessErrorsRequest {
	return ToolboxAPIGetProcessErrorsRequest{
		ApiService:  a,
		ctx:         ctx,
		processName: processName,
		sandboxId:   sandboxId,
	}
}

// Execute executes the request
//
//	@return ProcessErrorsResponse
func (a *ToolboxAPIService) GetProcessErrorsExecute(r ToolboxAPIGetProcessErrorsRequest) (*ProcessErrorsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProcessErrorsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetProcessErrors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/process/{processName}/errors"
	localVarPath = strings.Replace(localVarPath, "{"+"processName"+"}", url.PathEscape(parameterValueToString(r.processName, "processName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetProcessLogsRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	processName            string
	sandboxId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetProcessLogsRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetProcessLogsRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetProcessLogsRequest) Execute() (*ProcessLogsResponse, *http.Response, error) {
	return r.ApiService.GetProcessLogsExecute(r)
}

/*
GetProcessLogs Get process logs

Get logs for a specific VNC process

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param processName
	@param sandboxId
	@return ToolboxAPIGetProcessLogsRequest
*/
func (a *ToolboxAPIService) GetProcessLogs(ctx context.Context, processName string, sandboxId string) ToolboxAPIGetProcessLogsRequest {
	return ToolboxAPIGetProcessLogsRequest{
		ApiService:  a,
		ctx:         ctx,
		processName: processName,
		sandboxId:   sandboxId,
	}
}

// Execute executes the request
//
//	@return ProcessLogsResponse
func (a *ToolboxAPIService) GetProcessLogsExecute(r ToolboxAPIGetProcessLogsRequest) (*ProcessLogsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProcessLogsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetProcessLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/process/{processName}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"processName"+"}", url.PathEscape(parameterValueToString(r.processName, "processName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetProcessStatusRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	processName            string
	sandboxId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetProcessStatusRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetProcessStatusRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetProcessStatusRequest) Execute() (*ProcessStatusResponse, *http.Response, error) {
	return r.ApiService.GetProcessStatusExecute(r)
}

/*
GetProcessStatus Get process status

Get status of a specific VNC process

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param processName
	@param sandboxId
	@return ToolboxAPIGetProcessStatusRequest
*/
func (a *ToolboxAPIService) GetProcessStatus(ctx context.Context, processName string, sandboxId string) ToolboxAPIGetProcessStatusRequest {
	return ToolboxAPIGetProcessStatusRequest{
		ApiService:  a,
		ctx:         ctx,
		processName: processName,
		sandboxId:   sandboxId,
	}
}

// Execute executes the request
//
//	@return ProcessStatusResponse
func (a *ToolboxAPIService) GetProcessStatusExecute(r ToolboxAPIGetProcessStatusRequest) (*ProcessStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProcessStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetProcessStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/process/{processName}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"processName"+"}", url.PathEscape(parameterValueToString(r.processName, "processName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetProjectDirRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetProjectDirRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetProjectDirRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetProjectDirRequest) Execute() (*ProjectDirResponse, *http.Response, error) {
	return r.ApiService.GetProjectDirExecute(r)
}

/*
GetProjectDir Get sandbox project dir

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGetProjectDirRequest
*/
func (a *ToolboxAPIService) GetProjectDir(ctx context.Context, sandboxId string) ToolboxAPIGetProjectDirRequest {
	return ToolboxAPIGetProjectDirRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return ProjectDirResponse
func (a *ToolboxAPIService) GetProjectDirExecute(r ToolboxAPIGetProjectDirRequest) (*ProjectDirResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProjectDirResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetProjectDir")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/project-dir"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetSessionRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	sessionId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetSessionRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetSessionRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetSessionRequest) Execute() (*Session, *http.Response, error) {
	return r.ApiService.GetSessionExecute(r)
}

/*
GetSession Get session

Get session by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@param sessionId
	@return ToolboxAPIGetSessionRequest
*/
func (a *ToolboxAPIService) GetSession(ctx context.Context, sandboxId string, sessionId string) ToolboxAPIGetSessionRequest {
	return ToolboxAPIGetSessionRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
		sessionId:  sessionId,
	}
}

// Execute executes the request
//
//	@return Session
func (a *ToolboxAPIService) GetSessionExecute(r ToolboxAPIGetSessionRequest) (*Session, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Session
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/process/session/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetSessionCommandRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	sessionId              string
	commandId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetSessionCommandRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetSessionCommandRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetSessionCommandRequest) Execute() (*Command, *http.Response, error) {
	return r.ApiService.GetSessionCommandExecute(r)
}

/*
GetSessionCommand Get session command

Get session command by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@param sessionId
	@param commandId
	@return ToolboxAPIGetSessionCommandRequest
*/
func (a *ToolboxAPIService) GetSessionCommand(ctx context.Context, sandboxId string, sessionId string, commandId string) ToolboxAPIGetSessionCommandRequest {
	return ToolboxAPIGetSessionCommandRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
		sessionId:  sessionId,
		commandId:  commandId,
	}
}

// Execute executes the request
//
//	@return Command
func (a *ToolboxAPIService) GetSessionCommandExecute(r ToolboxAPIGetSessionCommandRequest) (*Command, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Command
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetSessionCommand")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/process/session/{sessionId}/command/{commandId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commandId"+"}", url.PathEscape(parameterValueToString(r.commandId, "commandId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetSessionCommandLogsRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	sessionId              string
	commandId              string
	xDaytonaOrganizationID *string
	follow                 *bool
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetSessionCommandLogsRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetSessionCommandLogsRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

// Whether to stream the logs
func (r ToolboxAPIGetSessionCommandLogsRequest) Follow(follow bool) ToolboxAPIGetSessionCommandLogsRequest {
	r.follow = &follow
	return r
}

func (r ToolboxAPIGetSessionCommandLogsRequest) Execute() (*SessionCommandLogsResponse, *http.Response, error) {
	return r.ApiService.GetSessionCommandLogsExecute(r)
}

/*
GetSessionCommandLogs Get command logs

Get logs for a specific command in a session

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@param sessionId
	@param commandId
	@return ToolboxAPIGetSessionCommandLogsRequest
*/
func (a *ToolboxAPIService) GetSessionCommandLogs(ctx context.Context, sandboxId string, sessionId string, commandId string) ToolboxAPIGetSessionCommandLogsRequest {
	return ToolboxAPIGetSessionCommandLogsRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
		sessionId:  sessionId,
		commandId:  commandId,
	}
}

// Execute executes the request
//
//	@return SessionCommandLogsResponse
func (a *ToolboxAPIService) GetSessionCommandLogsExecute(r ToolboxAPIGetSessionCommandLogsRequest) (*SessionCommandLogsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SessionCommandLogsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetSessionCommandLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/process/session/{sessionId}/command/{commandId}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commandId"+"}", url.PathEscape(parameterValueToString(r.commandId, "commandId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.follow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "follow", r.follow, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetWindowsRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetWindowsRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetWindowsRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetWindowsRequest) Execute() (*WindowsResponse, *http.Response, error) {
	return r.ApiService.GetWindowsExecute(r)
}

/*
GetWindows Get windows

Get list of open windows

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGetWindowsRequest
*/
func (a *ToolboxAPIService) GetWindows(ctx context.Context, sandboxId string) ToolboxAPIGetWindowsRequest {
	return ToolboxAPIGetWindowsRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return WindowsResponse
func (a *ToolboxAPIService) GetWindowsExecute(r ToolboxAPIGetWindowsRequest) (*WindowsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WindowsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetWindows")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/display/windows"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGitAddFilesRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	gitAddRequest          *GitAddRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitAddFilesRequest) GitAddRequest(gitAddRequest GitAddRequest) ToolboxAPIGitAddFilesRequest {
	r.gitAddRequest = &gitAddRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitAddFilesRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitAddFilesRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitAddFilesRequest) Execute() (*http.Response, error) {
	return r.ApiService.GitAddFilesExecute(r)
}

/*
GitAddFiles Add files

Add files to git commit

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGitAddFilesRequest
*/
func (a *ToolboxAPIService) GitAddFiles(ctx context.Context, sandboxId string) ToolboxAPIGitAddFilesRequest {
	return ToolboxAPIGitAddFilesRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) GitAddFilesExecute(r ToolboxAPIGitAddFilesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitAddFiles")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/git/add"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitAddRequest == nil {
		return nil, reportError("gitAddRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.gitAddRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIGitCheckoutBranchRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	gitCheckoutRequest     *GitCheckoutRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitCheckoutBranchRequest) GitCheckoutRequest(gitCheckoutRequest GitCheckoutRequest) ToolboxAPIGitCheckoutBranchRequest {
	r.gitCheckoutRequest = &gitCheckoutRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitCheckoutBranchRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitCheckoutBranchRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitCheckoutBranchRequest) Execute() (*http.Response, error) {
	return r.ApiService.GitCheckoutBranchExecute(r)
}

/*
GitCheckoutBranch Checkout branch

Checkout branch or commit in git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGitCheckoutBranchRequest
*/
func (a *ToolboxAPIService) GitCheckoutBranch(ctx context.Context, sandboxId string) ToolboxAPIGitCheckoutBranchRequest {
	return ToolboxAPIGitCheckoutBranchRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) GitCheckoutBranchExecute(r ToolboxAPIGitCheckoutBranchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitCheckoutBranch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/git/checkout"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitCheckoutRequest == nil {
		return nil, reportError("gitCheckoutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.gitCheckoutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIGitCloneRepositoryRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	gitCloneRequest        *GitCloneRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitCloneRepositoryRequest) GitCloneRequest(gitCloneRequest GitCloneRequest) ToolboxAPIGitCloneRepositoryRequest {
	r.gitCloneRequest = &gitCloneRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitCloneRepositoryRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitCloneRepositoryRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitCloneRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.GitCloneRepositoryExecute(r)
}

/*
GitCloneRepository Clone repository

Clone git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGitCloneRepositoryRequest
*/
func (a *ToolboxAPIService) GitCloneRepository(ctx context.Context, sandboxId string) ToolboxAPIGitCloneRepositoryRequest {
	return ToolboxAPIGitCloneRepositoryRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) GitCloneRepositoryExecute(r ToolboxAPIGitCloneRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitCloneRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/git/clone"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitCloneRequest == nil {
		return nil, reportError("gitCloneRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.gitCloneRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIGitCommitChangesRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	gitCommitRequest       *GitCommitRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitCommitChangesRequest) GitCommitRequest(gitCommitRequest GitCommitRequest) ToolboxAPIGitCommitChangesRequest {
	r.gitCommitRequest = &gitCommitRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitCommitChangesRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitCommitChangesRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitCommitChangesRequest) Execute() (*GitCommitResponse, *http.Response, error) {
	return r.ApiService.GitCommitChangesExecute(r)
}

/*
GitCommitChanges Commit changes

Commit changes to git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGitCommitChangesRequest
*/
func (a *ToolboxAPIService) GitCommitChanges(ctx context.Context, sandboxId string) ToolboxAPIGitCommitChangesRequest {
	return ToolboxAPIGitCommitChangesRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return GitCommitResponse
func (a *ToolboxAPIService) GitCommitChangesExecute(r ToolboxAPIGitCommitChangesRequest) (*GitCommitResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GitCommitResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitCommitChanges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/git/commit"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitCommitRequest == nil {
		return localVarReturnValue, nil, reportError("gitCommitRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.gitCommitRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGitCreateBranchRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	gitBranchRequest       *GitBranchRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitCreateBranchRequest) GitBranchRequest(gitBranchRequest GitBranchRequest) ToolboxAPIGitCreateBranchRequest {
	r.gitBranchRequest = &gitBranchRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitCreateBranchRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitCreateBranchRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitCreateBranchRequest) Execute() (*http.Response, error) {
	return r.ApiService.GitCreateBranchExecute(r)
}

/*
GitCreateBranch Create branch

Create branch on git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGitCreateBranchRequest
*/
func (a *ToolboxAPIService) GitCreateBranch(ctx context.Context, sandboxId string) ToolboxAPIGitCreateBranchRequest {
	return ToolboxAPIGitCreateBranchRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) GitCreateBranchExecute(r ToolboxAPIGitCreateBranchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitCreateBranch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/git/branches"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitBranchRequest == nil {
		return nil, reportError("gitBranchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.gitBranchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIGitDeleteBranchRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	gitDeleteBranchRequest *GitDeleteBranchRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitDeleteBranchRequest) GitDeleteBranchRequest(gitDeleteBranchRequest GitDeleteBranchRequest) ToolboxAPIGitDeleteBranchRequest {
	r.gitDeleteBranchRequest = &gitDeleteBranchRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitDeleteBranchRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitDeleteBranchRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitDeleteBranchRequest) Execute() (*http.Response, error) {
	return r.ApiService.GitDeleteBranchExecute(r)
}

/*
GitDeleteBranch Delete branch

Delete branch on git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGitDeleteBranchRequest
*/
func (a *ToolboxAPIService) GitDeleteBranch(ctx context.Context, sandboxId string) ToolboxAPIGitDeleteBranchRequest {
	return ToolboxAPIGitDeleteBranchRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) GitDeleteBranchExecute(r ToolboxAPIGitDeleteBranchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitDeleteBranch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/git/branches"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitDeleteBranchRequest == nil {
		return nil, reportError("gitDeleteBranchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.gitDeleteBranchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIGitGetHistoryRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	path                   *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitGetHistoryRequest) Path(path string) ToolboxAPIGitGetHistoryRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitGetHistoryRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitGetHistoryRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitGetHistoryRequest) Execute() ([]GitCommitInfo, *http.Response, error) {
	return r.ApiService.GitGetHistoryExecute(r)
}

/*
GitGetHistory Get commit history

Get commit history from git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGitGetHistoryRequest
*/
func (a *ToolboxAPIService) GitGetHistory(ctx context.Context, sandboxId string) ToolboxAPIGitGetHistoryRequest {
	return ToolboxAPIGitGetHistoryRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return []GitCommitInfo
func (a *ToolboxAPIService) GitGetHistoryExecute(r ToolboxAPIGitGetHistoryRequest) ([]GitCommitInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []GitCommitInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitGetHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/git/history"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGitGetStatusRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	path                   *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitGetStatusRequest) Path(path string) ToolboxAPIGitGetStatusRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitGetStatusRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitGetStatusRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitGetStatusRequest) Execute() (*GitStatus, *http.Response, error) {
	return r.ApiService.GitGetStatusExecute(r)
}

/*
GitGetStatus Get git status

Get status from git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGitGetStatusRequest
*/
func (a *ToolboxAPIService) GitGetStatus(ctx context.Context, sandboxId string) ToolboxAPIGitGetStatusRequest {
	return ToolboxAPIGitGetStatusRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return GitStatus
func (a *ToolboxAPIService) GitGetStatusExecute(r ToolboxAPIGitGetStatusRequest) (*GitStatus, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GitStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitGetStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/git/status"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGitListBranchesRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	path                   *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitListBranchesRequest) Path(path string) ToolboxAPIGitListBranchesRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitListBranchesRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitListBranchesRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitListBranchesRequest) Execute() (*ListBranchResponse, *http.Response, error) {
	return r.ApiService.GitListBranchesExecute(r)
}

/*
GitListBranches Get branch list

Get branch list from git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGitListBranchesRequest
*/
func (a *ToolboxAPIService) GitListBranches(ctx context.Context, sandboxId string) ToolboxAPIGitListBranchesRequest {
	return ToolboxAPIGitListBranchesRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return ListBranchResponse
func (a *ToolboxAPIService) GitListBranchesExecute(r ToolboxAPIGitListBranchesRequest) (*ListBranchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListBranchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitListBranches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/git/branches"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGitPullChangesRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	gitRepoRequest         *GitRepoRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitPullChangesRequest) GitRepoRequest(gitRepoRequest GitRepoRequest) ToolboxAPIGitPullChangesRequest {
	r.gitRepoRequest = &gitRepoRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitPullChangesRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitPullChangesRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitPullChangesRequest) Execute() (*http.Response, error) {
	return r.ApiService.GitPullChangesExecute(r)
}

/*
GitPullChanges Pull changes

Pull changes from remote

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGitPullChangesRequest
*/
func (a *ToolboxAPIService) GitPullChanges(ctx context.Context, sandboxId string) ToolboxAPIGitPullChangesRequest {
	return ToolboxAPIGitPullChangesRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) GitPullChangesExecute(r ToolboxAPIGitPullChangesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitPullChanges")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/git/pull"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitRepoRequest == nil {
		return nil, reportError("gitRepoRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.gitRepoRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIGitPushChangesRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	gitRepoRequest         *GitRepoRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitPushChangesRequest) GitRepoRequest(gitRepoRequest GitRepoRequest) ToolboxAPIGitPushChangesRequest {
	r.gitRepoRequest = &gitRepoRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitPushChangesRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitPushChangesRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitPushChangesRequest) Execute() (*http.Response, error) {
	return r.ApiService.GitPushChangesExecute(r)
}

/*
GitPushChanges Push changes

Push changes to remote

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIGitPushChangesRequest
*/
func (a *ToolboxAPIService) GitPushChanges(ctx context.Context, sandboxId string) ToolboxAPIGitPushChangesRequest {
	return ToolboxAPIGitPushChangesRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) GitPushChangesExecute(r ToolboxAPIGitPushChangesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitPushChanges")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/git/push"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitRepoRequest == nil {
		return nil, reportError("gitRepoRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.gitRepoRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIListFilesRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	xDaytonaOrganizationID *string
	path                   *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIListFilesRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIListFilesRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIListFilesRequest) Path(path string) ToolboxAPIListFilesRequest {
	r.path = &path
	return r
}

func (r ToolboxAPIListFilesRequest) Execute() ([]FileInfo, *http.Response, error) {
	return r.ApiService.ListFilesExecute(r)
}

/*
ListFiles List files

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIListFilesRequest
*/
func (a *ToolboxAPIService) ListFiles(ctx context.Context, sandboxId string) ToolboxAPIListFilesRequest {
	return ToolboxAPIListFilesRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return []FileInfo
func (a *ToolboxAPIService) ListFilesExecute(r ToolboxAPIListFilesRequest) ([]FileInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []FileInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.ListFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIListSessionsRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIListSessionsRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIListSessionsRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIListSessionsRequest) Execute() ([]Session, *http.Response, error) {
	return r.ApiService.ListSessionsExecute(r)
}

/*
ListSessions List sessions

List all active sessions in the sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIListSessionsRequest
*/
func (a *ToolboxAPIService) ListSessions(ctx context.Context, sandboxId string) ToolboxAPIListSessionsRequest {
	return ToolboxAPIListSessionsRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return []Session
func (a *ToolboxAPIService) ListSessionsExecute(r ToolboxAPIListSessionsRequest) ([]Session, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Session
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.ListSessions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/process/session"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPILspCompletionsRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	lspCompletionParams    *LspCompletionParams
	xDaytonaOrganizationID *string
}

func (r ToolboxAPILspCompletionsRequest) LspCompletionParams(lspCompletionParams LspCompletionParams) ToolboxAPILspCompletionsRequest {
	r.lspCompletionParams = &lspCompletionParams
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPILspCompletionsRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPILspCompletionsRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPILspCompletionsRequest) Execute() (*CompletionList, *http.Response, error) {
	return r.ApiService.LspCompletionsExecute(r)
}

/*
LspCompletions Get Lsp Completions

The Completion request is sent from the client to the server to compute completion items at a given cursor position.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPILspCompletionsRequest
*/
func (a *ToolboxAPIService) LspCompletions(ctx context.Context, sandboxId string) ToolboxAPILspCompletionsRequest {
	return ToolboxAPILspCompletionsRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return CompletionList
func (a *ToolboxAPIService) LspCompletionsExecute(r ToolboxAPILspCompletionsRequest) (*CompletionList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CompletionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.LspCompletions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/lsp/completions"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lspCompletionParams == nil {
		return localVarReturnValue, nil, reportError("lspCompletionParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.lspCompletionParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPILspDidCloseRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	lspDocumentRequest     *LspDocumentRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPILspDidCloseRequest) LspDocumentRequest(lspDocumentRequest LspDocumentRequest) ToolboxAPILspDidCloseRequest {
	r.lspDocumentRequest = &lspDocumentRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPILspDidCloseRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPILspDidCloseRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPILspDidCloseRequest) Execute() (*http.Response, error) {
	return r.ApiService.LspDidCloseExecute(r)
}

/*
LspDidClose Call Lsp DidClose

The document close notification is sent from the client to the server when the document got closed in the client.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPILspDidCloseRequest
*/
func (a *ToolboxAPIService) LspDidClose(ctx context.Context, sandboxId string) ToolboxAPILspDidCloseRequest {
	return ToolboxAPILspDidCloseRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) LspDidCloseExecute(r ToolboxAPILspDidCloseRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.LspDidClose")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/lsp/did-close"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lspDocumentRequest == nil {
		return nil, reportError("lspDocumentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.lspDocumentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPILspDidOpenRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	lspDocumentRequest     *LspDocumentRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPILspDidOpenRequest) LspDocumentRequest(lspDocumentRequest LspDocumentRequest) ToolboxAPILspDidOpenRequest {
	r.lspDocumentRequest = &lspDocumentRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPILspDidOpenRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPILspDidOpenRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPILspDidOpenRequest) Execute() (*http.Response, error) {
	return r.ApiService.LspDidOpenExecute(r)
}

/*
LspDidOpen Call Lsp DidOpen

The document open notification is sent from the client to the server to signal newly opened text documents.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPILspDidOpenRequest
*/
func (a *ToolboxAPIService) LspDidOpen(ctx context.Context, sandboxId string) ToolboxAPILspDidOpenRequest {
	return ToolboxAPILspDidOpenRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) LspDidOpenExecute(r ToolboxAPILspDidOpenRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.LspDidOpen")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/lsp/did-open"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lspDocumentRequest == nil {
		return nil, reportError("lspDocumentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.lspDocumentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPILspDocumentSymbolsRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	languageId             *string
	pathToProject          *string
	uri                    *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPILspDocumentSymbolsRequest) LanguageId(languageId string) ToolboxAPILspDocumentSymbolsRequest {
	r.languageId = &languageId
	return r
}

func (r ToolboxAPILspDocumentSymbolsRequest) PathToProject(pathToProject string) ToolboxAPILspDocumentSymbolsRequest {
	r.pathToProject = &pathToProject
	return r
}

func (r ToolboxAPILspDocumentSymbolsRequest) Uri(uri string) ToolboxAPILspDocumentSymbolsRequest {
	r.uri = &uri
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPILspDocumentSymbolsRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPILspDocumentSymbolsRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPILspDocumentSymbolsRequest) Execute() ([]LspSymbol, *http.Response, error) {
	return r.ApiService.LspDocumentSymbolsExecute(r)
}

/*
LspDocumentSymbols Call Lsp DocumentSymbols

The document symbol request is sent from the client to the server.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPILspDocumentSymbolsRequest
*/
func (a *ToolboxAPIService) LspDocumentSymbols(ctx context.Context, sandboxId string) ToolboxAPILspDocumentSymbolsRequest {
	return ToolboxAPILspDocumentSymbolsRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return []LspSymbol
func (a *ToolboxAPIService) LspDocumentSymbolsExecute(r ToolboxAPILspDocumentSymbolsRequest) ([]LspSymbol, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []LspSymbol
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.LspDocumentSymbols")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/lsp/document-symbols"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.languageId == nil {
		return localVarReturnValue, nil, reportError("languageId is required and must be specified")
	}
	if r.pathToProject == nil {
		return localVarReturnValue, nil, reportError("pathToProject is required and must be specified")
	}
	if r.uri == nil {
		return localVarReturnValue, nil, reportError("uri is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "languageId", r.languageId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pathToProject", r.pathToProject, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "uri", r.uri, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPILspStartRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	lspServerRequest       *LspServerRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPILspStartRequest) LspServerRequest(lspServerRequest LspServerRequest) ToolboxAPILspStartRequest {
	r.lspServerRequest = &lspServerRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPILspStartRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPILspStartRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPILspStartRequest) Execute() (*http.Response, error) {
	return r.ApiService.LspStartExecute(r)
}

/*
LspStart Start Lsp server

Start Lsp server process inside sandbox project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPILspStartRequest
*/
func (a *ToolboxAPIService) LspStart(ctx context.Context, sandboxId string) ToolboxAPILspStartRequest {
	return ToolboxAPILspStartRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) LspStartExecute(r ToolboxAPILspStartRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.LspStart")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/lsp/start"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lspServerRequest == nil {
		return nil, reportError("lspServerRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.lspServerRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPILspStopRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	lspServerRequest       *LspServerRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPILspStopRequest) LspServerRequest(lspServerRequest LspServerRequest) ToolboxAPILspStopRequest {
	r.lspServerRequest = &lspServerRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPILspStopRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPILspStopRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPILspStopRequest) Execute() (*http.Response, error) {
	return r.ApiService.LspStopExecute(r)
}

/*
LspStop Stop Lsp server

Stop Lsp server process inside sandbox project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPILspStopRequest
*/
func (a *ToolboxAPIService) LspStop(ctx context.Context, sandboxId string) ToolboxAPILspStopRequest {
	return ToolboxAPILspStopRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) LspStopExecute(r ToolboxAPILspStopRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.LspStop")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/lsp/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lspServerRequest == nil {
		return nil, reportError("lspServerRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.lspServerRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPILspWorkspaceSymbolsRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	languageId             *string
	pathToProject          *string
	query                  *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPILspWorkspaceSymbolsRequest) LanguageId(languageId string) ToolboxAPILspWorkspaceSymbolsRequest {
	r.languageId = &languageId
	return r
}

func (r ToolboxAPILspWorkspaceSymbolsRequest) PathToProject(pathToProject string) ToolboxAPILspWorkspaceSymbolsRequest {
	r.pathToProject = &pathToProject
	return r
}

func (r ToolboxAPILspWorkspaceSymbolsRequest) Query(query string) ToolboxAPILspWorkspaceSymbolsRequest {
	r.query = &query
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPILspWorkspaceSymbolsRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPILspWorkspaceSymbolsRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPILspWorkspaceSymbolsRequest) Execute() ([]LspSymbol, *http.Response, error) {
	return r.ApiService.LspWorkspaceSymbolsExecute(r)
}

/*
LspWorkspaceSymbols Call Lsp WorkspaceSymbols

The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPILspWorkspaceSymbolsRequest
*/
func (a *ToolboxAPIService) LspWorkspaceSymbols(ctx context.Context, sandboxId string) ToolboxAPILspWorkspaceSymbolsRequest {
	return ToolboxAPILspWorkspaceSymbolsRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return []LspSymbol
func (a *ToolboxAPIService) LspWorkspaceSymbolsExecute(r ToolboxAPILspWorkspaceSymbolsRequest) ([]LspSymbol, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []LspSymbol
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.LspWorkspaceSymbols")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/lsp/workspace-symbols"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.languageId == nil {
		return localVarReturnValue, nil, reportError("languageId is required and must be specified")
	}
	if r.pathToProject == nil {
		return localVarReturnValue, nil, reportError("pathToProject is required and must be specified")
	}
	if r.query == nil {
		return localVarReturnValue, nil, reportError("query is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "languageId", r.languageId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pathToProject", r.pathToProject, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIMoveFileRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	source                 *string
	destination            *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIMoveFileRequest) Source(source string) ToolboxAPIMoveFileRequest {
	r.source = &source
	return r
}

func (r ToolboxAPIMoveFileRequest) Destination(destination string) ToolboxAPIMoveFileRequest {
	r.destination = &destination
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIMoveFileRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIMoveFileRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIMoveFileRequest) Execute() (*http.Response, error) {
	return r.ApiService.MoveFileExecute(r)
}

/*
MoveFile Move file

Move file inside sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIMoveFileRequest
*/
func (a *ToolboxAPIService) MoveFile(ctx context.Context, sandboxId string) ToolboxAPIMoveFileRequest {
	return ToolboxAPIMoveFileRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) MoveFileExecute(r ToolboxAPIMoveFileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.MoveFile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files/move"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.source == nil {
		return nil, reportError("source is required and must be specified")
	}
	if r.destination == nil {
		return nil, reportError("destination is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "destination", r.destination, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIMoveMouseRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	mouseMoveRequest       *MouseMoveRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIMoveMouseRequest) MouseMoveRequest(mouseMoveRequest MouseMoveRequest) ToolboxAPIMoveMouseRequest {
	r.mouseMoveRequest = &mouseMoveRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIMoveMouseRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIMoveMouseRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIMoveMouseRequest) Execute() (*MouseMoveResponse, *http.Response, error) {
	return r.ApiService.MoveMouseExecute(r)
}

/*
MoveMouse Move mouse

Move mouse cursor to specified coordinates

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIMoveMouseRequest
*/
func (a *ToolboxAPIService) MoveMouse(ctx context.Context, sandboxId string) ToolboxAPIMoveMouseRequest {
	return ToolboxAPIMoveMouseRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return MouseMoveResponse
func (a *ToolboxAPIService) MoveMouseExecute(r ToolboxAPIMoveMouseRequest) (*MouseMoveResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MouseMoveResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.MoveMouse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/mouse/move"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mouseMoveRequest == nil {
		return localVarReturnValue, nil, reportError("mouseMoveRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.mouseMoveRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIPressHotkeyRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	keyboardHotkeyRequest  *KeyboardHotkeyRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIPressHotkeyRequest) KeyboardHotkeyRequest(keyboardHotkeyRequest KeyboardHotkeyRequest) ToolboxAPIPressHotkeyRequest {
	r.keyboardHotkeyRequest = &keyboardHotkeyRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIPressHotkeyRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIPressHotkeyRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIPressHotkeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PressHotkeyExecute(r)
}

/*
PressHotkey Press hotkey

Press a hotkey combination

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIPressHotkeyRequest
*/
func (a *ToolboxAPIService) PressHotkey(ctx context.Context, sandboxId string) ToolboxAPIPressHotkeyRequest {
	return ToolboxAPIPressHotkeyRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) PressHotkeyExecute(r ToolboxAPIPressHotkeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.PressHotkey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/keyboard/hotkey"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.keyboardHotkeyRequest == nil {
		return nil, reportError("keyboardHotkeyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.keyboardHotkeyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIPressKeyRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	keyboardPressRequest   *KeyboardPressRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIPressKeyRequest) KeyboardPressRequest(keyboardPressRequest KeyboardPressRequest) ToolboxAPIPressKeyRequest {
	r.keyboardPressRequest = &keyboardPressRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIPressKeyRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIPressKeyRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIPressKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PressKeyExecute(r)
}

/*
PressKey Press key

Press a key with optional modifiers

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIPressKeyRequest
*/
func (a *ToolboxAPIService) PressKey(ctx context.Context, sandboxId string) ToolboxAPIPressKeyRequest {
	return ToolboxAPIPressKeyRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) PressKeyExecute(r ToolboxAPIPressKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.PressKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/keyboard/key"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.keyboardPressRequest == nil {
		return nil, reportError("keyboardPressRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.keyboardPressRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIReplaceInFilesRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	replaceRequest         *ReplaceRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIReplaceInFilesRequest) ReplaceRequest(replaceRequest ReplaceRequest) ToolboxAPIReplaceInFilesRequest {
	r.replaceRequest = &replaceRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIReplaceInFilesRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIReplaceInFilesRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIReplaceInFilesRequest) Execute() ([]ReplaceResult, *http.Response, error) {
	return r.ApiService.ReplaceInFilesExecute(r)
}

/*
ReplaceInFiles Replace in files

Replace text/pattern in multiple files inside sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIReplaceInFilesRequest
*/
func (a *ToolboxAPIService) ReplaceInFiles(ctx context.Context, sandboxId string) ToolboxAPIReplaceInFilesRequest {
	return ToolboxAPIReplaceInFilesRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return []ReplaceResult
func (a *ToolboxAPIService) ReplaceInFilesExecute(r ToolboxAPIReplaceInFilesRequest) ([]ReplaceResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ReplaceResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.ReplaceInFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files/replace"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.replaceRequest == nil {
		return localVarReturnValue, nil, reportError("replaceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.replaceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIRestartProcessRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	processName            string
	sandboxId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIRestartProcessRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIRestartProcessRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIRestartProcessRequest) Execute() (*ProcessRestartResponse, *http.Response, error) {
	return r.ApiService.RestartProcessExecute(r)
}

/*
RestartProcess Restart process

Restart a specific VNC process

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param processName
	@param sandboxId
	@return ToolboxAPIRestartProcessRequest
*/
func (a *ToolboxAPIService) RestartProcess(ctx context.Context, processName string, sandboxId string) ToolboxAPIRestartProcessRequest {
	return ToolboxAPIRestartProcessRequest{
		ApiService:  a,
		ctx:         ctx,
		processName: processName,
		sandboxId:   sandboxId,
	}
}

// Execute executes the request
//
//	@return ProcessRestartResponse
func (a *ToolboxAPIService) RestartProcessExecute(r ToolboxAPIRestartProcessRequest) (*ProcessRestartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProcessRestartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.RestartProcess")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/process/{processName}/restart"
	localVarPath = strings.Replace(localVarPath, "{"+"processName"+"}", url.PathEscape(parameterValueToString(r.processName, "processName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIScrollMouseRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	mouseScrollRequest     *MouseScrollRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIScrollMouseRequest) MouseScrollRequest(mouseScrollRequest MouseScrollRequest) ToolboxAPIScrollMouseRequest {
	r.mouseScrollRequest = &mouseScrollRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIScrollMouseRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIScrollMouseRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIScrollMouseRequest) Execute() (*MouseScrollResponse, *http.Response, error) {
	return r.ApiService.ScrollMouseExecute(r)
}

/*
ScrollMouse Scroll mouse

Scroll mouse at specified coordinates

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIScrollMouseRequest
*/
func (a *ToolboxAPIService) ScrollMouse(ctx context.Context, sandboxId string) ToolboxAPIScrollMouseRequest {
	return ToolboxAPIScrollMouseRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return MouseScrollResponse
func (a *ToolboxAPIService) ScrollMouseExecute(r ToolboxAPIScrollMouseRequest) (*MouseScrollResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MouseScrollResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.ScrollMouse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/mouse/scroll"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mouseScrollRequest == nil {
		return localVarReturnValue, nil, reportError("mouseScrollRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.mouseScrollRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPISearchFilesRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	path                   *string
	pattern                *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPISearchFilesRequest) Path(path string) ToolboxAPISearchFilesRequest {
	r.path = &path
	return r
}

func (r ToolboxAPISearchFilesRequest) Pattern(pattern string) ToolboxAPISearchFilesRequest {
	r.pattern = &pattern
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPISearchFilesRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPISearchFilesRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPISearchFilesRequest) Execute() (*SearchFilesResponse, *http.Response, error) {
	return r.ApiService.SearchFilesExecute(r)
}

/*
SearchFiles Search files

Search for files inside sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPISearchFilesRequest
*/
func (a *ToolboxAPIService) SearchFiles(ctx context.Context, sandboxId string) ToolboxAPISearchFilesRequest {
	return ToolboxAPISearchFilesRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return SearchFilesResponse
func (a *ToolboxAPIService) SearchFilesExecute(r ToolboxAPISearchFilesRequest) (*SearchFilesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SearchFilesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.SearchFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files/search"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}
	if r.pattern == nil {
		return localVarReturnValue, nil, reportError("pattern is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pattern", r.pattern, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPISetFilePermissionsRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	path                   *string
	xDaytonaOrganizationID *string
	owner                  *string
	group                  *string
	mode                   *string
}

func (r ToolboxAPISetFilePermissionsRequest) Path(path string) ToolboxAPISetFilePermissionsRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPISetFilePermissionsRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPISetFilePermissionsRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPISetFilePermissionsRequest) Owner(owner string) ToolboxAPISetFilePermissionsRequest {
	r.owner = &owner
	return r
}

func (r ToolboxAPISetFilePermissionsRequest) Group(group string) ToolboxAPISetFilePermissionsRequest {
	r.group = &group
	return r
}

func (r ToolboxAPISetFilePermissionsRequest) Mode(mode string) ToolboxAPISetFilePermissionsRequest {
	r.mode = &mode
	return r
}

func (r ToolboxAPISetFilePermissionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetFilePermissionsExecute(r)
}

/*
SetFilePermissions Set file permissions

Set file owner/group/permissions inside sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPISetFilePermissionsRequest
*/
func (a *ToolboxAPIService) SetFilePermissions(ctx context.Context, sandboxId string) ToolboxAPISetFilePermissionsRequest {
	return ToolboxAPISetFilePermissionsRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) SetFilePermissionsExecute(r ToolboxAPISetFilePermissionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.SetFilePermissions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	if r.owner != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "owner", r.owner, "form", "")
	}
	if r.group != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group", r.group, "form", "")
	}
	if r.mode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIStartComputerUseRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIStartComputerUseRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIStartComputerUseRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIStartComputerUseRequest) Execute() (*ComputerUseStartResponse, *http.Response, error) {
	return r.ApiService.StartComputerUseExecute(r)
}

/*
StartComputerUse Start computer use processes

Start all VNC desktop processes (Xvfb, xfce4, x11vnc, novnc)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIStartComputerUseRequest
*/
func (a *ToolboxAPIService) StartComputerUse(ctx context.Context, sandboxId string) ToolboxAPIStartComputerUseRequest {
	return ToolboxAPIStartComputerUseRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return ComputerUseStartResponse
func (a *ToolboxAPIService) StartComputerUseExecute(r ToolboxAPIStartComputerUseRequest) (*ComputerUseStartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ComputerUseStartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.StartComputerUse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/start"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIStopComputerUseRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIStopComputerUseRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIStopComputerUseRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIStopComputerUseRequest) Execute() (*ComputerUseStopResponse, *http.Response, error) {
	return r.ApiService.StopComputerUseExecute(r)
}

/*
StopComputerUse Stop computer use processes

Stop all VNC desktop processes (Xvfb, xfce4, x11vnc, novnc)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIStopComputerUseRequest
*/
func (a *ToolboxAPIService) StopComputerUse(ctx context.Context, sandboxId string) ToolboxAPIStopComputerUseRequest {
	return ToolboxAPIStopComputerUseRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return ComputerUseStopResponse
func (a *ToolboxAPIService) StopComputerUseExecute(r ToolboxAPIStopComputerUseRequest) (*ComputerUseStopResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ComputerUseStopResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.StopComputerUse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPITakeCompressedRegionScreenshotRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	height                 *float32
	width                  *float32
	y                      *float32
	x                      *float32
	xDaytonaOrganizationID *string
	scale                  *float32
	quality                *float32
	format                 *string
	showCursor             *bool
}

func (r ToolboxAPITakeCompressedRegionScreenshotRequest) Height(height float32) ToolboxAPITakeCompressedRegionScreenshotRequest {
	r.height = &height
	return r
}

func (r ToolboxAPITakeCompressedRegionScreenshotRequest) Width(width float32) ToolboxAPITakeCompressedRegionScreenshotRequest {
	r.width = &width
	return r
}

func (r ToolboxAPITakeCompressedRegionScreenshotRequest) Y(y float32) ToolboxAPITakeCompressedRegionScreenshotRequest {
	r.y = &y
	return r
}

func (r ToolboxAPITakeCompressedRegionScreenshotRequest) X(x float32) ToolboxAPITakeCompressedRegionScreenshotRequest {
	r.x = &x
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPITakeCompressedRegionScreenshotRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPITakeCompressedRegionScreenshotRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPITakeCompressedRegionScreenshotRequest) Scale(scale float32) ToolboxAPITakeCompressedRegionScreenshotRequest {
	r.scale = &scale
	return r
}

func (r ToolboxAPITakeCompressedRegionScreenshotRequest) Quality(quality float32) ToolboxAPITakeCompressedRegionScreenshotRequest {
	r.quality = &quality
	return r
}

func (r ToolboxAPITakeCompressedRegionScreenshotRequest) Format(format string) ToolboxAPITakeCompressedRegionScreenshotRequest {
	r.format = &format
	return r
}

func (r ToolboxAPITakeCompressedRegionScreenshotRequest) ShowCursor(showCursor bool) ToolboxAPITakeCompressedRegionScreenshotRequest {
	r.showCursor = &showCursor
	return r
}

func (r ToolboxAPITakeCompressedRegionScreenshotRequest) Execute() (*CompressedScreenshotResponse, *http.Response, error) {
	return r.ApiService.TakeCompressedRegionScreenshotExecute(r)
}

/*
TakeCompressedRegionScreenshot Take compressed region screenshot

Take a compressed screenshot of a specific region

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPITakeCompressedRegionScreenshotRequest
*/
func (a *ToolboxAPIService) TakeCompressedRegionScreenshot(ctx context.Context, sandboxId string) ToolboxAPITakeCompressedRegionScreenshotRequest {
	return ToolboxAPITakeCompressedRegionScreenshotRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return CompressedScreenshotResponse
func (a *ToolboxAPIService) TakeCompressedRegionScreenshotExecute(r ToolboxAPITakeCompressedRegionScreenshotRequest) (*CompressedScreenshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CompressedScreenshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.TakeCompressedRegionScreenshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/screenshot/region/compressed"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.height == nil {
		return localVarReturnValue, nil, reportError("height is required and must be specified")
	}
	if r.width == nil {
		return localVarReturnValue, nil, reportError("width is required and must be specified")
	}
	if r.y == nil {
		return localVarReturnValue, nil, reportError("y is required and must be specified")
	}
	if r.x == nil {
		return localVarReturnValue, nil, reportError("x is required and must be specified")
	}

	if r.scale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scale", r.scale, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.showCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_cursor", r.showCursor, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "y", r.y, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "x", r.x, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPITakeCompressedScreenshotRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	xDaytonaOrganizationID *string
	scale                  *float32
	quality                *float32
	format                 *string
	showCursor             *bool
}

// Use with JWT to specify the organization ID
func (r ToolboxAPITakeCompressedScreenshotRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPITakeCompressedScreenshotRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPITakeCompressedScreenshotRequest) Scale(scale float32) ToolboxAPITakeCompressedScreenshotRequest {
	r.scale = &scale
	return r
}

func (r ToolboxAPITakeCompressedScreenshotRequest) Quality(quality float32) ToolboxAPITakeCompressedScreenshotRequest {
	r.quality = &quality
	return r
}

func (r ToolboxAPITakeCompressedScreenshotRequest) Format(format string) ToolboxAPITakeCompressedScreenshotRequest {
	r.format = &format
	return r
}

func (r ToolboxAPITakeCompressedScreenshotRequest) ShowCursor(showCursor bool) ToolboxAPITakeCompressedScreenshotRequest {
	r.showCursor = &showCursor
	return r
}

func (r ToolboxAPITakeCompressedScreenshotRequest) Execute() (*CompressedScreenshotResponse, *http.Response, error) {
	return r.ApiService.TakeCompressedScreenshotExecute(r)
}

/*
TakeCompressedScreenshot Take compressed screenshot

Take a compressed screenshot with format, quality, and scale options

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPITakeCompressedScreenshotRequest
*/
func (a *ToolboxAPIService) TakeCompressedScreenshot(ctx context.Context, sandboxId string) ToolboxAPITakeCompressedScreenshotRequest {
	return ToolboxAPITakeCompressedScreenshotRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return CompressedScreenshotResponse
func (a *ToolboxAPIService) TakeCompressedScreenshotExecute(r ToolboxAPITakeCompressedScreenshotRequest) (*CompressedScreenshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CompressedScreenshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.TakeCompressedScreenshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/screenshot/compressed"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scale", r.scale, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.showCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_cursor", r.showCursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPITakeRegionScreenshotRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	height                 *float32
	width                  *float32
	y                      *float32
	x                      *float32
	xDaytonaOrganizationID *string
	showCursor             *bool
}

func (r ToolboxAPITakeRegionScreenshotRequest) Height(height float32) ToolboxAPITakeRegionScreenshotRequest {
	r.height = &height
	return r
}

func (r ToolboxAPITakeRegionScreenshotRequest) Width(width float32) ToolboxAPITakeRegionScreenshotRequest {
	r.width = &width
	return r
}

func (r ToolboxAPITakeRegionScreenshotRequest) Y(y float32) ToolboxAPITakeRegionScreenshotRequest {
	r.y = &y
	return r
}

func (r ToolboxAPITakeRegionScreenshotRequest) X(x float32) ToolboxAPITakeRegionScreenshotRequest {
	r.x = &x
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPITakeRegionScreenshotRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPITakeRegionScreenshotRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPITakeRegionScreenshotRequest) ShowCursor(showCursor bool) ToolboxAPITakeRegionScreenshotRequest {
	r.showCursor = &showCursor
	return r
}

func (r ToolboxAPITakeRegionScreenshotRequest) Execute() (*RegionScreenshotResponse, *http.Response, error) {
	return r.ApiService.TakeRegionScreenshotExecute(r)
}

/*
TakeRegionScreenshot Take region screenshot

Take a screenshot of a specific region

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPITakeRegionScreenshotRequest
*/
func (a *ToolboxAPIService) TakeRegionScreenshot(ctx context.Context, sandboxId string) ToolboxAPITakeRegionScreenshotRequest {
	return ToolboxAPITakeRegionScreenshotRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return RegionScreenshotResponse
func (a *ToolboxAPIService) TakeRegionScreenshotExecute(r ToolboxAPITakeRegionScreenshotRequest) (*RegionScreenshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RegionScreenshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.TakeRegionScreenshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/screenshot/region"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.height == nil {
		return localVarReturnValue, nil, reportError("height is required and must be specified")
	}
	if r.width == nil {
		return localVarReturnValue, nil, reportError("width is required and must be specified")
	}
	if r.y == nil {
		return localVarReturnValue, nil, reportError("y is required and must be specified")
	}
	if r.x == nil {
		return localVarReturnValue, nil, reportError("x is required and must be specified")
	}

	if r.showCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_cursor", r.showCursor, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "y", r.y, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "x", r.x, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPITakeScreenshotRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	xDaytonaOrganizationID *string
	showCursor             *bool
}

// Use with JWT to specify the organization ID
func (r ToolboxAPITakeScreenshotRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPITakeScreenshotRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPITakeScreenshotRequest) ShowCursor(showCursor bool) ToolboxAPITakeScreenshotRequest {
	r.showCursor = &showCursor
	return r
}

func (r ToolboxAPITakeScreenshotRequest) Execute() (*ScreenshotResponse, *http.Response, error) {
	return r.ApiService.TakeScreenshotExecute(r)
}

/*
TakeScreenshot Take screenshot

Take a screenshot of the entire screen

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPITakeScreenshotRequest
*/
func (a *ToolboxAPIService) TakeScreenshot(ctx context.Context, sandboxId string) ToolboxAPITakeScreenshotRequest {
	return ToolboxAPITakeScreenshotRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
//
//	@return ScreenshotResponse
func (a *ToolboxAPIService) TakeScreenshotExecute(r ToolboxAPITakeScreenshotRequest) (*ScreenshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ScreenshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.TakeScreenshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/screenshot"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.showCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_cursor", r.showCursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPITypeTextRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	keyboardTypeRequest    *KeyboardTypeRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPITypeTextRequest) KeyboardTypeRequest(keyboardTypeRequest KeyboardTypeRequest) ToolboxAPITypeTextRequest {
	r.keyboardTypeRequest = &keyboardTypeRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPITypeTextRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPITypeTextRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPITypeTextRequest) Execute() (*http.Response, error) {
	return r.ApiService.TypeTextExecute(r)
}

/*
TypeText Type text

Type text using keyboard

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPITypeTextRequest
*/
func (a *ToolboxAPIService) TypeText(ctx context.Context, sandboxId string) ToolboxAPITypeTextRequest {
	return ToolboxAPITypeTextRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) TypeTextExecute(r ToolboxAPITypeTextRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.TypeText")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/computeruse/keyboard/type"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.keyboardTypeRequest == nil {
		return nil, reportError("keyboardTypeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.keyboardTypeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIUploadFileRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	path                   *string
	xDaytonaOrganizationID *string
	file                   *os.File
}

func (r ToolboxAPIUploadFileRequest) Path(path string) ToolboxAPIUploadFileRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIUploadFileRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIUploadFileRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIUploadFileRequest) File(file *os.File) ToolboxAPIUploadFileRequest {
	r.file = file
	return r
}

func (r ToolboxAPIUploadFileRequest) Execute() (*http.Response, error) {
	return r.ApiService.UploadFileExecute(r)
}

/*
UploadFile Upload file

Upload file inside sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIUploadFileRequest

Deprecated
*/
func (a *ToolboxAPIService) UploadFile(ctx context.Context, sandboxId string) ToolboxAPIUploadFileRequest {
	return ToolboxAPIUploadFileRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
// Deprecated
func (a *ToolboxAPIService) UploadFileExecute(r ToolboxAPIUploadFileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.UploadFile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files/upload"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName string
	var fileLocalVarFileBytes []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIUploadFilesRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	sandboxId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIUploadFilesRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIUploadFilesRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIUploadFilesRequest) Execute() (*http.Response, error) {
	return r.ApiService.UploadFilesExecute(r)
}

/*
UploadFiles Upload multiple files

Upload multiple files inside sandbox

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sandboxId
	@return ToolboxAPIUploadFilesRequest
*/
func (a *ToolboxAPIService) UploadFiles(ctx context.Context, sandboxId string) ToolboxAPIUploadFilesRequest {
	return ToolboxAPIUploadFilesRequest{
		ApiService: a,
		ctx:        ctx,
		sandboxId:  sandboxId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) UploadFilesExecute(r ToolboxAPIUploadFilesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.UploadFiles")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{sandboxId}/toolbox/files/bulk-upload"
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxId"+"}", url.PathEscape(parameterValueToString(r.sandboxId, "sandboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
