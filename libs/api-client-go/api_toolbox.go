/*
Daytona

Daytona AI platform API Docs

API version: 1.0
Contact: support@daytona.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package daytonaapiclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

type ToolboxAPI interface {

	/*
		CreateFolder Create folder

		Create folder inside workspace

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPICreateFolderRequest
	*/
	CreateFolder(ctx context.Context, workspaceId string) ToolboxAPICreateFolderRequest

	// CreateFolderExecute executes the request
	CreateFolderExecute(r ToolboxAPICreateFolderRequest) (*http.Response, error)

	/*
		CreateSession Create session

		Create a new session in the workspace

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPICreateSessionRequest
	*/
	CreateSession(ctx context.Context, workspaceId string) ToolboxAPICreateSessionRequest

	// CreateSessionExecute executes the request
	CreateSessionExecute(r ToolboxAPICreateSessionRequest) (*http.Response, error)

	/*
		DeleteFile Delete file

		Delete file inside workspace

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPIDeleteFileRequest
	*/
	DeleteFile(ctx context.Context, workspaceId string) ToolboxAPIDeleteFileRequest

	// DeleteFileExecute executes the request
	DeleteFileExecute(r ToolboxAPIDeleteFileRequest) (*http.Response, error)

	/*
		DeleteSession Delete session

		Delete a specific session

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@param sessionId
		@return ToolboxAPIDeleteSessionRequest
	*/
	DeleteSession(ctx context.Context, workspaceId string, sessionId string) ToolboxAPIDeleteSessionRequest

	// DeleteSessionExecute executes the request
	DeleteSessionExecute(r ToolboxAPIDeleteSessionRequest) (*http.Response, error)

	/*
		DownloadFile Download file

		Download file from workspace

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPIDownloadFileRequest
	*/
	DownloadFile(ctx context.Context, workspaceId string) ToolboxAPIDownloadFileRequest

	// DownloadFileExecute executes the request
	//  @return *os.File
	DownloadFileExecute(r ToolboxAPIDownloadFileRequest) (*os.File, *http.Response, error)

	/*
		ExecuteCommand Execute command

		Execute command synchronously inside workspace

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPIExecuteCommandRequest
	*/
	ExecuteCommand(ctx context.Context, workspaceId string) ToolboxAPIExecuteCommandRequest

	// ExecuteCommandExecute executes the request
	//  @return ExecuteResponse
	ExecuteCommandExecute(r ToolboxAPIExecuteCommandRequest) (*ExecuteResponse, *http.Response, error)

	/*
		ExecuteSessionCommand Execute command in session

		Execute a command in a specific session

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@param sessionId
		@return ToolboxAPIExecuteSessionCommandRequest
	*/
	ExecuteSessionCommand(ctx context.Context, workspaceId string, sessionId string) ToolboxAPIExecuteSessionCommandRequest

	// ExecuteSessionCommandExecute executes the request
	//  @return SessionExecuteResponse
	ExecuteSessionCommandExecute(r ToolboxAPIExecuteSessionCommandRequest) (*SessionExecuteResponse, *http.Response, error)

	/*
		FindInFiles Search for text/pattern in files

		Search for text/pattern inside workspace files

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPIFindInFilesRequest
	*/
	FindInFiles(ctx context.Context, workspaceId string) ToolboxAPIFindInFilesRequest

	// FindInFilesExecute executes the request
	//  @return []Match
	FindInFilesExecute(r ToolboxAPIFindInFilesRequest) ([]Match, *http.Response, error)

	/*
		GetFileInfo Get file info

		Get file info inside workspace

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPIGetFileInfoRequest
	*/
	GetFileInfo(ctx context.Context, workspaceId string) ToolboxAPIGetFileInfoRequest

	// GetFileInfoExecute executes the request
	//  @return FileInfo
	GetFileInfoExecute(r ToolboxAPIGetFileInfoRequest) (*FileInfo, *http.Response, error)

	/*
		GetProjectDir Get workspace project dir

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPIGetProjectDirRequest
	*/
	GetProjectDir(ctx context.Context, workspaceId string) ToolboxAPIGetProjectDirRequest

	// GetProjectDirExecute executes the request
	//  @return ProjectDirResponse
	GetProjectDirExecute(r ToolboxAPIGetProjectDirRequest) (*ProjectDirResponse, *http.Response, error)

	/*
		GetSession Get session

		Get session by ID

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@param sessionId
		@return ToolboxAPIGetSessionRequest
	*/
	GetSession(ctx context.Context, workspaceId string, sessionId string) ToolboxAPIGetSessionRequest

	// GetSessionExecute executes the request
	//  @return Session
	GetSessionExecute(r ToolboxAPIGetSessionRequest) (*Session, *http.Response, error)

	/*
		GetSessionCommand Get session command

		Get session command by ID

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@param sessionId
		@param commandId
		@return ToolboxAPIGetSessionCommandRequest
	*/
	GetSessionCommand(ctx context.Context, workspaceId string, sessionId string, commandId string) ToolboxAPIGetSessionCommandRequest

	// GetSessionCommandExecute executes the request
	//  @return Command
	GetSessionCommandExecute(r ToolboxAPIGetSessionCommandRequest) (*Command, *http.Response, error)

	/*
		GetSessionCommandLogs Get command logs

		Get logs for a specific command in a session

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@param sessionId
		@param commandId
		@return ToolboxAPIGetSessionCommandLogsRequest
	*/
	GetSessionCommandLogs(ctx context.Context, workspaceId string, sessionId string, commandId string) ToolboxAPIGetSessionCommandLogsRequest

	// GetSessionCommandLogsExecute executes the request
	//  @return string
	GetSessionCommandLogsExecute(r ToolboxAPIGetSessionCommandLogsRequest) (string, *http.Response, error)

	/*
		GitAddFiles Add files

		Add files to git commit

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPIGitAddFilesRequest
	*/
	GitAddFiles(ctx context.Context, workspaceId string) ToolboxAPIGitAddFilesRequest

	// GitAddFilesExecute executes the request
	GitAddFilesExecute(r ToolboxAPIGitAddFilesRequest) (*http.Response, error)

	/*
		GitCloneRepository Clone repository

		Clone git repository

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPIGitCloneRepositoryRequest
	*/
	GitCloneRepository(ctx context.Context, workspaceId string) ToolboxAPIGitCloneRepositoryRequest

	// GitCloneRepositoryExecute executes the request
	GitCloneRepositoryExecute(r ToolboxAPIGitCloneRepositoryRequest) (*http.Response, error)

	/*
		GitCommitChanges Commit changes

		Commit changes to git repository

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPIGitCommitChangesRequest
	*/
	GitCommitChanges(ctx context.Context, workspaceId string) ToolboxAPIGitCommitChangesRequest

	// GitCommitChangesExecute executes the request
	//  @return GitCommitResponse
	GitCommitChangesExecute(r ToolboxAPIGitCommitChangesRequest) (*GitCommitResponse, *http.Response, error)

	/*
		GitCreateBranch Create branch

		Create branch on git repository

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPIGitCreateBranchRequest
	*/
	GitCreateBranch(ctx context.Context, workspaceId string) ToolboxAPIGitCreateBranchRequest

	// GitCreateBranchExecute executes the request
	GitCreateBranchExecute(r ToolboxAPIGitCreateBranchRequest) (*http.Response, error)

	/*
		GitGetHistory Get commit history

		Get commit history from git repository

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPIGitGetHistoryRequest
	*/
	GitGetHistory(ctx context.Context, workspaceId string) ToolboxAPIGitGetHistoryRequest

	// GitGetHistoryExecute executes the request
	//  @return []GitCommitInfo
	GitGetHistoryExecute(r ToolboxAPIGitGetHistoryRequest) ([]GitCommitInfo, *http.Response, error)

	/*
		GitGetStatus Get git status

		Get status from git repository

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPIGitGetStatusRequest
	*/
	GitGetStatus(ctx context.Context, workspaceId string) ToolboxAPIGitGetStatusRequest

	// GitGetStatusExecute executes the request
	//  @return GitStatus
	GitGetStatusExecute(r ToolboxAPIGitGetStatusRequest) (*GitStatus, *http.Response, error)

	/*
		GitListBranches Get branch list

		Get branch list from git repository

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPIGitListBranchesRequest
	*/
	GitListBranches(ctx context.Context, workspaceId string) ToolboxAPIGitListBranchesRequest

	// GitListBranchesExecute executes the request
	//  @return ListBranchResponse
	GitListBranchesExecute(r ToolboxAPIGitListBranchesRequest) (*ListBranchResponse, *http.Response, error)

	/*
		GitPullChanges Pull changes

		Pull changes from remote

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPIGitPullChangesRequest
	*/
	GitPullChanges(ctx context.Context, workspaceId string) ToolboxAPIGitPullChangesRequest

	// GitPullChangesExecute executes the request
	GitPullChangesExecute(r ToolboxAPIGitPullChangesRequest) (*http.Response, error)

	/*
		GitPushChanges Push changes

		Push changes to remote

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPIGitPushChangesRequest
	*/
	GitPushChanges(ctx context.Context, workspaceId string) ToolboxAPIGitPushChangesRequest

	// GitPushChangesExecute executes the request
	GitPushChangesExecute(r ToolboxAPIGitPushChangesRequest) (*http.Response, error)

	/*
		ListFiles List files

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPIListFilesRequest
	*/
	ListFiles(ctx context.Context, workspaceId string) ToolboxAPIListFilesRequest

	// ListFilesExecute executes the request
	//  @return []FileInfo
	ListFilesExecute(r ToolboxAPIListFilesRequest) ([]FileInfo, *http.Response, error)

	/*
		ListSessions List sessions

		List all active sessions in the workspace

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPIListSessionsRequest
	*/
	ListSessions(ctx context.Context, workspaceId string) ToolboxAPIListSessionsRequest

	// ListSessionsExecute executes the request
	//  @return []Session
	ListSessionsExecute(r ToolboxAPIListSessionsRequest) ([]Session, *http.Response, error)

	/*
		LspCompletions Get Lsp Completions

		The Completion request is sent from the client to the server to compute completion items at a given cursor position.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPILspCompletionsRequest
	*/
	LspCompletions(ctx context.Context, workspaceId string) ToolboxAPILspCompletionsRequest

	// LspCompletionsExecute executes the request
	//  @return CompletionList
	LspCompletionsExecute(r ToolboxAPILspCompletionsRequest) (*CompletionList, *http.Response, error)

	/*
		LspDidClose Call Lsp DidClose

		The document close notification is sent from the client to the server when the document got closed in the client.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPILspDidCloseRequest
	*/
	LspDidClose(ctx context.Context, workspaceId string) ToolboxAPILspDidCloseRequest

	// LspDidCloseExecute executes the request
	LspDidCloseExecute(r ToolboxAPILspDidCloseRequest) (*http.Response, error)

	/*
		LspDidOpen Call Lsp DidOpen

		The document open notification is sent from the client to the server to signal newly opened text documents.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPILspDidOpenRequest
	*/
	LspDidOpen(ctx context.Context, workspaceId string) ToolboxAPILspDidOpenRequest

	// LspDidOpenExecute executes the request
	LspDidOpenExecute(r ToolboxAPILspDidOpenRequest) (*http.Response, error)

	/*
		LspDocumentSymbols Call Lsp DocumentSymbols

		The document symbol request is sent from the client to the server.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPILspDocumentSymbolsRequest
	*/
	LspDocumentSymbols(ctx context.Context, workspaceId string) ToolboxAPILspDocumentSymbolsRequest

	// LspDocumentSymbolsExecute executes the request
	//  @return []LspSymbol
	LspDocumentSymbolsExecute(r ToolboxAPILspDocumentSymbolsRequest) ([]LspSymbol, *http.Response, error)

	/*
		LspStart Start Lsp server

		Start Lsp server process inside workspace project

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPILspStartRequest
	*/
	LspStart(ctx context.Context, workspaceId string) ToolboxAPILspStartRequest

	// LspStartExecute executes the request
	LspStartExecute(r ToolboxAPILspStartRequest) (*http.Response, error)

	/*
		LspStop Stop Lsp server

		Stop Lsp server process inside workspace project

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPILspStopRequest
	*/
	LspStop(ctx context.Context, workspaceId string) ToolboxAPILspStopRequest

	// LspStopExecute executes the request
	LspStopExecute(r ToolboxAPILspStopRequest) (*http.Response, error)

	/*
		LspWorkspaceSymbols Call Lsp WorkspaceSymbols

		The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPILspWorkspaceSymbolsRequest
	*/
	LspWorkspaceSymbols(ctx context.Context, workspaceId string) ToolboxAPILspWorkspaceSymbolsRequest

	// LspWorkspaceSymbolsExecute executes the request
	//  @return []LspSymbol
	LspWorkspaceSymbolsExecute(r ToolboxAPILspWorkspaceSymbolsRequest) ([]LspSymbol, *http.Response, error)

	/*
		MoveFile Move file

		Move file inside workspace

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPIMoveFileRequest
	*/
	MoveFile(ctx context.Context, workspaceId string) ToolboxAPIMoveFileRequest

	// MoveFileExecute executes the request
	MoveFileExecute(r ToolboxAPIMoveFileRequest) (*http.Response, error)

	/*
		ReplaceInFiles Replace in files

		Replace text/pattern in multiple files inside workspace

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPIReplaceInFilesRequest
	*/
	ReplaceInFiles(ctx context.Context, workspaceId string) ToolboxAPIReplaceInFilesRequest

	// ReplaceInFilesExecute executes the request
	//  @return []ReplaceResult
	ReplaceInFilesExecute(r ToolboxAPIReplaceInFilesRequest) ([]ReplaceResult, *http.Response, error)

	/*
		SearchFiles Search files

		Search for files inside workspace

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPISearchFilesRequest
	*/
	SearchFiles(ctx context.Context, workspaceId string) ToolboxAPISearchFilesRequest

	// SearchFilesExecute executes the request
	//  @return SearchFilesResponse
	SearchFilesExecute(r ToolboxAPISearchFilesRequest) (*SearchFilesResponse, *http.Response, error)

	/*
		SetFilePermissions Set file permissions

		Set file owner/group/permissions inside workspace

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPISetFilePermissionsRequest
	*/
	SetFilePermissions(ctx context.Context, workspaceId string) ToolboxAPISetFilePermissionsRequest

	// SetFilePermissionsExecute executes the request
	SetFilePermissionsExecute(r ToolboxAPISetFilePermissionsRequest) (*http.Response, error)

	/*
		UploadFile Upload file

		Upload file inside workspace

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return ToolboxAPIUploadFileRequest
	*/
	UploadFile(ctx context.Context, workspaceId string) ToolboxAPIUploadFileRequest

	// UploadFileExecute executes the request
	UploadFileExecute(r ToolboxAPIUploadFileRequest) (*http.Response, error)
}

// ToolboxAPIService ToolboxAPI service
type ToolboxAPIService service

type ToolboxAPICreateFolderRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	path                   *string
	mode                   *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPICreateFolderRequest) Path(path string) ToolboxAPICreateFolderRequest {
	r.path = &path
	return r
}

func (r ToolboxAPICreateFolderRequest) Mode(mode string) ToolboxAPICreateFolderRequest {
	r.mode = &mode
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPICreateFolderRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPICreateFolderRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPICreateFolderRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateFolderExecute(r)
}

/*
CreateFolder Create folder

Create folder inside workspace

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPICreateFolderRequest
*/
func (a *ToolboxAPIService) CreateFolder(ctx context.Context, workspaceId string) ToolboxAPICreateFolderRequest {
	return ToolboxAPICreateFolderRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) CreateFolderExecute(r ToolboxAPICreateFolderRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.CreateFolder")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/files/folder"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return nil, reportError("path is required and must be specified")
	}
	if r.mode == nil {
		return nil, reportError("mode is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPICreateSessionRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	createSessionRequest   *CreateSessionRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPICreateSessionRequest) CreateSessionRequest(createSessionRequest CreateSessionRequest) ToolboxAPICreateSessionRequest {
	r.createSessionRequest = &createSessionRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPICreateSessionRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPICreateSessionRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPICreateSessionRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateSessionExecute(r)
}

/*
CreateSession Create session

Create a new session in the workspace

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPICreateSessionRequest
*/
func (a *ToolboxAPIService) CreateSession(ctx context.Context, workspaceId string) ToolboxAPICreateSessionRequest {
	return ToolboxAPICreateSessionRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) CreateSessionExecute(r ToolboxAPICreateSessionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.CreateSession")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/process/session"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createSessionRequest == nil {
		return nil, reportError("createSessionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.createSessionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIDeleteFileRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	path                   *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIDeleteFileRequest) Path(path string) ToolboxAPIDeleteFileRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIDeleteFileRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIDeleteFileRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIDeleteFileRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFileExecute(r)
}

/*
DeleteFile Delete file

Delete file inside workspace

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPIDeleteFileRequest
*/
func (a *ToolboxAPIService) DeleteFile(ctx context.Context, workspaceId string) ToolboxAPIDeleteFileRequest {
	return ToolboxAPIDeleteFileRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) DeleteFileExecute(r ToolboxAPIDeleteFileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.DeleteFile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/files"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIDeleteSessionRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	sessionId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIDeleteSessionRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIDeleteSessionRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIDeleteSessionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSessionExecute(r)
}

/*
DeleteSession Delete session

Delete a specific session

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@param sessionId
	@return ToolboxAPIDeleteSessionRequest
*/
func (a *ToolboxAPIService) DeleteSession(ctx context.Context, workspaceId string, sessionId string) ToolboxAPIDeleteSessionRequest {
	return ToolboxAPIDeleteSessionRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
		sessionId:   sessionId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) DeleteSessionExecute(r ToolboxAPIDeleteSessionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.DeleteSession")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/process/session/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIDownloadFileRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	path                   *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIDownloadFileRequest) Path(path string) ToolboxAPIDownloadFileRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIDownloadFileRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIDownloadFileRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIDownloadFileRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.DownloadFileExecute(r)
}

/*
DownloadFile Download file

Download file from workspace

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPIDownloadFileRequest
*/
func (a *ToolboxAPIService) DownloadFile(ctx context.Context, workspaceId string) ToolboxAPIDownloadFileRequest {
	return ToolboxAPIDownloadFileRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *ToolboxAPIService) DownloadFileExecute(r ToolboxAPIDownloadFileRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.DownloadFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/files/download"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIExecuteCommandRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	executeRequest         *ExecuteRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIExecuteCommandRequest) ExecuteRequest(executeRequest ExecuteRequest) ToolboxAPIExecuteCommandRequest {
	r.executeRequest = &executeRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIExecuteCommandRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIExecuteCommandRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIExecuteCommandRequest) Execute() (*ExecuteResponse, *http.Response, error) {
	return r.ApiService.ExecuteCommandExecute(r)
}

/*
ExecuteCommand Execute command

Execute command synchronously inside workspace

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPIExecuteCommandRequest
*/
func (a *ToolboxAPIService) ExecuteCommand(ctx context.Context, workspaceId string) ToolboxAPIExecuteCommandRequest {
	return ToolboxAPIExecuteCommandRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
//
//	@return ExecuteResponse
func (a *ToolboxAPIService) ExecuteCommandExecute(r ToolboxAPIExecuteCommandRequest) (*ExecuteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExecuteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.ExecuteCommand")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/process/execute"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.executeRequest == nil {
		return localVarReturnValue, nil, reportError("executeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.executeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIExecuteSessionCommandRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	sessionId              string
	sessionExecuteRequest  *SessionExecuteRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIExecuteSessionCommandRequest) SessionExecuteRequest(sessionExecuteRequest SessionExecuteRequest) ToolboxAPIExecuteSessionCommandRequest {
	r.sessionExecuteRequest = &sessionExecuteRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIExecuteSessionCommandRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIExecuteSessionCommandRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIExecuteSessionCommandRequest) Execute() (*SessionExecuteResponse, *http.Response, error) {
	return r.ApiService.ExecuteSessionCommandExecute(r)
}

/*
ExecuteSessionCommand Execute command in session

Execute a command in a specific session

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@param sessionId
	@return ToolboxAPIExecuteSessionCommandRequest
*/
func (a *ToolboxAPIService) ExecuteSessionCommand(ctx context.Context, workspaceId string, sessionId string) ToolboxAPIExecuteSessionCommandRequest {
	return ToolboxAPIExecuteSessionCommandRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
		sessionId:   sessionId,
	}
}

// Execute executes the request
//
//	@return SessionExecuteResponse
func (a *ToolboxAPIService) ExecuteSessionCommandExecute(r ToolboxAPIExecuteSessionCommandRequest) (*SessionExecuteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SessionExecuteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.ExecuteSessionCommand")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/process/session/{sessionId}/exec"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionExecuteRequest == nil {
		return localVarReturnValue, nil, reportError("sessionExecuteRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.sessionExecuteRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIFindInFilesRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	path                   *string
	pattern                *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIFindInFilesRequest) Path(path string) ToolboxAPIFindInFilesRequest {
	r.path = &path
	return r
}

func (r ToolboxAPIFindInFilesRequest) Pattern(pattern string) ToolboxAPIFindInFilesRequest {
	r.pattern = &pattern
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIFindInFilesRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIFindInFilesRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIFindInFilesRequest) Execute() ([]Match, *http.Response, error) {
	return r.ApiService.FindInFilesExecute(r)
}

/*
FindInFiles Search for text/pattern in files

Search for text/pattern inside workspace files

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPIFindInFilesRequest
*/
func (a *ToolboxAPIService) FindInFiles(ctx context.Context, workspaceId string) ToolboxAPIFindInFilesRequest {
	return ToolboxAPIFindInFilesRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
//
//	@return []Match
func (a *ToolboxAPIService) FindInFilesExecute(r ToolboxAPIFindInFilesRequest) ([]Match, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Match
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.FindInFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/files/find"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}
	if r.pattern == nil {
		return localVarReturnValue, nil, reportError("pattern is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pattern", r.pattern, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetFileInfoRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	path                   *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGetFileInfoRequest) Path(path string) ToolboxAPIGetFileInfoRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetFileInfoRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetFileInfoRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetFileInfoRequest) Execute() (*FileInfo, *http.Response, error) {
	return r.ApiService.GetFileInfoExecute(r)
}

/*
GetFileInfo Get file info

Get file info inside workspace

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPIGetFileInfoRequest
*/
func (a *ToolboxAPIService) GetFileInfo(ctx context.Context, workspaceId string) ToolboxAPIGetFileInfoRequest {
	return ToolboxAPIGetFileInfoRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
//
//	@return FileInfo
func (a *ToolboxAPIService) GetFileInfoExecute(r ToolboxAPIGetFileInfoRequest) (*FileInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FileInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetFileInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/files/info"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetProjectDirRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetProjectDirRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetProjectDirRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetProjectDirRequest) Execute() (*ProjectDirResponse, *http.Response, error) {
	return r.ApiService.GetProjectDirExecute(r)
}

/*
GetProjectDir Get workspace project dir

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPIGetProjectDirRequest
*/
func (a *ToolboxAPIService) GetProjectDir(ctx context.Context, workspaceId string) ToolboxAPIGetProjectDirRequest {
	return ToolboxAPIGetProjectDirRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
//
//	@return ProjectDirResponse
func (a *ToolboxAPIService) GetProjectDirExecute(r ToolboxAPIGetProjectDirRequest) (*ProjectDirResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProjectDirResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetProjectDir")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/project-dir"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetSessionRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	sessionId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetSessionRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetSessionRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetSessionRequest) Execute() (*Session, *http.Response, error) {
	return r.ApiService.GetSessionExecute(r)
}

/*
GetSession Get session

Get session by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@param sessionId
	@return ToolboxAPIGetSessionRequest
*/
func (a *ToolboxAPIService) GetSession(ctx context.Context, workspaceId string, sessionId string) ToolboxAPIGetSessionRequest {
	return ToolboxAPIGetSessionRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
		sessionId:   sessionId,
	}
}

// Execute executes the request
//
//	@return Session
func (a *ToolboxAPIService) GetSessionExecute(r ToolboxAPIGetSessionRequest) (*Session, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Session
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/process/session/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetSessionCommandRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	sessionId              string
	commandId              string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetSessionCommandRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetSessionCommandRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetSessionCommandRequest) Execute() (*Command, *http.Response, error) {
	return r.ApiService.GetSessionCommandExecute(r)
}

/*
GetSessionCommand Get session command

Get session command by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@param sessionId
	@param commandId
	@return ToolboxAPIGetSessionCommandRequest
*/
func (a *ToolboxAPIService) GetSessionCommand(ctx context.Context, workspaceId string, sessionId string, commandId string) ToolboxAPIGetSessionCommandRequest {
	return ToolboxAPIGetSessionCommandRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
		sessionId:   sessionId,
		commandId:   commandId,
	}
}

// Execute executes the request
//
//	@return Command
func (a *ToolboxAPIService) GetSessionCommandExecute(r ToolboxAPIGetSessionCommandRequest) (*Command, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Command
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetSessionCommand")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/process/session/{sessionId}/command/{commandId}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commandId"+"}", url.PathEscape(parameterValueToString(r.commandId, "commandId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGetSessionCommandLogsRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	sessionId              string
	commandId              string
	xDaytonaOrganizationID *string
	follow                 *bool
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGetSessionCommandLogsRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGetSessionCommandLogsRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGetSessionCommandLogsRequest) Follow(follow bool) ToolboxAPIGetSessionCommandLogsRequest {
	r.follow = &follow
	return r
}

func (r ToolboxAPIGetSessionCommandLogsRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetSessionCommandLogsExecute(r)
}

/*
GetSessionCommandLogs Get command logs

Get logs for a specific command in a session

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@param sessionId
	@param commandId
	@return ToolboxAPIGetSessionCommandLogsRequest
*/
func (a *ToolboxAPIService) GetSessionCommandLogs(ctx context.Context, workspaceId string, sessionId string, commandId string) ToolboxAPIGetSessionCommandLogsRequest {
	return ToolboxAPIGetSessionCommandLogsRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
		sessionId:   sessionId,
		commandId:   commandId,
	}
}

// Execute executes the request
//
//	@return string
func (a *ToolboxAPIService) GetSessionCommandLogsExecute(r ToolboxAPIGetSessionCommandLogsRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GetSessionCommandLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/process/session/{sessionId}/command/{commandId}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commandId"+"}", url.PathEscape(parameterValueToString(r.commandId, "commandId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.follow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "follow", r.follow, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGitAddFilesRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	gitAddRequest          *GitAddRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitAddFilesRequest) GitAddRequest(gitAddRequest GitAddRequest) ToolboxAPIGitAddFilesRequest {
	r.gitAddRequest = &gitAddRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitAddFilesRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitAddFilesRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitAddFilesRequest) Execute() (*http.Response, error) {
	return r.ApiService.GitAddFilesExecute(r)
}

/*
GitAddFiles Add files

Add files to git commit

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPIGitAddFilesRequest
*/
func (a *ToolboxAPIService) GitAddFiles(ctx context.Context, workspaceId string) ToolboxAPIGitAddFilesRequest {
	return ToolboxAPIGitAddFilesRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) GitAddFilesExecute(r ToolboxAPIGitAddFilesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitAddFiles")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/git/add"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitAddRequest == nil {
		return nil, reportError("gitAddRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.gitAddRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIGitCloneRepositoryRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	gitCloneRequest        *GitCloneRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitCloneRepositoryRequest) GitCloneRequest(gitCloneRequest GitCloneRequest) ToolboxAPIGitCloneRepositoryRequest {
	r.gitCloneRequest = &gitCloneRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitCloneRepositoryRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitCloneRepositoryRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitCloneRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.GitCloneRepositoryExecute(r)
}

/*
GitCloneRepository Clone repository

Clone git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPIGitCloneRepositoryRequest
*/
func (a *ToolboxAPIService) GitCloneRepository(ctx context.Context, workspaceId string) ToolboxAPIGitCloneRepositoryRequest {
	return ToolboxAPIGitCloneRepositoryRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) GitCloneRepositoryExecute(r ToolboxAPIGitCloneRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitCloneRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/git/clone"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitCloneRequest == nil {
		return nil, reportError("gitCloneRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.gitCloneRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIGitCommitChangesRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	gitCommitRequest       *GitCommitRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitCommitChangesRequest) GitCommitRequest(gitCommitRequest GitCommitRequest) ToolboxAPIGitCommitChangesRequest {
	r.gitCommitRequest = &gitCommitRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitCommitChangesRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitCommitChangesRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitCommitChangesRequest) Execute() (*GitCommitResponse, *http.Response, error) {
	return r.ApiService.GitCommitChangesExecute(r)
}

/*
GitCommitChanges Commit changes

Commit changes to git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPIGitCommitChangesRequest
*/
func (a *ToolboxAPIService) GitCommitChanges(ctx context.Context, workspaceId string) ToolboxAPIGitCommitChangesRequest {
	return ToolboxAPIGitCommitChangesRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
//
//	@return GitCommitResponse
func (a *ToolboxAPIService) GitCommitChangesExecute(r ToolboxAPIGitCommitChangesRequest) (*GitCommitResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GitCommitResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitCommitChanges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/git/commit"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitCommitRequest == nil {
		return localVarReturnValue, nil, reportError("gitCommitRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.gitCommitRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGitCreateBranchRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	gitBranchRequest       *GitBranchRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitCreateBranchRequest) GitBranchRequest(gitBranchRequest GitBranchRequest) ToolboxAPIGitCreateBranchRequest {
	r.gitBranchRequest = &gitBranchRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitCreateBranchRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitCreateBranchRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitCreateBranchRequest) Execute() (*http.Response, error) {
	return r.ApiService.GitCreateBranchExecute(r)
}

/*
GitCreateBranch Create branch

Create branch on git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPIGitCreateBranchRequest
*/
func (a *ToolboxAPIService) GitCreateBranch(ctx context.Context, workspaceId string) ToolboxAPIGitCreateBranchRequest {
	return ToolboxAPIGitCreateBranchRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) GitCreateBranchExecute(r ToolboxAPIGitCreateBranchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitCreateBranch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/git/branches"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitBranchRequest == nil {
		return nil, reportError("gitBranchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.gitBranchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIGitGetHistoryRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	path                   *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitGetHistoryRequest) Path(path string) ToolboxAPIGitGetHistoryRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitGetHistoryRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitGetHistoryRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitGetHistoryRequest) Execute() ([]GitCommitInfo, *http.Response, error) {
	return r.ApiService.GitGetHistoryExecute(r)
}

/*
GitGetHistory Get commit history

Get commit history from git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPIGitGetHistoryRequest
*/
func (a *ToolboxAPIService) GitGetHistory(ctx context.Context, workspaceId string) ToolboxAPIGitGetHistoryRequest {
	return ToolboxAPIGitGetHistoryRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
//
//	@return []GitCommitInfo
func (a *ToolboxAPIService) GitGetHistoryExecute(r ToolboxAPIGitGetHistoryRequest) ([]GitCommitInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []GitCommitInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitGetHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/git/history"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGitGetStatusRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	path                   *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitGetStatusRequest) Path(path string) ToolboxAPIGitGetStatusRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitGetStatusRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitGetStatusRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitGetStatusRequest) Execute() (*GitStatus, *http.Response, error) {
	return r.ApiService.GitGetStatusExecute(r)
}

/*
GitGetStatus Get git status

Get status from git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPIGitGetStatusRequest
*/
func (a *ToolboxAPIService) GitGetStatus(ctx context.Context, workspaceId string) ToolboxAPIGitGetStatusRequest {
	return ToolboxAPIGitGetStatusRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
//
//	@return GitStatus
func (a *ToolboxAPIService) GitGetStatusExecute(r ToolboxAPIGitGetStatusRequest) (*GitStatus, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GitStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitGetStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/git/status"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGitListBranchesRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	path                   *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitListBranchesRequest) Path(path string) ToolboxAPIGitListBranchesRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitListBranchesRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitListBranchesRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitListBranchesRequest) Execute() (*ListBranchResponse, *http.Response, error) {
	return r.ApiService.GitListBranchesExecute(r)
}

/*
GitListBranches Get branch list

Get branch list from git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPIGitListBranchesRequest
*/
func (a *ToolboxAPIService) GitListBranches(ctx context.Context, workspaceId string) ToolboxAPIGitListBranchesRequest {
	return ToolboxAPIGitListBranchesRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
//
//	@return ListBranchResponse
func (a *ToolboxAPIService) GitListBranchesExecute(r ToolboxAPIGitListBranchesRequest) (*ListBranchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListBranchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitListBranches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/git/branches"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIGitPullChangesRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	gitRepoRequest         *GitRepoRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitPullChangesRequest) GitRepoRequest(gitRepoRequest GitRepoRequest) ToolboxAPIGitPullChangesRequest {
	r.gitRepoRequest = &gitRepoRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitPullChangesRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitPullChangesRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitPullChangesRequest) Execute() (*http.Response, error) {
	return r.ApiService.GitPullChangesExecute(r)
}

/*
GitPullChanges Pull changes

Pull changes from remote

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPIGitPullChangesRequest
*/
func (a *ToolboxAPIService) GitPullChanges(ctx context.Context, workspaceId string) ToolboxAPIGitPullChangesRequest {
	return ToolboxAPIGitPullChangesRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) GitPullChangesExecute(r ToolboxAPIGitPullChangesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitPullChanges")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/git/pull"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitRepoRequest == nil {
		return nil, reportError("gitRepoRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.gitRepoRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIGitPushChangesRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	gitRepoRequest         *GitRepoRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIGitPushChangesRequest) GitRepoRequest(gitRepoRequest GitRepoRequest) ToolboxAPIGitPushChangesRequest {
	r.gitRepoRequest = &gitRepoRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIGitPushChangesRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIGitPushChangesRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIGitPushChangesRequest) Execute() (*http.Response, error) {
	return r.ApiService.GitPushChangesExecute(r)
}

/*
GitPushChanges Push changes

Push changes to remote

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPIGitPushChangesRequest
*/
func (a *ToolboxAPIService) GitPushChanges(ctx context.Context, workspaceId string) ToolboxAPIGitPushChangesRequest {
	return ToolboxAPIGitPushChangesRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) GitPushChangesExecute(r ToolboxAPIGitPushChangesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.GitPushChanges")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/git/push"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitRepoRequest == nil {
		return nil, reportError("gitRepoRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.gitRepoRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIListFilesRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	xDaytonaOrganizationID *string
	path                   *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIListFilesRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIListFilesRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIListFilesRequest) Path(path string) ToolboxAPIListFilesRequest {
	r.path = &path
	return r
}

func (r ToolboxAPIListFilesRequest) Execute() ([]FileInfo, *http.Response, error) {
	return r.ApiService.ListFilesExecute(r)
}

/*
ListFiles List files

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPIListFilesRequest
*/
func (a *ToolboxAPIService) ListFiles(ctx context.Context, workspaceId string) ToolboxAPIListFilesRequest {
	return ToolboxAPIListFilesRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
//
//	@return []FileInfo
func (a *ToolboxAPIService) ListFilesExecute(r ToolboxAPIListFilesRequest) ([]FileInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []FileInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.ListFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/files"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIListSessionsRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIListSessionsRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIListSessionsRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIListSessionsRequest) Execute() ([]Session, *http.Response, error) {
	return r.ApiService.ListSessionsExecute(r)
}

/*
ListSessions List sessions

List all active sessions in the workspace

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPIListSessionsRequest
*/
func (a *ToolboxAPIService) ListSessions(ctx context.Context, workspaceId string) ToolboxAPIListSessionsRequest {
	return ToolboxAPIListSessionsRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
//
//	@return []Session
func (a *ToolboxAPIService) ListSessionsExecute(r ToolboxAPIListSessionsRequest) ([]Session, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Session
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.ListSessions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/process/session"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPILspCompletionsRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	lspCompletionParams    *LspCompletionParams
	xDaytonaOrganizationID *string
}

func (r ToolboxAPILspCompletionsRequest) LspCompletionParams(lspCompletionParams LspCompletionParams) ToolboxAPILspCompletionsRequest {
	r.lspCompletionParams = &lspCompletionParams
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPILspCompletionsRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPILspCompletionsRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPILspCompletionsRequest) Execute() (*CompletionList, *http.Response, error) {
	return r.ApiService.LspCompletionsExecute(r)
}

/*
LspCompletions Get Lsp Completions

The Completion request is sent from the client to the server to compute completion items at a given cursor position.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPILspCompletionsRequest
*/
func (a *ToolboxAPIService) LspCompletions(ctx context.Context, workspaceId string) ToolboxAPILspCompletionsRequest {
	return ToolboxAPILspCompletionsRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
//
//	@return CompletionList
func (a *ToolboxAPIService) LspCompletionsExecute(r ToolboxAPILspCompletionsRequest) (*CompletionList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CompletionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.LspCompletions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/lsp/completions"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lspCompletionParams == nil {
		return localVarReturnValue, nil, reportError("lspCompletionParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.lspCompletionParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPILspDidCloseRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	lspDocumentRequest     *LspDocumentRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPILspDidCloseRequest) LspDocumentRequest(lspDocumentRequest LspDocumentRequest) ToolboxAPILspDidCloseRequest {
	r.lspDocumentRequest = &lspDocumentRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPILspDidCloseRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPILspDidCloseRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPILspDidCloseRequest) Execute() (*http.Response, error) {
	return r.ApiService.LspDidCloseExecute(r)
}

/*
LspDidClose Call Lsp DidClose

The document close notification is sent from the client to the server when the document got closed in the client.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPILspDidCloseRequest
*/
func (a *ToolboxAPIService) LspDidClose(ctx context.Context, workspaceId string) ToolboxAPILspDidCloseRequest {
	return ToolboxAPILspDidCloseRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) LspDidCloseExecute(r ToolboxAPILspDidCloseRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.LspDidClose")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/lsp/did-close"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lspDocumentRequest == nil {
		return nil, reportError("lspDocumentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.lspDocumentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPILspDidOpenRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	lspDocumentRequest     *LspDocumentRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPILspDidOpenRequest) LspDocumentRequest(lspDocumentRequest LspDocumentRequest) ToolboxAPILspDidOpenRequest {
	r.lspDocumentRequest = &lspDocumentRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPILspDidOpenRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPILspDidOpenRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPILspDidOpenRequest) Execute() (*http.Response, error) {
	return r.ApiService.LspDidOpenExecute(r)
}

/*
LspDidOpen Call Lsp DidOpen

The document open notification is sent from the client to the server to signal newly opened text documents.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPILspDidOpenRequest
*/
func (a *ToolboxAPIService) LspDidOpen(ctx context.Context, workspaceId string) ToolboxAPILspDidOpenRequest {
	return ToolboxAPILspDidOpenRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) LspDidOpenExecute(r ToolboxAPILspDidOpenRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.LspDidOpen")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/lsp/did-open"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lspDocumentRequest == nil {
		return nil, reportError("lspDocumentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.lspDocumentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPILspDocumentSymbolsRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	languageId             *string
	pathToProject          *string
	uri                    *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPILspDocumentSymbolsRequest) LanguageId(languageId string) ToolboxAPILspDocumentSymbolsRequest {
	r.languageId = &languageId
	return r
}

func (r ToolboxAPILspDocumentSymbolsRequest) PathToProject(pathToProject string) ToolboxAPILspDocumentSymbolsRequest {
	r.pathToProject = &pathToProject
	return r
}

func (r ToolboxAPILspDocumentSymbolsRequest) Uri(uri string) ToolboxAPILspDocumentSymbolsRequest {
	r.uri = &uri
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPILspDocumentSymbolsRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPILspDocumentSymbolsRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPILspDocumentSymbolsRequest) Execute() ([]LspSymbol, *http.Response, error) {
	return r.ApiService.LspDocumentSymbolsExecute(r)
}

/*
LspDocumentSymbols Call Lsp DocumentSymbols

The document symbol request is sent from the client to the server.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPILspDocumentSymbolsRequest
*/
func (a *ToolboxAPIService) LspDocumentSymbols(ctx context.Context, workspaceId string) ToolboxAPILspDocumentSymbolsRequest {
	return ToolboxAPILspDocumentSymbolsRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
//
//	@return []LspSymbol
func (a *ToolboxAPIService) LspDocumentSymbolsExecute(r ToolboxAPILspDocumentSymbolsRequest) ([]LspSymbol, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []LspSymbol
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.LspDocumentSymbols")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/lsp/document-symbols"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.languageId == nil {
		return localVarReturnValue, nil, reportError("languageId is required and must be specified")
	}
	if r.pathToProject == nil {
		return localVarReturnValue, nil, reportError("pathToProject is required and must be specified")
	}
	if r.uri == nil {
		return localVarReturnValue, nil, reportError("uri is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "languageId", r.languageId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pathToProject", r.pathToProject, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "uri", r.uri, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPILspStartRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	lspServerRequest       *LspServerRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPILspStartRequest) LspServerRequest(lspServerRequest LspServerRequest) ToolboxAPILspStartRequest {
	r.lspServerRequest = &lspServerRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPILspStartRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPILspStartRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPILspStartRequest) Execute() (*http.Response, error) {
	return r.ApiService.LspStartExecute(r)
}

/*
LspStart Start Lsp server

Start Lsp server process inside workspace project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPILspStartRequest
*/
func (a *ToolboxAPIService) LspStart(ctx context.Context, workspaceId string) ToolboxAPILspStartRequest {
	return ToolboxAPILspStartRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) LspStartExecute(r ToolboxAPILspStartRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.LspStart")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/lsp/start"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lspServerRequest == nil {
		return nil, reportError("lspServerRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.lspServerRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPILspStopRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	lspServerRequest       *LspServerRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPILspStopRequest) LspServerRequest(lspServerRequest LspServerRequest) ToolboxAPILspStopRequest {
	r.lspServerRequest = &lspServerRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPILspStopRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPILspStopRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPILspStopRequest) Execute() (*http.Response, error) {
	return r.ApiService.LspStopExecute(r)
}

/*
LspStop Stop Lsp server

Stop Lsp server process inside workspace project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPILspStopRequest
*/
func (a *ToolboxAPIService) LspStop(ctx context.Context, workspaceId string) ToolboxAPILspStopRequest {
	return ToolboxAPILspStopRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) LspStopExecute(r ToolboxAPILspStopRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.LspStop")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/lsp/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lspServerRequest == nil {
		return nil, reportError("lspServerRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.lspServerRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPILspWorkspaceSymbolsRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	languageId             *string
	pathToProject          *string
	query                  *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPILspWorkspaceSymbolsRequest) LanguageId(languageId string) ToolboxAPILspWorkspaceSymbolsRequest {
	r.languageId = &languageId
	return r
}

func (r ToolboxAPILspWorkspaceSymbolsRequest) PathToProject(pathToProject string) ToolboxAPILspWorkspaceSymbolsRequest {
	r.pathToProject = &pathToProject
	return r
}

func (r ToolboxAPILspWorkspaceSymbolsRequest) Query(query string) ToolboxAPILspWorkspaceSymbolsRequest {
	r.query = &query
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPILspWorkspaceSymbolsRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPILspWorkspaceSymbolsRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPILspWorkspaceSymbolsRequest) Execute() ([]LspSymbol, *http.Response, error) {
	return r.ApiService.LspWorkspaceSymbolsExecute(r)
}

/*
LspWorkspaceSymbols Call Lsp WorkspaceSymbols

The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPILspWorkspaceSymbolsRequest
*/
func (a *ToolboxAPIService) LspWorkspaceSymbols(ctx context.Context, workspaceId string) ToolboxAPILspWorkspaceSymbolsRequest {
	return ToolboxAPILspWorkspaceSymbolsRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
//
//	@return []LspSymbol
func (a *ToolboxAPIService) LspWorkspaceSymbolsExecute(r ToolboxAPILspWorkspaceSymbolsRequest) ([]LspSymbol, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []LspSymbol
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.LspWorkspaceSymbols")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/lsp/workspace-symbols"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.languageId == nil {
		return localVarReturnValue, nil, reportError("languageId is required and must be specified")
	}
	if r.pathToProject == nil {
		return localVarReturnValue, nil, reportError("pathToProject is required and must be specified")
	}
	if r.query == nil {
		return localVarReturnValue, nil, reportError("query is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "languageId", r.languageId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pathToProject", r.pathToProject, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPIMoveFileRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	source                 *string
	destination            *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIMoveFileRequest) Source(source string) ToolboxAPIMoveFileRequest {
	r.source = &source
	return r
}

func (r ToolboxAPIMoveFileRequest) Destination(destination string) ToolboxAPIMoveFileRequest {
	r.destination = &destination
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIMoveFileRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIMoveFileRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIMoveFileRequest) Execute() (*http.Response, error) {
	return r.ApiService.MoveFileExecute(r)
}

/*
MoveFile Move file

Move file inside workspace

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPIMoveFileRequest
*/
func (a *ToolboxAPIService) MoveFile(ctx context.Context, workspaceId string) ToolboxAPIMoveFileRequest {
	return ToolboxAPIMoveFileRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) MoveFileExecute(r ToolboxAPIMoveFileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.MoveFile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/files/move"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.source == nil {
		return nil, reportError("source is required and must be specified")
	}
	if r.destination == nil {
		return nil, reportError("destination is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "destination", r.destination, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIReplaceInFilesRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	replaceRequest         *ReplaceRequest
	xDaytonaOrganizationID *string
}

func (r ToolboxAPIReplaceInFilesRequest) ReplaceRequest(replaceRequest ReplaceRequest) ToolboxAPIReplaceInFilesRequest {
	r.replaceRequest = &replaceRequest
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIReplaceInFilesRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIReplaceInFilesRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIReplaceInFilesRequest) Execute() ([]ReplaceResult, *http.Response, error) {
	return r.ApiService.ReplaceInFilesExecute(r)
}

/*
ReplaceInFiles Replace in files

Replace text/pattern in multiple files inside workspace

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPIReplaceInFilesRequest
*/
func (a *ToolboxAPIService) ReplaceInFiles(ctx context.Context, workspaceId string) ToolboxAPIReplaceInFilesRequest {
	return ToolboxAPIReplaceInFilesRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
//
//	@return []ReplaceResult
func (a *ToolboxAPIService) ReplaceInFilesExecute(r ToolboxAPIReplaceInFilesRequest) ([]ReplaceResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ReplaceResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.ReplaceInFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/files/replace"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.replaceRequest == nil {
		return localVarReturnValue, nil, reportError("replaceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.replaceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPISearchFilesRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	path                   *string
	pattern                *string
	xDaytonaOrganizationID *string
}

func (r ToolboxAPISearchFilesRequest) Path(path string) ToolboxAPISearchFilesRequest {
	r.path = &path
	return r
}

func (r ToolboxAPISearchFilesRequest) Pattern(pattern string) ToolboxAPISearchFilesRequest {
	r.pattern = &pattern
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPISearchFilesRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPISearchFilesRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPISearchFilesRequest) Execute() (*SearchFilesResponse, *http.Response, error) {
	return r.ApiService.SearchFilesExecute(r)
}

/*
SearchFiles Search files

Search for files inside workspace

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPISearchFilesRequest
*/
func (a *ToolboxAPIService) SearchFiles(ctx context.Context, workspaceId string) ToolboxAPISearchFilesRequest {
	return ToolboxAPISearchFilesRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
//
//	@return SearchFilesResponse
func (a *ToolboxAPIService) SearchFilesExecute(r ToolboxAPISearchFilesRequest) (*SearchFilesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SearchFilesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.SearchFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/files/search"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}
	if r.pattern == nil {
		return localVarReturnValue, nil, reportError("pattern is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pattern", r.pattern, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ToolboxAPISetFilePermissionsRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	path                   *string
	xDaytonaOrganizationID *string
	owner                  *string
	group                  *string
	mode                   *string
}

func (r ToolboxAPISetFilePermissionsRequest) Path(path string) ToolboxAPISetFilePermissionsRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPISetFilePermissionsRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPISetFilePermissionsRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPISetFilePermissionsRequest) Owner(owner string) ToolboxAPISetFilePermissionsRequest {
	r.owner = &owner
	return r
}

func (r ToolboxAPISetFilePermissionsRequest) Group(group string) ToolboxAPISetFilePermissionsRequest {
	r.group = &group
	return r
}

func (r ToolboxAPISetFilePermissionsRequest) Mode(mode string) ToolboxAPISetFilePermissionsRequest {
	r.mode = &mode
	return r
}

func (r ToolboxAPISetFilePermissionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetFilePermissionsExecute(r)
}

/*
SetFilePermissions Set file permissions

Set file owner/group/permissions inside workspace

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPISetFilePermissionsRequest
*/
func (a *ToolboxAPIService) SetFilePermissions(ctx context.Context, workspaceId string) ToolboxAPISetFilePermissionsRequest {
	return ToolboxAPISetFilePermissionsRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) SetFilePermissionsExecute(r ToolboxAPISetFilePermissionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.SetFilePermissions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/files/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	if r.owner != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "owner", r.owner, "form", "")
	}
	if r.group != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group", r.group, "form", "")
	}
	if r.mode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ToolboxAPIUploadFileRequest struct {
	ctx                    context.Context
	ApiService             ToolboxAPI
	workspaceId            string
	path                   *string
	xDaytonaOrganizationID *string
	file                   *os.File
}

func (r ToolboxAPIUploadFileRequest) Path(path string) ToolboxAPIUploadFileRequest {
	r.path = &path
	return r
}

// Use with JWT to specify the organization ID
func (r ToolboxAPIUploadFileRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) ToolboxAPIUploadFileRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r ToolboxAPIUploadFileRequest) File(file *os.File) ToolboxAPIUploadFileRequest {
	r.file = file
	return r
}

func (r ToolboxAPIUploadFileRequest) Execute() (*http.Response, error) {
	return r.ApiService.UploadFileExecute(r)
}

/*
UploadFile Upload file

Upload file inside workspace

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return ToolboxAPIUploadFileRequest
*/
func (a *ToolboxAPIService) UploadFile(ctx context.Context, workspaceId string) ToolboxAPIUploadFileRequest {
	return ToolboxAPIUploadFileRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
func (a *ToolboxAPIService) UploadFileExecute(r ToolboxAPIUploadFileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolboxAPIService.UploadFile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/toolbox/{workspaceId}/toolbox/files/upload"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName string
	var fileLocalVarFileBytes []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
