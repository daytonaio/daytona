/*
Daytona

Daytona AI platform API Docs

API version: 1.0
Contact: support@daytona.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package daytonaapiclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type WorkspaceAPI interface {

	/*
		ArchiveWorkspace Archive workspace

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId
		@return WorkspaceAPIArchiveWorkspaceRequest
	*/
	ArchiveWorkspace(ctx context.Context, workspaceId string) WorkspaceAPIArchiveWorkspaceRequest

	// ArchiveWorkspaceExecute executes the request
	ArchiveWorkspaceExecute(r WorkspaceAPIArchiveWorkspaceRequest) (*http.Response, error)

	/*
		CreateSnapshot Create workspace snapshot

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId ID of the workspace
		@return WorkspaceAPICreateSnapshotRequest
	*/
	CreateSnapshot(ctx context.Context, workspaceId string) WorkspaceAPICreateSnapshotRequest

	// CreateSnapshotExecute executes the request
	//  @return Workspace
	CreateSnapshotExecute(r WorkspaceAPICreateSnapshotRequest) (*Workspace, *http.Response, error)

	/*
		CreateWorkspace Create a new workspace

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return WorkspaceAPICreateWorkspaceRequest
	*/
	CreateWorkspace(ctx context.Context) WorkspaceAPICreateWorkspaceRequest

	// CreateWorkspaceExecute executes the request
	//  @return Workspace
	CreateWorkspaceExecute(r WorkspaceAPICreateWorkspaceRequest) (*Workspace, *http.Response, error)

	/*
		DeleteWorkspace Delete workspace

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId ID of the workspace
		@return WorkspaceAPIDeleteWorkspaceRequest
	*/
	DeleteWorkspace(ctx context.Context, workspaceId string) WorkspaceAPIDeleteWorkspaceRequest

	// DeleteWorkspaceExecute executes the request
	DeleteWorkspaceExecute(r WorkspaceAPIDeleteWorkspaceRequest) (*http.Response, error)

	/*
		GetBuildLogs Get build logs

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId ID of the workspace
		@return WorkspaceAPIGetBuildLogsRequest
	*/
	GetBuildLogs(ctx context.Context, workspaceId string) WorkspaceAPIGetBuildLogsRequest

	// GetBuildLogsExecute executes the request
	GetBuildLogsExecute(r WorkspaceAPIGetBuildLogsRequest) (*http.Response, error)

	/*
		GetPortPreviewUrl Get preview URL for a workspace port

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId ID of the workspace
		@param port Port number to get preview URL for
		@return WorkspaceAPIGetPortPreviewUrlRequest
	*/
	GetPortPreviewUrl(ctx context.Context, workspaceId string, port float32) WorkspaceAPIGetPortPreviewUrlRequest

	// GetPortPreviewUrlExecute executes the request
	//  @return PortPreviewUrl
	GetPortPreviewUrlExecute(r WorkspaceAPIGetPortPreviewUrlRequest) (*PortPreviewUrl, *http.Response, error)

	/*
		GetWorkspace Get workspace details

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId ID of the workspace
		@return WorkspaceAPIGetWorkspaceRequest
	*/
	GetWorkspace(ctx context.Context, workspaceId string) WorkspaceAPIGetWorkspaceRequest

	// GetWorkspaceExecute executes the request
	//  @return Workspace
	GetWorkspaceExecute(r WorkspaceAPIGetWorkspaceRequest) (*Workspace, *http.Response, error)

	/*
		ListWorkspaces List all workspaces

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return WorkspaceAPIListWorkspacesRequest
	*/
	ListWorkspaces(ctx context.Context) WorkspaceAPIListWorkspacesRequest

	// ListWorkspacesExecute executes the request
	//  @return []Workspace
	ListWorkspacesExecute(r WorkspaceAPIListWorkspacesRequest) ([]Workspace, *http.Response, error)

	/*
		ReplaceLabels Replace workspace labels

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId ID of the workspace
		@return WorkspaceAPIReplaceLabelsRequest
	*/
	ReplaceLabels(ctx context.Context, workspaceId string) WorkspaceAPIReplaceLabelsRequest

	// ReplaceLabelsExecute executes the request
	//  @return WorkspaceLabels
	ReplaceLabelsExecute(r WorkspaceAPIReplaceLabelsRequest) (*WorkspaceLabels, *http.Response, error)

	/*
		SetAutostopInterval Set workspace auto-stop interval

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId ID of the workspace
		@param interval Auto-stop interval in minutes (0 to disable)
		@return WorkspaceAPISetAutostopIntervalRequest
	*/
	SetAutostopInterval(ctx context.Context, workspaceId string, interval float32) WorkspaceAPISetAutostopIntervalRequest

	// SetAutostopIntervalExecute executes the request
	SetAutostopIntervalExecute(r WorkspaceAPISetAutostopIntervalRequest) (*http.Response, error)

	/*
		StartWorkspace Start workspace

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId ID of the workspace
		@return WorkspaceAPIStartWorkspaceRequest
	*/
	StartWorkspace(ctx context.Context, workspaceId string) WorkspaceAPIStartWorkspaceRequest

	// StartWorkspaceExecute executes the request
	StartWorkspaceExecute(r WorkspaceAPIStartWorkspaceRequest) (*http.Response, error)

	/*
		StopWorkspace Stop workspace

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId ID of the workspace
		@return WorkspaceAPIStopWorkspaceRequest
	*/
	StopWorkspace(ctx context.Context, workspaceId string) WorkspaceAPIStopWorkspaceRequest

	// StopWorkspaceExecute executes the request
	StopWorkspaceExecute(r WorkspaceAPIStopWorkspaceRequest) (*http.Response, error)

	/*
		UpdatePublicStatus Update public status

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param workspaceId ID of the workspace
		@param isPublic Public status to set
		@return WorkspaceAPIUpdatePublicStatusRequest
	*/
	UpdatePublicStatus(ctx context.Context, workspaceId string, isPublic bool) WorkspaceAPIUpdatePublicStatusRequest

	// UpdatePublicStatusExecute executes the request
	UpdatePublicStatusExecute(r WorkspaceAPIUpdatePublicStatusRequest) (*http.Response, error)
}

// WorkspaceAPIService WorkspaceAPI service
type WorkspaceAPIService service

type WorkspaceAPIArchiveWorkspaceRequest struct {
	ctx                    context.Context
	ApiService             WorkspaceAPI
	workspaceId            string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r WorkspaceAPIArchiveWorkspaceRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) WorkspaceAPIArchiveWorkspaceRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r WorkspaceAPIArchiveWorkspaceRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveWorkspaceExecute(r)
}

/*
ArchiveWorkspace Archive workspace

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId
	@return WorkspaceAPIArchiveWorkspaceRequest
*/
func (a *WorkspaceAPIService) ArchiveWorkspace(ctx context.Context, workspaceId string) WorkspaceAPIArchiveWorkspaceRequest {
	return WorkspaceAPIArchiveWorkspaceRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
func (a *WorkspaceAPIService) ArchiveWorkspaceExecute(r WorkspaceAPIArchiveWorkspaceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspaceAPIService.ArchiveWorkspace")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspace/{workspaceId}/archive"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type WorkspaceAPICreateSnapshotRequest struct {
	ctx                    context.Context
	ApiService             WorkspaceAPI
	workspaceId            string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r WorkspaceAPICreateSnapshotRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) WorkspaceAPICreateSnapshotRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r WorkspaceAPICreateSnapshotRequest) Execute() (*Workspace, *http.Response, error) {
	return r.ApiService.CreateSnapshotExecute(r)
}

/*
CreateSnapshot Create workspace snapshot

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId ID of the workspace
	@return WorkspaceAPICreateSnapshotRequest
*/
func (a *WorkspaceAPIService) CreateSnapshot(ctx context.Context, workspaceId string) WorkspaceAPICreateSnapshotRequest {
	return WorkspaceAPICreateSnapshotRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
//
//	@return Workspace
func (a *WorkspaceAPIService) CreateSnapshotExecute(r WorkspaceAPICreateSnapshotRequest) (*Workspace, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Workspace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspaceAPIService.CreateSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspace/{workspaceId}/snapshot"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkspaceAPICreateWorkspaceRequest struct {
	ctx                    context.Context
	ApiService             WorkspaceAPI
	createWorkspace        *CreateWorkspace
	xDaytonaOrganizationID *string
}

func (r WorkspaceAPICreateWorkspaceRequest) CreateWorkspace(createWorkspace CreateWorkspace) WorkspaceAPICreateWorkspaceRequest {
	r.createWorkspace = &createWorkspace
	return r
}

// Use with JWT to specify the organization ID
func (r WorkspaceAPICreateWorkspaceRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) WorkspaceAPICreateWorkspaceRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r WorkspaceAPICreateWorkspaceRequest) Execute() (*Workspace, *http.Response, error) {
	return r.ApiService.CreateWorkspaceExecute(r)
}

/*
CreateWorkspace Create a new workspace

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return WorkspaceAPICreateWorkspaceRequest
*/
func (a *WorkspaceAPIService) CreateWorkspace(ctx context.Context) WorkspaceAPICreateWorkspaceRequest {
	return WorkspaceAPICreateWorkspaceRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Workspace
func (a *WorkspaceAPIService) CreateWorkspaceExecute(r WorkspaceAPICreateWorkspaceRequest) (*Workspace, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Workspace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspaceAPIService.CreateWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspace"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createWorkspace == nil {
		return localVarReturnValue, nil, reportError("createWorkspace is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.createWorkspace
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkspaceAPIDeleteWorkspaceRequest struct {
	ctx                    context.Context
	ApiService             WorkspaceAPI
	workspaceId            string
	force                  *bool
	xDaytonaOrganizationID *string
}

func (r WorkspaceAPIDeleteWorkspaceRequest) Force(force bool) WorkspaceAPIDeleteWorkspaceRequest {
	r.force = &force
	return r
}

// Use with JWT to specify the organization ID
func (r WorkspaceAPIDeleteWorkspaceRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) WorkspaceAPIDeleteWorkspaceRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r WorkspaceAPIDeleteWorkspaceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteWorkspaceExecute(r)
}

/*
DeleteWorkspace Delete workspace

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId ID of the workspace
	@return WorkspaceAPIDeleteWorkspaceRequest
*/
func (a *WorkspaceAPIService) DeleteWorkspace(ctx context.Context, workspaceId string) WorkspaceAPIDeleteWorkspaceRequest {
	return WorkspaceAPIDeleteWorkspaceRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
func (a *WorkspaceAPIService) DeleteWorkspaceExecute(r WorkspaceAPIDeleteWorkspaceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspaceAPIService.DeleteWorkspace")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspace/{workspaceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.force == nil {
		return nil, reportError("force is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type WorkspaceAPIGetBuildLogsRequest struct {
	ctx                    context.Context
	ApiService             WorkspaceAPI
	workspaceId            string
	xDaytonaOrganizationID *string
	follow                 *bool
}

// Use with JWT to specify the organization ID
func (r WorkspaceAPIGetBuildLogsRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) WorkspaceAPIGetBuildLogsRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

// Whether to follow the logs stream
func (r WorkspaceAPIGetBuildLogsRequest) Follow(follow bool) WorkspaceAPIGetBuildLogsRequest {
	r.follow = &follow
	return r
}

func (r WorkspaceAPIGetBuildLogsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetBuildLogsExecute(r)
}

/*
GetBuildLogs Get build logs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId ID of the workspace
	@return WorkspaceAPIGetBuildLogsRequest
*/
func (a *WorkspaceAPIService) GetBuildLogs(ctx context.Context, workspaceId string) WorkspaceAPIGetBuildLogsRequest {
	return WorkspaceAPIGetBuildLogsRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
func (a *WorkspaceAPIService) GetBuildLogsExecute(r WorkspaceAPIGetBuildLogsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspaceAPIService.GetBuildLogs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspace/{workspaceId}/build-logs"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.follow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "follow", r.follow, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type WorkspaceAPIGetPortPreviewUrlRequest struct {
	ctx                    context.Context
	ApiService             WorkspaceAPI
	workspaceId            string
	port                   float32
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r WorkspaceAPIGetPortPreviewUrlRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) WorkspaceAPIGetPortPreviewUrlRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r WorkspaceAPIGetPortPreviewUrlRequest) Execute() (*PortPreviewUrl, *http.Response, error) {
	return r.ApiService.GetPortPreviewUrlExecute(r)
}

/*
GetPortPreviewUrl Get preview URL for a workspace port

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId ID of the workspace
	@param port Port number to get preview URL for
	@return WorkspaceAPIGetPortPreviewUrlRequest
*/
func (a *WorkspaceAPIService) GetPortPreviewUrl(ctx context.Context, workspaceId string, port float32) WorkspaceAPIGetPortPreviewUrlRequest {
	return WorkspaceAPIGetPortPreviewUrlRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
		port:        port,
	}
}

// Execute executes the request
//
//	@return PortPreviewUrl
func (a *WorkspaceAPIService) GetPortPreviewUrlExecute(r WorkspaceAPIGetPortPreviewUrlRequest) (*PortPreviewUrl, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PortPreviewUrl
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspaceAPIService.GetPortPreviewUrl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspace/{workspaceId}/ports/{port}/preview-url"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"port"+"}", url.PathEscape(parameterValueToString(r.port, "port")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkspaceAPIGetWorkspaceRequest struct {
	ctx                    context.Context
	ApiService             WorkspaceAPI
	workspaceId            string
	xDaytonaOrganizationID *string
	verbose                *bool
}

// Use with JWT to specify the organization ID
func (r WorkspaceAPIGetWorkspaceRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) WorkspaceAPIGetWorkspaceRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

// Include verbose output
func (r WorkspaceAPIGetWorkspaceRequest) Verbose(verbose bool) WorkspaceAPIGetWorkspaceRequest {
	r.verbose = &verbose
	return r
}

func (r WorkspaceAPIGetWorkspaceRequest) Execute() (*Workspace, *http.Response, error) {
	return r.ApiService.GetWorkspaceExecute(r)
}

/*
GetWorkspace Get workspace details

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId ID of the workspace
	@return WorkspaceAPIGetWorkspaceRequest
*/
func (a *WorkspaceAPIService) GetWorkspace(ctx context.Context, workspaceId string) WorkspaceAPIGetWorkspaceRequest {
	return WorkspaceAPIGetWorkspaceRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
//
//	@return Workspace
func (a *WorkspaceAPIService) GetWorkspaceExecute(r WorkspaceAPIGetWorkspaceRequest) (*Workspace, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Workspace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspaceAPIService.GetWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspace/{workspaceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.verbose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verbose", r.verbose, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkspaceAPIListWorkspacesRequest struct {
	ctx                    context.Context
	ApiService             WorkspaceAPI
	xDaytonaOrganizationID *string
	verbose                *bool
	labels                 *string
}

// Use with JWT to specify the organization ID
func (r WorkspaceAPIListWorkspacesRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) WorkspaceAPIListWorkspacesRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

// Include verbose output
func (r WorkspaceAPIListWorkspacesRequest) Verbose(verbose bool) WorkspaceAPIListWorkspacesRequest {
	r.verbose = &verbose
	return r
}

// JSON encoded labels to filter by
func (r WorkspaceAPIListWorkspacesRequest) Labels(labels string) WorkspaceAPIListWorkspacesRequest {
	r.labels = &labels
	return r
}

func (r WorkspaceAPIListWorkspacesRequest) Execute() ([]Workspace, *http.Response, error) {
	return r.ApiService.ListWorkspacesExecute(r)
}

/*
ListWorkspaces List all workspaces

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return WorkspaceAPIListWorkspacesRequest
*/
func (a *WorkspaceAPIService) ListWorkspaces(ctx context.Context) WorkspaceAPIListWorkspacesRequest {
	return WorkspaceAPIListWorkspacesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Workspace
func (a *WorkspaceAPIService) ListWorkspacesExecute(r WorkspaceAPIListWorkspacesRequest) ([]Workspace, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Workspace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspaceAPIService.ListWorkspaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspace"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.verbose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verbose", r.verbose, "form", "")
	}
	if r.labels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "labels", r.labels, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkspaceAPIReplaceLabelsRequest struct {
	ctx                    context.Context
	ApiService             WorkspaceAPI
	workspaceId            string
	workspaceLabels        *WorkspaceLabels
	xDaytonaOrganizationID *string
}

func (r WorkspaceAPIReplaceLabelsRequest) WorkspaceLabels(workspaceLabels WorkspaceLabels) WorkspaceAPIReplaceLabelsRequest {
	r.workspaceLabels = &workspaceLabels
	return r
}

// Use with JWT to specify the organization ID
func (r WorkspaceAPIReplaceLabelsRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) WorkspaceAPIReplaceLabelsRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r WorkspaceAPIReplaceLabelsRequest) Execute() (*WorkspaceLabels, *http.Response, error) {
	return r.ApiService.ReplaceLabelsExecute(r)
}

/*
ReplaceLabels Replace workspace labels

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId ID of the workspace
	@return WorkspaceAPIReplaceLabelsRequest
*/
func (a *WorkspaceAPIService) ReplaceLabels(ctx context.Context, workspaceId string) WorkspaceAPIReplaceLabelsRequest {
	return WorkspaceAPIReplaceLabelsRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
//
//	@return WorkspaceLabels
func (a *WorkspaceAPIService) ReplaceLabelsExecute(r WorkspaceAPIReplaceLabelsRequest) (*WorkspaceLabels, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WorkspaceLabels
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspaceAPIService.ReplaceLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspace/{workspaceId}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.workspaceLabels == nil {
		return localVarReturnValue, nil, reportError("workspaceLabels is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	// body params
	localVarPostBody = r.workspaceLabels
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkspaceAPISetAutostopIntervalRequest struct {
	ctx                    context.Context
	ApiService             WorkspaceAPI
	workspaceId            string
	interval               float32
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r WorkspaceAPISetAutostopIntervalRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) WorkspaceAPISetAutostopIntervalRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r WorkspaceAPISetAutostopIntervalRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetAutostopIntervalExecute(r)
}

/*
SetAutostopInterval Set workspace auto-stop interval

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId ID of the workspace
	@param interval Auto-stop interval in minutes (0 to disable)
	@return WorkspaceAPISetAutostopIntervalRequest
*/
func (a *WorkspaceAPIService) SetAutostopInterval(ctx context.Context, workspaceId string, interval float32) WorkspaceAPISetAutostopIntervalRequest {
	return WorkspaceAPISetAutostopIntervalRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
		interval:    interval,
	}
}

// Execute executes the request
func (a *WorkspaceAPIService) SetAutostopIntervalExecute(r WorkspaceAPISetAutostopIntervalRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspaceAPIService.SetAutostopInterval")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspace/{workspaceId}/autostop/{interval}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interval"+"}", url.PathEscape(parameterValueToString(r.interval, "interval")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type WorkspaceAPIStartWorkspaceRequest struct {
	ctx                    context.Context
	ApiService             WorkspaceAPI
	workspaceId            string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r WorkspaceAPIStartWorkspaceRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) WorkspaceAPIStartWorkspaceRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r WorkspaceAPIStartWorkspaceRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartWorkspaceExecute(r)
}

/*
StartWorkspace Start workspace

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId ID of the workspace
	@return WorkspaceAPIStartWorkspaceRequest
*/
func (a *WorkspaceAPIService) StartWorkspace(ctx context.Context, workspaceId string) WorkspaceAPIStartWorkspaceRequest {
	return WorkspaceAPIStartWorkspaceRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
func (a *WorkspaceAPIService) StartWorkspaceExecute(r WorkspaceAPIStartWorkspaceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspaceAPIService.StartWorkspace")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspace/{workspaceId}/start"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type WorkspaceAPIStopWorkspaceRequest struct {
	ctx                    context.Context
	ApiService             WorkspaceAPI
	workspaceId            string
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r WorkspaceAPIStopWorkspaceRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) WorkspaceAPIStopWorkspaceRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r WorkspaceAPIStopWorkspaceRequest) Execute() (*http.Response, error) {
	return r.ApiService.StopWorkspaceExecute(r)
}

/*
StopWorkspace Stop workspace

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId ID of the workspace
	@return WorkspaceAPIStopWorkspaceRequest
*/
func (a *WorkspaceAPIService) StopWorkspace(ctx context.Context, workspaceId string) WorkspaceAPIStopWorkspaceRequest {
	return WorkspaceAPIStopWorkspaceRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
	}
}

// Execute executes the request
func (a *WorkspaceAPIService) StopWorkspaceExecute(r WorkspaceAPIStopWorkspaceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspaceAPIService.StopWorkspace")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspace/{workspaceId}/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type WorkspaceAPIUpdatePublicStatusRequest struct {
	ctx                    context.Context
	ApiService             WorkspaceAPI
	workspaceId            string
	isPublic               bool
	xDaytonaOrganizationID *string
}

// Use with JWT to specify the organization ID
func (r WorkspaceAPIUpdatePublicStatusRequest) XDaytonaOrganizationID(xDaytonaOrganizationID string) WorkspaceAPIUpdatePublicStatusRequest {
	r.xDaytonaOrganizationID = &xDaytonaOrganizationID
	return r
}

func (r WorkspaceAPIUpdatePublicStatusRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdatePublicStatusExecute(r)
}

/*
UpdatePublicStatus Update public status

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workspaceId ID of the workspace
	@param isPublic Public status to set
	@return WorkspaceAPIUpdatePublicStatusRequest
*/
func (a *WorkspaceAPIService) UpdatePublicStatus(ctx context.Context, workspaceId string, isPublic bool) WorkspaceAPIUpdatePublicStatusRequest {
	return WorkspaceAPIUpdatePublicStatusRequest{
		ApiService:  a,
		ctx:         ctx,
		workspaceId: workspaceId,
		isPublic:    isPublic,
	}
}

// Execute executes the request
func (a *WorkspaceAPIService) UpdatePublicStatusExecute(r WorkspaceAPIUpdatePublicStatusRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspaceAPIService.UpdatePublicStatus")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspace/{workspaceId}/public/{isPublic}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspaceId"+"}", url.PathEscape(parameterValueToString(r.workspaceId, "workspaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"isPublic"+"}", url.PathEscape(parameterValueToString(r.isPublic, "isPublic")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDaytonaOrganizationID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Daytona-Organization-ID", r.xDaytonaOrganizationID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
