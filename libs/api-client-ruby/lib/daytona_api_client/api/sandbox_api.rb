=begin
#Daytona

#Daytona AI platform API Docs

The version of the OpenAPI document: 1.0
Contact: support@daytona.com
Generated by: https://openapi-generator.tech
Generator version: 7.12.0

=end

require 'cgi'

module DaytonaApiClient
  class SandboxApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Archive sandbox
    # @param sandbox_id_or_name [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Sandbox]
    def archive_sandbox(sandbox_id_or_name, opts = {})
      data, _status_code, _headers = archive_sandbox_with_http_info(sandbox_id_or_name, opts)
      data
    end

    # Archive sandbox
    # @param sandbox_id_or_name [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Array<(Sandbox, Integer, Hash)>] Sandbox data, response status code and response headers
    def archive_sandbox_with_http_info(sandbox_id_or_name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.archive_sandbox ...'
      end
      # verify the required parameter 'sandbox_id_or_name' is set
      if @api_client.config.client_side_validation && sandbox_id_or_name.nil?
        fail ArgumentError, "Missing the required parameter 'sandbox_id_or_name' when calling SandboxApi.archive_sandbox"
      end
      # resource path
      local_var_path = '/sandbox/{sandboxIdOrName}/archive'.sub('{' + 'sandboxIdOrName' + '}', CGI.escape(sandbox_id_or_name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Sandbox'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.archive_sandbox",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#archive_sandbox\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create sandbox backup
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Sandbox]
    def create_backup(sandbox_id_or_name, opts = {})
      data, _status_code, _headers = create_backup_with_http_info(sandbox_id_or_name, opts)
      data
    end

    # Create sandbox backup
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Array<(Sandbox, Integer, Hash)>] Sandbox data, response status code and response headers
    def create_backup_with_http_info(sandbox_id_or_name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.create_backup ...'
      end
      # verify the required parameter 'sandbox_id_or_name' is set
      if @api_client.config.client_side_validation && sandbox_id_or_name.nil?
        fail ArgumentError, "Missing the required parameter 'sandbox_id_or_name' when calling SandboxApi.create_backup"
      end
      # resource path
      local_var_path = '/sandbox/{sandboxIdOrName}/backup'.sub('{' + 'sandboxIdOrName' + '}', CGI.escape(sandbox_id_or_name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Sandbox'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.create_backup",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#create_backup\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a new sandbox
    # @param create_sandbox [CreateSandbox] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Sandbox]
    def create_sandbox(create_sandbox, opts = {})
      data, _status_code, _headers = create_sandbox_with_http_info(create_sandbox, opts)
      data
    end

    # Create a new sandbox
    # @param create_sandbox [CreateSandbox] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Array<(Sandbox, Integer, Hash)>] Sandbox data, response status code and response headers
    def create_sandbox_with_http_info(create_sandbox, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.create_sandbox ...'
      end
      # verify the required parameter 'create_sandbox' is set
      if @api_client.config.client_side_validation && create_sandbox.nil?
        fail ArgumentError, "Missing the required parameter 'create_sandbox' when calling SandboxApi.create_sandbox"
      end
      # resource path
      local_var_path = '/sandbox'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
        header_params['Content-Type'] = content_type
      end
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(create_sandbox)

      # return_type
      return_type = opts[:debug_return_type] || 'Sandbox'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.create_sandbox",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#create_sandbox\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create SSH access for sandbox
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @option opts [Float] :expires_in_minutes Expiration time in minutes (default: 60)
    # @return [SshAccessDto]
    def create_ssh_access(sandbox_id_or_name, opts = {})
      data, _status_code, _headers = create_ssh_access_with_http_info(sandbox_id_or_name, opts)
      data
    end

    # Create SSH access for sandbox
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @option opts [Float] :expires_in_minutes Expiration time in minutes (default: 60)
    # @return [Array<(SshAccessDto, Integer, Hash)>] SshAccessDto data, response status code and response headers
    def create_ssh_access_with_http_info(sandbox_id_or_name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.create_ssh_access ...'
      end
      # verify the required parameter 'sandbox_id_or_name' is set
      if @api_client.config.client_side_validation && sandbox_id_or_name.nil?
        fail ArgumentError, "Missing the required parameter 'sandbox_id_or_name' when calling SandboxApi.create_ssh_access"
      end
      # resource path
      local_var_path = '/sandbox/{sandboxIdOrName}/ssh-access'.sub('{' + 'sandboxIdOrName' + '}', CGI.escape(sandbox_id_or_name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expiresInMinutes'] = opts[:'expires_in_minutes'] if !opts[:'expires_in_minutes'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SshAccessDto'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.create_ssh_access",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#create_ssh_access\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete sandbox
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Sandbox]
    def delete_sandbox(sandbox_id_or_name, opts = {})
      data, _status_code, _headers = delete_sandbox_with_http_info(sandbox_id_or_name, opts)
      data
    end

    # Delete sandbox
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Array<(Sandbox, Integer, Hash)>] Sandbox data, response status code and response headers
    def delete_sandbox_with_http_info(sandbox_id_or_name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.delete_sandbox ...'
      end
      # verify the required parameter 'sandbox_id_or_name' is set
      if @api_client.config.client_side_validation && sandbox_id_or_name.nil?
        fail ArgumentError, "Missing the required parameter 'sandbox_id_or_name' when calling SandboxApi.delete_sandbox"
      end
      # resource path
      local_var_path = '/sandbox/{sandboxIdOrName}'.sub('{' + 'sandboxIdOrName' + '}', CGI.escape(sandbox_id_or_name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Sandbox'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.delete_sandbox",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#delete_sandbox\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get build logs
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @option opts [Boolean] :follow Whether to follow the logs stream
    # @return [nil]
    def get_build_logs(sandbox_id_or_name, opts = {})
      get_build_logs_with_http_info(sandbox_id_or_name, opts)
      nil
    end

    # Get build logs
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @option opts [Boolean] :follow Whether to follow the logs stream
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def get_build_logs_with_http_info(sandbox_id_or_name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.get_build_logs ...'
      end
      # verify the required parameter 'sandbox_id_or_name' is set
      if @api_client.config.client_side_validation && sandbox_id_or_name.nil?
        fail ArgumentError, "Missing the required parameter 'sandbox_id_or_name' when calling SandboxApi.get_build_logs"
      end
      # resource path
      local_var_path = '/sandbox/{sandboxIdOrName}/build-logs'.sub('{' + 'sandboxIdOrName' + '}', CGI.escape(sandbox_id_or_name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'follow'] = opts[:'follow'] if !opts[:'follow'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.get_build_logs",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#get_build_logs\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get preview URL for a sandbox port
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param port [Float] Port number to get preview URL for
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [PortPreviewUrl]
    def get_port_preview_url(sandbox_id_or_name, port, opts = {})
      data, _status_code, _headers = get_port_preview_url_with_http_info(sandbox_id_or_name, port, opts)
      data
    end

    # Get preview URL for a sandbox port
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param port [Float] Port number to get preview URL for
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Array<(PortPreviewUrl, Integer, Hash)>] PortPreviewUrl data, response status code and response headers
    def get_port_preview_url_with_http_info(sandbox_id_or_name, port, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.get_port_preview_url ...'
      end
      # verify the required parameter 'sandbox_id_or_name' is set
      if @api_client.config.client_side_validation && sandbox_id_or_name.nil?
        fail ArgumentError, "Missing the required parameter 'sandbox_id_or_name' when calling SandboxApi.get_port_preview_url"
      end
      # verify the required parameter 'port' is set
      if @api_client.config.client_side_validation && port.nil?
        fail ArgumentError, "Missing the required parameter 'port' when calling SandboxApi.get_port_preview_url"
      end
      # resource path
      local_var_path = '/sandbox/{sandboxIdOrName}/ports/{port}/preview-url'.sub('{' + 'sandboxIdOrName' + '}', CGI.escape(sandbox_id_or_name.to_s)).sub('{' + 'port' + '}', CGI.escape(port.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'PortPreviewUrl'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.get_port_preview_url",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#get_port_preview_url\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get sandbox details
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @option opts [Boolean] :verbose Include verbose output
    # @return [Sandbox]
    def get_sandbox(sandbox_id_or_name, opts = {})
      data, _status_code, _headers = get_sandbox_with_http_info(sandbox_id_or_name, opts)
      data
    end

    # Get sandbox details
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @option opts [Boolean] :verbose Include verbose output
    # @return [Array<(Sandbox, Integer, Hash)>] Sandbox data, response status code and response headers
    def get_sandbox_with_http_info(sandbox_id_or_name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.get_sandbox ...'
      end
      # verify the required parameter 'sandbox_id_or_name' is set
      if @api_client.config.client_side_validation && sandbox_id_or_name.nil?
        fail ArgumentError, "Missing the required parameter 'sandbox_id_or_name' when calling SandboxApi.get_sandbox"
      end
      # resource path
      local_var_path = '/sandbox/{sandboxIdOrName}'.sub('{' + 'sandboxIdOrName' + '}', CGI.escape(sandbox_id_or_name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'verbose'] = opts[:'verbose'] if !opts[:'verbose'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Sandbox'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.get_sandbox",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#get_sandbox\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get sandboxes for the authenticated runner
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @option opts [String] :states Comma-separated list of sandbox states to filter by
    # @option opts [Boolean] :skip_reconciling_sandboxes Skip sandboxes where state differs from desired state
    # @return [Array<Sandbox>]
    def get_sandboxes_for_runner(opts = {})
      data, _status_code, _headers = get_sandboxes_for_runner_with_http_info(opts)
      data
    end

    # Get sandboxes for the authenticated runner
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @option opts [String] :states Comma-separated list of sandbox states to filter by
    # @option opts [Boolean] :skip_reconciling_sandboxes Skip sandboxes where state differs from desired state
    # @return [Array<(Array<Sandbox>, Integer, Hash)>] Array<Sandbox> data, response status code and response headers
    def get_sandboxes_for_runner_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.get_sandboxes_for_runner ...'
      end
      # resource path
      local_var_path = '/sandbox/for-runner'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'states'] = opts[:'states'] if !opts[:'states'].nil?
      query_params[:'skipReconcilingSandboxes'] = opts[:'skip_reconciling_sandboxes'] if !opts[:'skip_reconciling_sandboxes'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<Sandbox>'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.get_sandboxes_for_runner",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#get_sandboxes_for_runner\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List all sandboxes
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @option opts [Boolean] :verbose Include verbose output
    # @option opts [String] :labels JSON encoded labels to filter by
    # @option opts [Boolean] :include_errored_deleted Include errored and deleted sandboxes
    # @return [Array<Sandbox>]
    def list_sandboxes(opts = {})
      data, _status_code, _headers = list_sandboxes_with_http_info(opts)
      data
    end

    # List all sandboxes
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @option opts [Boolean] :verbose Include verbose output
    # @option opts [String] :labels JSON encoded labels to filter by
    # @option opts [Boolean] :include_errored_deleted Include errored and deleted sandboxes
    # @return [Array<(Array<Sandbox>, Integer, Hash)>] Array<Sandbox> data, response status code and response headers
    def list_sandboxes_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.list_sandboxes ...'
      end
      # resource path
      local_var_path = '/sandbox'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'verbose'] = opts[:'verbose'] if !opts[:'verbose'].nil?
      query_params[:'labels'] = opts[:'labels'] if !opts[:'labels'].nil?
      query_params[:'includeErroredDeleted'] = opts[:'include_errored_deleted'] if !opts[:'include_errored_deleted'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<Sandbox>'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.list_sandboxes",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#list_sandboxes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List all sandboxes paginated
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @option opts [Float] :page Page number of the results (default to 1)
    # @option opts [Float] :limit Number of results per page (default to 100)
    # @option opts [String] :id Filter by partial ID match
    # @option opts [String] :name Filter by partial name match
    # @option opts [String] :labels JSON encoded labels to filter by
    # @option opts [Boolean] :include_errored_deleted Include results with errored state and deleted desired state (default to false)
    # @option opts [Array<String>] :states List of states to filter by
    # @option opts [Array<String>] :snapshots List of snapshot names to filter by
    # @option opts [Array<String>] :regions List of regions to filter by
    # @option opts [Float] :min_cpu Minimum CPU
    # @option opts [Float] :max_cpu Maximum CPU
    # @option opts [Float] :min_memory_gi_b Minimum memory in GiB
    # @option opts [Float] :max_memory_gi_b Maximum memory in GiB
    # @option opts [Float] :min_disk_gi_b Minimum disk space in GiB
    # @option opts [Float] :max_disk_gi_b Maximum disk space in GiB
    # @option opts [Time] :last_event_after Include items with last event after this timestamp
    # @option opts [Time] :last_event_before Include items with last event before this timestamp
    # @option opts [String] :sort Field to sort by (default to 'createdAt')
    # @option opts [String] :order Direction to sort by (default to 'desc')
    # @return [PaginatedSandboxes]
    def list_sandboxes_paginated(opts = {})
      data, _status_code, _headers = list_sandboxes_paginated_with_http_info(opts)
      data
    end

    # List all sandboxes paginated
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @option opts [Float] :page Page number of the results (default to 1)
    # @option opts [Float] :limit Number of results per page (default to 100)
    # @option opts [String] :id Filter by partial ID match
    # @option opts [String] :name Filter by partial name match
    # @option opts [String] :labels JSON encoded labels to filter by
    # @option opts [Boolean] :include_errored_deleted Include results with errored state and deleted desired state (default to false)
    # @option opts [Array<String>] :states List of states to filter by
    # @option opts [Array<String>] :snapshots List of snapshot names to filter by
    # @option opts [Array<String>] :regions List of regions to filter by
    # @option opts [Float] :min_cpu Minimum CPU
    # @option opts [Float] :max_cpu Maximum CPU
    # @option opts [Float] :min_memory_gi_b Minimum memory in GiB
    # @option opts [Float] :max_memory_gi_b Maximum memory in GiB
    # @option opts [Float] :min_disk_gi_b Minimum disk space in GiB
    # @option opts [Float] :max_disk_gi_b Maximum disk space in GiB
    # @option opts [Time] :last_event_after Include items with last event after this timestamp
    # @option opts [Time] :last_event_before Include items with last event before this timestamp
    # @option opts [String] :sort Field to sort by (default to 'createdAt')
    # @option opts [String] :order Direction to sort by (default to 'desc')
    # @return [Array<(PaginatedSandboxes, Integer, Hash)>] PaginatedSandboxes data, response status code and response headers
    def list_sandboxes_paginated_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.list_sandboxes_paginated ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page'].nil? && opts[:'page'] < 1
        fail ArgumentError, 'invalid value for "opts[:"page"]" when calling SandboxApi.list_sandboxes_paginated, must be greater than or equal to 1.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 200
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling SandboxApi.list_sandboxes_paginated, must be smaller than or equal to 200.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 1
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling SandboxApi.list_sandboxes_paginated, must be greater than or equal to 1.'
      end

      allowable_values = ["creating", "restoring", "destroying", "started", "stopped", "starting", "stopping", "error", "build_failed", "pending_build", "building_snapshot", "unknown", "pulling_snapshot", "archived", "archiving"]
      if @api_client.config.client_side_validation && opts[:'states'] && !opts[:'states'].all? { |item| allowable_values.include?(item) }
        fail ArgumentError, "invalid value for \"states\", must include one of #{allowable_values}"
      end
      if @api_client.config.client_side_validation && !opts[:'min_cpu'].nil? && opts[:'min_cpu'] < 1
        fail ArgumentError, 'invalid value for "opts[:"min_cpu"]" when calling SandboxApi.list_sandboxes_paginated, must be greater than or equal to 1.'
      end

      if @api_client.config.client_side_validation && !opts[:'max_cpu'].nil? && opts[:'max_cpu'] < 1
        fail ArgumentError, 'invalid value for "opts[:"max_cpu"]" when calling SandboxApi.list_sandboxes_paginated, must be greater than or equal to 1.'
      end

      if @api_client.config.client_side_validation && !opts[:'min_memory_gi_b'].nil? && opts[:'min_memory_gi_b'] < 1
        fail ArgumentError, 'invalid value for "opts[:"min_memory_gi_b"]" when calling SandboxApi.list_sandboxes_paginated, must be greater than or equal to 1.'
      end

      if @api_client.config.client_side_validation && !opts[:'max_memory_gi_b'].nil? && opts[:'max_memory_gi_b'] < 1
        fail ArgumentError, 'invalid value for "opts[:"max_memory_gi_b"]" when calling SandboxApi.list_sandboxes_paginated, must be greater than or equal to 1.'
      end

      if @api_client.config.client_side_validation && !opts[:'min_disk_gi_b'].nil? && opts[:'min_disk_gi_b'] < 1
        fail ArgumentError, 'invalid value for "opts[:"min_disk_gi_b"]" when calling SandboxApi.list_sandboxes_paginated, must be greater than or equal to 1.'
      end

      if @api_client.config.client_side_validation && !opts[:'max_disk_gi_b'].nil? && opts[:'max_disk_gi_b'] < 1
        fail ArgumentError, 'invalid value for "opts[:"max_disk_gi_b"]" when calling SandboxApi.list_sandboxes_paginated, must be greater than or equal to 1.'
      end

      allowable_values = ["id", "name", "state", "snapshot", "region", "updatedAt", "createdAt"]
      if @api_client.config.client_side_validation && opts[:'sort'] && !allowable_values.include?(opts[:'sort'])
        fail ArgumentError, "invalid value for \"sort\", must be one of #{allowable_values}"
      end
      allowable_values = ["asc", "desc"]
      if @api_client.config.client_side_validation && opts[:'order'] && !allowable_values.include?(opts[:'order'])
        fail ArgumentError, "invalid value for \"order\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/sandbox/paginated'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'page'] = opts[:'page'] if !opts[:'page'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'id'] = opts[:'id'] if !opts[:'id'].nil?
      query_params[:'name'] = opts[:'name'] if !opts[:'name'].nil?
      query_params[:'labels'] = opts[:'labels'] if !opts[:'labels'].nil?
      query_params[:'includeErroredDeleted'] = opts[:'include_errored_deleted'] if !opts[:'include_errored_deleted'].nil?
      query_params[:'states'] = @api_client.build_collection_param(opts[:'states'], :multi) if !opts[:'states'].nil?
      query_params[:'snapshots'] = @api_client.build_collection_param(opts[:'snapshots'], :multi) if !opts[:'snapshots'].nil?
      query_params[:'regions'] = @api_client.build_collection_param(opts[:'regions'], :multi) if !opts[:'regions'].nil?
      query_params[:'minCpu'] = opts[:'min_cpu'] if !opts[:'min_cpu'].nil?
      query_params[:'maxCpu'] = opts[:'max_cpu'] if !opts[:'max_cpu'].nil?
      query_params[:'minMemoryGiB'] = opts[:'min_memory_gi_b'] if !opts[:'min_memory_gi_b'].nil?
      query_params[:'maxMemoryGiB'] = opts[:'max_memory_gi_b'] if !opts[:'max_memory_gi_b'].nil?
      query_params[:'minDiskGiB'] = opts[:'min_disk_gi_b'] if !opts[:'min_disk_gi_b'].nil?
      query_params[:'maxDiskGiB'] = opts[:'max_disk_gi_b'] if !opts[:'max_disk_gi_b'].nil?
      query_params[:'lastEventAfter'] = opts[:'last_event_after'] if !opts[:'last_event_after'].nil?
      query_params[:'lastEventBefore'] = opts[:'last_event_before'] if !opts[:'last_event_before'].nil?
      query_params[:'sort'] = opts[:'sort'] if !opts[:'sort'].nil?
      query_params[:'order'] = opts[:'order'] if !opts[:'order'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'PaginatedSandboxes'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.list_sandboxes_paginated",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#list_sandboxes_paginated\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Recover sandbox from error state
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Sandbox]
    def recover_sandbox(sandbox_id_or_name, opts = {})
      data, _status_code, _headers = recover_sandbox_with_http_info(sandbox_id_or_name, opts)
      data
    end

    # Recover sandbox from error state
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Array<(Sandbox, Integer, Hash)>] Sandbox data, response status code and response headers
    def recover_sandbox_with_http_info(sandbox_id_or_name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.recover_sandbox ...'
      end
      # verify the required parameter 'sandbox_id_or_name' is set
      if @api_client.config.client_side_validation && sandbox_id_or_name.nil?
        fail ArgumentError, "Missing the required parameter 'sandbox_id_or_name' when calling SandboxApi.recover_sandbox"
      end
      # resource path
      local_var_path = '/sandbox/{sandboxIdOrName}/recover'.sub('{' + 'sandboxIdOrName' + '}', CGI.escape(sandbox_id_or_name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Sandbox'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.recover_sandbox",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#recover_sandbox\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Replace sandbox labels
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param sandbox_labels [SandboxLabels] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [SandboxLabels]
    def replace_labels(sandbox_id_or_name, sandbox_labels, opts = {})
      data, _status_code, _headers = replace_labels_with_http_info(sandbox_id_or_name, sandbox_labels, opts)
      data
    end

    # Replace sandbox labels
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param sandbox_labels [SandboxLabels] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Array<(SandboxLabels, Integer, Hash)>] SandboxLabels data, response status code and response headers
    def replace_labels_with_http_info(sandbox_id_or_name, sandbox_labels, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.replace_labels ...'
      end
      # verify the required parameter 'sandbox_id_or_name' is set
      if @api_client.config.client_side_validation && sandbox_id_or_name.nil?
        fail ArgumentError, "Missing the required parameter 'sandbox_id_or_name' when calling SandboxApi.replace_labels"
      end
      # verify the required parameter 'sandbox_labels' is set
      if @api_client.config.client_side_validation && sandbox_labels.nil?
        fail ArgumentError, "Missing the required parameter 'sandbox_labels' when calling SandboxApi.replace_labels"
      end
      # resource path
      local_var_path = '/sandbox/{sandboxIdOrName}/labels'.sub('{' + 'sandboxIdOrName' + '}', CGI.escape(sandbox_id_or_name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
        header_params['Content-Type'] = content_type
      end
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(sandbox_labels)

      # return_type
      return_type = opts[:debug_return_type] || 'SandboxLabels'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.replace_labels",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#replace_labels\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Revoke SSH access for sandbox
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @option opts [String] :token SSH access token to revoke. If not provided, all SSH access for the sandbox will be revoked.
    # @return [Sandbox]
    def revoke_ssh_access(sandbox_id_or_name, opts = {})
      data, _status_code, _headers = revoke_ssh_access_with_http_info(sandbox_id_or_name, opts)
      data
    end

    # Revoke SSH access for sandbox
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @option opts [String] :token SSH access token to revoke. If not provided, all SSH access for the sandbox will be revoked.
    # @return [Array<(Sandbox, Integer, Hash)>] Sandbox data, response status code and response headers
    def revoke_ssh_access_with_http_info(sandbox_id_or_name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.revoke_ssh_access ...'
      end
      # verify the required parameter 'sandbox_id_or_name' is set
      if @api_client.config.client_side_validation && sandbox_id_or_name.nil?
        fail ArgumentError, "Missing the required parameter 'sandbox_id_or_name' when calling SandboxApi.revoke_ssh_access"
      end
      # resource path
      local_var_path = '/sandbox/{sandboxIdOrName}/ssh-access'.sub('{' + 'sandboxIdOrName' + '}', CGI.escape(sandbox_id_or_name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'token'] = opts[:'token'] if !opts[:'token'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Sandbox'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.revoke_ssh_access",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#revoke_ssh_access\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Set sandbox auto-archive interval
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param interval [Float] Auto-archive interval in minutes (0 means the maximum interval will be used)
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Sandbox]
    def set_auto_archive_interval(sandbox_id_or_name, interval, opts = {})
      data, _status_code, _headers = set_auto_archive_interval_with_http_info(sandbox_id_or_name, interval, opts)
      data
    end

    # Set sandbox auto-archive interval
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param interval [Float] Auto-archive interval in minutes (0 means the maximum interval will be used)
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Array<(Sandbox, Integer, Hash)>] Sandbox data, response status code and response headers
    def set_auto_archive_interval_with_http_info(sandbox_id_or_name, interval, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.set_auto_archive_interval ...'
      end
      # verify the required parameter 'sandbox_id_or_name' is set
      if @api_client.config.client_side_validation && sandbox_id_or_name.nil?
        fail ArgumentError, "Missing the required parameter 'sandbox_id_or_name' when calling SandboxApi.set_auto_archive_interval"
      end
      # verify the required parameter 'interval' is set
      if @api_client.config.client_side_validation && interval.nil?
        fail ArgumentError, "Missing the required parameter 'interval' when calling SandboxApi.set_auto_archive_interval"
      end
      # resource path
      local_var_path = '/sandbox/{sandboxIdOrName}/autoarchive/{interval}'.sub('{' + 'sandboxIdOrName' + '}', CGI.escape(sandbox_id_or_name.to_s)).sub('{' + 'interval' + '}', CGI.escape(interval.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Sandbox'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.set_auto_archive_interval",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#set_auto_archive_interval\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Set sandbox auto-delete interval
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param interval [Float] Auto-delete interval in minutes (negative value means disabled, 0 means delete immediately upon stopping)
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Sandbox]
    def set_auto_delete_interval(sandbox_id_or_name, interval, opts = {})
      data, _status_code, _headers = set_auto_delete_interval_with_http_info(sandbox_id_or_name, interval, opts)
      data
    end

    # Set sandbox auto-delete interval
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param interval [Float] Auto-delete interval in minutes (negative value means disabled, 0 means delete immediately upon stopping)
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Array<(Sandbox, Integer, Hash)>] Sandbox data, response status code and response headers
    def set_auto_delete_interval_with_http_info(sandbox_id_or_name, interval, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.set_auto_delete_interval ...'
      end
      # verify the required parameter 'sandbox_id_or_name' is set
      if @api_client.config.client_side_validation && sandbox_id_or_name.nil?
        fail ArgumentError, "Missing the required parameter 'sandbox_id_or_name' when calling SandboxApi.set_auto_delete_interval"
      end
      # verify the required parameter 'interval' is set
      if @api_client.config.client_side_validation && interval.nil?
        fail ArgumentError, "Missing the required parameter 'interval' when calling SandboxApi.set_auto_delete_interval"
      end
      # resource path
      local_var_path = '/sandbox/{sandboxIdOrName}/autodelete/{interval}'.sub('{' + 'sandboxIdOrName' + '}', CGI.escape(sandbox_id_or_name.to_s)).sub('{' + 'interval' + '}', CGI.escape(interval.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Sandbox'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.set_auto_delete_interval",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#set_auto_delete_interval\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Set sandbox auto-stop interval
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param interval [Float] Auto-stop interval in minutes (0 to disable)
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Sandbox]
    def set_autostop_interval(sandbox_id_or_name, interval, opts = {})
      data, _status_code, _headers = set_autostop_interval_with_http_info(sandbox_id_or_name, interval, opts)
      data
    end

    # Set sandbox auto-stop interval
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param interval [Float] Auto-stop interval in minutes (0 to disable)
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Array<(Sandbox, Integer, Hash)>] Sandbox data, response status code and response headers
    def set_autostop_interval_with_http_info(sandbox_id_or_name, interval, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.set_autostop_interval ...'
      end
      # verify the required parameter 'sandbox_id_or_name' is set
      if @api_client.config.client_side_validation && sandbox_id_or_name.nil?
        fail ArgumentError, "Missing the required parameter 'sandbox_id_or_name' when calling SandboxApi.set_autostop_interval"
      end
      # verify the required parameter 'interval' is set
      if @api_client.config.client_side_validation && interval.nil?
        fail ArgumentError, "Missing the required parameter 'interval' when calling SandboxApi.set_autostop_interval"
      end
      # resource path
      local_var_path = '/sandbox/{sandboxIdOrName}/autostop/{interval}'.sub('{' + 'sandboxIdOrName' + '}', CGI.escape(sandbox_id_or_name.to_s)).sub('{' + 'interval' + '}', CGI.escape(interval.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Sandbox'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.set_autostop_interval",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#set_autostop_interval\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Start sandbox
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Sandbox]
    def start_sandbox(sandbox_id_or_name, opts = {})
      data, _status_code, _headers = start_sandbox_with_http_info(sandbox_id_or_name, opts)
      data
    end

    # Start sandbox
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Array<(Sandbox, Integer, Hash)>] Sandbox data, response status code and response headers
    def start_sandbox_with_http_info(sandbox_id_or_name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.start_sandbox ...'
      end
      # verify the required parameter 'sandbox_id_or_name' is set
      if @api_client.config.client_side_validation && sandbox_id_or_name.nil?
        fail ArgumentError, "Missing the required parameter 'sandbox_id_or_name' when calling SandboxApi.start_sandbox"
      end
      # resource path
      local_var_path = '/sandbox/{sandboxIdOrName}/start'.sub('{' + 'sandboxIdOrName' + '}', CGI.escape(sandbox_id_or_name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Sandbox'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.start_sandbox",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#start_sandbox\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Stop sandbox
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Sandbox]
    def stop_sandbox(sandbox_id_or_name, opts = {})
      data, _status_code, _headers = stop_sandbox_with_http_info(sandbox_id_or_name, opts)
      data
    end

    # Stop sandbox
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Array<(Sandbox, Integer, Hash)>] Sandbox data, response status code and response headers
    def stop_sandbox_with_http_info(sandbox_id_or_name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.stop_sandbox ...'
      end
      # verify the required parameter 'sandbox_id_or_name' is set
      if @api_client.config.client_side_validation && sandbox_id_or_name.nil?
        fail ArgumentError, "Missing the required parameter 'sandbox_id_or_name' when calling SandboxApi.stop_sandbox"
      end
      # resource path
      local_var_path = '/sandbox/{sandboxIdOrName}/stop'.sub('{' + 'sandboxIdOrName' + '}', CGI.escape(sandbox_id_or_name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Sandbox'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.stop_sandbox",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#stop_sandbox\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update sandbox last activity
    # @param sandbox_id [String] ID of the sandbox
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [nil]
    def update_last_activity(sandbox_id, opts = {})
      update_last_activity_with_http_info(sandbox_id, opts)
      nil
    end

    # Update sandbox last activity
    # @param sandbox_id [String] ID of the sandbox
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def update_last_activity_with_http_info(sandbox_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.update_last_activity ...'
      end
      # verify the required parameter 'sandbox_id' is set
      if @api_client.config.client_side_validation && sandbox_id.nil?
        fail ArgumentError, "Missing the required parameter 'sandbox_id' when calling SandboxApi.update_last_activity"
      end
      # resource path
      local_var_path = '/sandbox/{sandboxId}/last-activity'.sub('{' + 'sandboxId' + '}', CGI.escape(sandbox_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.update_last_activity",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#update_last_activity\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update public status
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param is_public [Boolean] Public status to set
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Sandbox]
    def update_public_status(sandbox_id_or_name, is_public, opts = {})
      data, _status_code, _headers = update_public_status_with_http_info(sandbox_id_or_name, is_public, opts)
      data
    end

    # Update public status
    # @param sandbox_id_or_name [String] ID or name of the sandbox
    # @param is_public [Boolean] Public status to set
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Array<(Sandbox, Integer, Hash)>] Sandbox data, response status code and response headers
    def update_public_status_with_http_info(sandbox_id_or_name, is_public, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.update_public_status ...'
      end
      # verify the required parameter 'sandbox_id_or_name' is set
      if @api_client.config.client_side_validation && sandbox_id_or_name.nil?
        fail ArgumentError, "Missing the required parameter 'sandbox_id_or_name' when calling SandboxApi.update_public_status"
      end
      # verify the required parameter 'is_public' is set
      if @api_client.config.client_side_validation && is_public.nil?
        fail ArgumentError, "Missing the required parameter 'is_public' when calling SandboxApi.update_public_status"
      end
      # resource path
      local_var_path = '/sandbox/{sandboxIdOrName}/public/{isPublic}'.sub('{' + 'sandboxIdOrName' + '}', CGI.escape(sandbox_id_or_name.to_s)).sub('{' + 'isPublic' + '}', CGI.escape(is_public.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Sandbox'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.update_public_status",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#update_public_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update sandbox state
    # @param sandbox_id [String] ID of the sandbox
    # @param update_sandbox_state_dto [UpdateSandboxStateDto] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [nil]
    def update_sandbox_state(sandbox_id, update_sandbox_state_dto, opts = {})
      update_sandbox_state_with_http_info(sandbox_id, update_sandbox_state_dto, opts)
      nil
    end

    # Update sandbox state
    # @param sandbox_id [String] ID of the sandbox
    # @param update_sandbox_state_dto [UpdateSandboxStateDto] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def update_sandbox_state_with_http_info(sandbox_id, update_sandbox_state_dto, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.update_sandbox_state ...'
      end
      # verify the required parameter 'sandbox_id' is set
      if @api_client.config.client_side_validation && sandbox_id.nil?
        fail ArgumentError, "Missing the required parameter 'sandbox_id' when calling SandboxApi.update_sandbox_state"
      end
      # verify the required parameter 'update_sandbox_state_dto' is set
      if @api_client.config.client_side_validation && update_sandbox_state_dto.nil?
        fail ArgumentError, "Missing the required parameter 'update_sandbox_state_dto' when calling SandboxApi.update_sandbox_state"
      end
      # resource path
      local_var_path = '/sandbox/{sandboxId}/state'.sub('{' + 'sandboxId' + '}', CGI.escape(sandbox_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
        header_params['Content-Type'] = content_type
      end
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(update_sandbox_state_dto)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.update_sandbox_state",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#update_sandbox_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Validate SSH access for sandbox
    # @param token [String] SSH access token to validate
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [SshAccessValidationDto]
    def validate_ssh_access(token, opts = {})
      data, _status_code, _headers = validate_ssh_access_with_http_info(token, opts)
      data
    end

    # Validate SSH access for sandbox
    # @param token [String] SSH access token to validate
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_daytona_organization_id Use with JWT to specify the organization ID
    # @return [Array<(SshAccessValidationDto, Integer, Hash)>] SshAccessValidationDto data, response status code and response headers
    def validate_ssh_access_with_http_info(token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SandboxApi.validate_ssh_access ...'
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling SandboxApi.validate_ssh_access"
      end
      # resource path
      local_var_path = '/sandbox/ssh-access/validate'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'token'] = token

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Daytona-Organization-ID'] = opts[:'x_daytona_organization_id'] if !opts[:'x_daytona_organization_id'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SshAccessValidationDto'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearer', 'oauth2']

      new_options = opts.merge(
        :operation => :"SandboxApi.validate_ssh_access",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SandboxApi#validate_ssh_access\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
