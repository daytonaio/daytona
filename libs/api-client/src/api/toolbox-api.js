'use strict'
/* tslint:disable */
/* eslint-disable */
/**
 * Daytona
 * Daytona AI platform API Docs
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@daytona.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, '__esModule', { value: true })
exports.ToolboxApi = exports.ToolboxApiFactory = exports.ToolboxApiFp = exports.ToolboxApiAxiosParamCreator = void 0
const tslib_1 = require('tslib')
const axios_1 = tslib_1.__importDefault(require('axios'))
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require('../common')
// @ts-ignore
const base_1 = require('../base')
/**
 * ToolboxApi - axios parameter creator
 * @export
 */
const ToolboxApiAxiosParamCreator = function (configuration) {
  return {
    /**
     * Create folder inside sandbox
     * @summary Create folder
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} mode
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFolder: async (sandboxId, path, mode, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('createFolder', 'sandboxId', sandboxId)
      // verify required parameter 'path' is not null or undefined
      ;(0, common_1.assertParamExists)('createFolder', 'path', path)
      // verify required parameter 'mode' is not null or undefined
      ;(0, common_1.assertParamExists)('createFolder', 'mode', mode)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files/folder`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }
      if (mode !== undefined) {
        localVarQueryParameter['mode'] = mode
      }
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create a new session in the sandbox
     * @summary Create session
     * @param {string} sandboxId
     * @param {CreateSessionRequest} createSessionRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSession: async (sandboxId, createSessionRequest, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('createSession', 'sandboxId', sandboxId)
      // verify required parameter 'createSessionRequest' is not null or undefined
      ;(0, common_1.assertParamExists)('createSession', 'createSessionRequest', createSessionRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/process/session`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      localVarHeaderParameter['Content-Type'] = 'application/json'
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(
        createSessionRequest,
        localVarRequestOptions,
        configuration,
      )
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete file inside sandbox
     * @summary Delete file
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile: async (sandboxId, path, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('deleteFile', 'sandboxId', sandboxId)
      // verify required parameter 'path' is not null or undefined
      ;(0, common_1.assertParamExists)('deleteFile', 'path', path)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete a specific session
     * @summary Delete session
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSession: async (sandboxId, sessionId, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('deleteSession', 'sandboxId', sandboxId)
      // verify required parameter 'sessionId' is not null or undefined
      ;(0, common_1.assertParamExists)('deleteSession', 'sessionId', sessionId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/process/session/{sessionId}`
        .replace(`{${'sandboxId'}}`, encodeURIComponent(String(sandboxId)))
        .replace(`{${'sessionId'}}`, encodeURIComponent(String(sessionId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Download file from sandbox
     * @summary Download file
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile: async (sandboxId, path, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('downloadFile', 'sandboxId', sandboxId)
      // verify required parameter 'path' is not null or undefined
      ;(0, common_1.assertParamExists)('downloadFile', 'path', path)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files/download`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Execute command synchronously inside sandbox
     * @summary Execute command
     * @param {string} sandboxId
     * @param {ExecuteRequest} executeRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeCommand: async (sandboxId, executeRequest, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('executeCommand', 'sandboxId', sandboxId)
      // verify required parameter 'executeRequest' is not null or undefined
      ;(0, common_1.assertParamExists)('executeCommand', 'executeRequest', executeRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/process/execute`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      localVarHeaderParameter['Content-Type'] = 'application/json'
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(
        executeRequest,
        localVarRequestOptions,
        configuration,
      )
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Execute a command in a specific session
     * @summary Execute command in session
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {SessionExecuteRequest} sessionExecuteRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeSessionCommand: async (
      sandboxId,
      sessionId,
      sessionExecuteRequest,
      xDaytonaOrganizationID,
      options = {},
    ) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('executeSessionCommand', 'sandboxId', sandboxId)
      // verify required parameter 'sessionId' is not null or undefined
      ;(0, common_1.assertParamExists)('executeSessionCommand', 'sessionId', sessionId)
      // verify required parameter 'sessionExecuteRequest' is not null or undefined
      ;(0, common_1.assertParamExists)('executeSessionCommand', 'sessionExecuteRequest', sessionExecuteRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/process/session/{sessionId}/exec`
        .replace(`{${'sandboxId'}}`, encodeURIComponent(String(sandboxId)))
        .replace(`{${'sessionId'}}`, encodeURIComponent(String(sessionId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      localVarHeaderParameter['Content-Type'] = 'application/json'
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(
        sessionExecuteRequest,
        localVarRequestOptions,
        configuration,
      )
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Search for text/pattern inside sandbox files
     * @summary Search for text/pattern in files
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} pattern
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findInFiles: async (sandboxId, path, pattern, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('findInFiles', 'sandboxId', sandboxId)
      // verify required parameter 'path' is not null or undefined
      ;(0, common_1.assertParamExists)('findInFiles', 'path', path)
      // verify required parameter 'pattern' is not null or undefined
      ;(0, common_1.assertParamExists)('findInFiles', 'pattern', pattern)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files/find`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }
      if (pattern !== undefined) {
        localVarQueryParameter['pattern'] = pattern
      }
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get file info inside sandbox
     * @summary Get file info
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileInfo: async (sandboxId, path, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('getFileInfo', 'sandboxId', sandboxId)
      // verify required parameter 'path' is not null or undefined
      ;(0, common_1.assertParamExists)('getFileInfo', 'path', path)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files/info`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get sandbox project dir
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectDir: async (sandboxId, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('getProjectDir', 'sandboxId', sandboxId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/project-dir`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get session by ID
     * @summary Get session
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSession: async (sandboxId, sessionId, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('getSession', 'sandboxId', sandboxId)
      // verify required parameter 'sessionId' is not null or undefined
      ;(0, common_1.assertParamExists)('getSession', 'sessionId', sessionId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/process/session/{sessionId}`
        .replace(`{${'sandboxId'}}`, encodeURIComponent(String(sandboxId)))
        .replace(`{${'sessionId'}}`, encodeURIComponent(String(sessionId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get session command by ID
     * @summary Get session command
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} commandId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionCommand: async (sandboxId, sessionId, commandId, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('getSessionCommand', 'sandboxId', sandboxId)
      // verify required parameter 'sessionId' is not null or undefined
      ;(0, common_1.assertParamExists)('getSessionCommand', 'sessionId', sessionId)
      // verify required parameter 'commandId' is not null or undefined
      ;(0, common_1.assertParamExists)('getSessionCommand', 'commandId', commandId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/process/session/{sessionId}/command/{commandId}`
        .replace(`{${'sandboxId'}}`, encodeURIComponent(String(sandboxId)))
        .replace(`{${'sessionId'}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${'commandId'}}`, encodeURIComponent(String(commandId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get logs for a specific command in a session
     * @summary Get command logs
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} commandId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {boolean} [follow]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionCommandLogs: async (sandboxId, sessionId, commandId, xDaytonaOrganizationID, follow, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('getSessionCommandLogs', 'sandboxId', sandboxId)
      // verify required parameter 'sessionId' is not null or undefined
      ;(0, common_1.assertParamExists)('getSessionCommandLogs', 'sessionId', sessionId)
      // verify required parameter 'commandId' is not null or undefined
      ;(0, common_1.assertParamExists)('getSessionCommandLogs', 'commandId', commandId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/process/session/{sessionId}/command/{commandId}/logs`
        .replace(`{${'sandboxId'}}`, encodeURIComponent(String(sandboxId)))
        .replace(`{${'sessionId'}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${'commandId'}}`, encodeURIComponent(String(commandId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      if (follow !== undefined) {
        localVarQueryParameter['follow'] = follow
      }
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Add files to git commit
     * @summary Add files
     * @param {string} sandboxId
     * @param {GitAddRequest} gitAddRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitAddFiles: async (sandboxId, gitAddRequest, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('gitAddFiles', 'sandboxId', sandboxId)
      // verify required parameter 'gitAddRequest' is not null or undefined
      ;(0, common_1.assertParamExists)('gitAddFiles', 'gitAddRequest', gitAddRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/git/add`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      localVarHeaderParameter['Content-Type'] = 'application/json'
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(
        gitAddRequest,
        localVarRequestOptions,
        configuration,
      )
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Checkout branch or commit in git repository
     * @summary Checkout branch
     * @param {string} sandboxId
     * @param {GitCheckoutRequest} gitCheckoutRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCheckoutBranch: async (sandboxId, gitCheckoutRequest, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('gitCheckoutBranch', 'sandboxId', sandboxId)
      // verify required parameter 'gitCheckoutRequest' is not null or undefined
      ;(0, common_1.assertParamExists)('gitCheckoutBranch', 'gitCheckoutRequest', gitCheckoutRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/git/checkout`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      localVarHeaderParameter['Content-Type'] = 'application/json'
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(
        gitCheckoutRequest,
        localVarRequestOptions,
        configuration,
      )
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Clone git repository
     * @summary Clone repository
     * @param {string} sandboxId
     * @param {GitCloneRequest} gitCloneRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCloneRepository: async (sandboxId, gitCloneRequest, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('gitCloneRepository', 'sandboxId', sandboxId)
      // verify required parameter 'gitCloneRequest' is not null or undefined
      ;(0, common_1.assertParamExists)('gitCloneRepository', 'gitCloneRequest', gitCloneRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/git/clone`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      localVarHeaderParameter['Content-Type'] = 'application/json'
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(
        gitCloneRequest,
        localVarRequestOptions,
        configuration,
      )
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Commit changes to git repository
     * @summary Commit changes
     * @param {string} sandboxId
     * @param {GitCommitRequest} gitCommitRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCommitChanges: async (sandboxId, gitCommitRequest, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('gitCommitChanges', 'sandboxId', sandboxId)
      // verify required parameter 'gitCommitRequest' is not null or undefined
      ;(0, common_1.assertParamExists)('gitCommitChanges', 'gitCommitRequest', gitCommitRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/git/commit`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      localVarHeaderParameter['Content-Type'] = 'application/json'
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(
        gitCommitRequest,
        localVarRequestOptions,
        configuration,
      )
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create branch on git repository
     * @summary Create branch
     * @param {string} sandboxId
     * @param {GitBranchRequest} gitBranchRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCreateBranch: async (sandboxId, gitBranchRequest, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('gitCreateBranch', 'sandboxId', sandboxId)
      // verify required parameter 'gitBranchRequest' is not null or undefined
      ;(0, common_1.assertParamExists)('gitCreateBranch', 'gitBranchRequest', gitBranchRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/git/branches`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      localVarHeaderParameter['Content-Type'] = 'application/json'
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(
        gitBranchRequest,
        localVarRequestOptions,
        configuration,
      )
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete branch on git repository
     * @summary Delete branch
     * @param {string} sandboxId
     * @param {GitDeleteBranchRequest} gitDeleteBranchRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitDeleteBranch: async (sandboxId, gitDeleteBranchRequest, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('gitDeleteBranch', 'sandboxId', sandboxId)
      // verify required parameter 'gitDeleteBranchRequest' is not null or undefined
      ;(0, common_1.assertParamExists)('gitDeleteBranch', 'gitDeleteBranchRequest', gitDeleteBranchRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/git/branches`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      localVarHeaderParameter['Content-Type'] = 'application/json'
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(
        gitDeleteBranchRequest,
        localVarRequestOptions,
        configuration,
      )
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get commit history from git repository
     * @summary Get commit history
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitGetHistory: async (sandboxId, path, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('gitGetHistory', 'sandboxId', sandboxId)
      // verify required parameter 'path' is not null or undefined
      ;(0, common_1.assertParamExists)('gitGetHistory', 'path', path)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/git/history`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get status from git repository
     * @summary Get git status
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitGetStatus: async (sandboxId, path, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('gitGetStatus', 'sandboxId', sandboxId)
      // verify required parameter 'path' is not null or undefined
      ;(0, common_1.assertParamExists)('gitGetStatus', 'path', path)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/git/status`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get branch list from git repository
     * @summary Get branch list
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitListBranches: async (sandboxId, path, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('gitListBranches', 'sandboxId', sandboxId)
      // verify required parameter 'path' is not null or undefined
      ;(0, common_1.assertParamExists)('gitListBranches', 'path', path)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/git/branches`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Pull changes from remote
     * @summary Pull changes
     * @param {string} sandboxId
     * @param {GitRepoRequest} gitRepoRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitPullChanges: async (sandboxId, gitRepoRequest, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('gitPullChanges', 'sandboxId', sandboxId)
      // verify required parameter 'gitRepoRequest' is not null or undefined
      ;(0, common_1.assertParamExists)('gitPullChanges', 'gitRepoRequest', gitRepoRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/git/pull`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      localVarHeaderParameter['Content-Type'] = 'application/json'
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(
        gitRepoRequest,
        localVarRequestOptions,
        configuration,
      )
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Push changes to remote
     * @summary Push changes
     * @param {string} sandboxId
     * @param {GitRepoRequest} gitRepoRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitPushChanges: async (sandboxId, gitRepoRequest, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('gitPushChanges', 'sandboxId', sandboxId)
      // verify required parameter 'gitRepoRequest' is not null or undefined
      ;(0, common_1.assertParamExists)('gitPushChanges', 'gitRepoRequest', gitRepoRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/git/push`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      localVarHeaderParameter['Content-Type'] = 'application/json'
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(
        gitRepoRequest,
        localVarRequestOptions,
        configuration,
      )
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List files
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {string} [path]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFiles: async (sandboxId, xDaytonaOrganizationID, path, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('listFiles', 'sandboxId', sandboxId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List all active sessions in the sandbox
     * @summary List sessions
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSessions: async (sandboxId, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('listSessions', 'sandboxId', sandboxId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/process/session`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * The Completion request is sent from the client to the server to compute completion items at a given cursor position.
     * @summary Get Lsp Completions
     * @param {string} sandboxId
     * @param {LspCompletionParams} lspCompletionParams
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspCompletions: async (sandboxId, lspCompletionParams, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('lspCompletions', 'sandboxId', sandboxId)
      // verify required parameter 'lspCompletionParams' is not null or undefined
      ;(0, common_1.assertParamExists)('lspCompletions', 'lspCompletionParams', lspCompletionParams)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/lsp/completions`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      localVarHeaderParameter['Content-Type'] = 'application/json'
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(
        lspCompletionParams,
        localVarRequestOptions,
        configuration,
      )
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * The document close notification is sent from the client to the server when the document got closed in the client.
     * @summary Call Lsp DidClose
     * @param {string} sandboxId
     * @param {LspDocumentRequest} lspDocumentRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspDidClose: async (sandboxId, lspDocumentRequest, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('lspDidClose', 'sandboxId', sandboxId)
      // verify required parameter 'lspDocumentRequest' is not null or undefined
      ;(0, common_1.assertParamExists)('lspDidClose', 'lspDocumentRequest', lspDocumentRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/lsp/did-close`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      localVarHeaderParameter['Content-Type'] = 'application/json'
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(
        lspDocumentRequest,
        localVarRequestOptions,
        configuration,
      )
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * The document open notification is sent from the client to the server to signal newly opened text documents.
     * @summary Call Lsp DidOpen
     * @param {string} sandboxId
     * @param {LspDocumentRequest} lspDocumentRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspDidOpen: async (sandboxId, lspDocumentRequest, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('lspDidOpen', 'sandboxId', sandboxId)
      // verify required parameter 'lspDocumentRequest' is not null or undefined
      ;(0, common_1.assertParamExists)('lspDidOpen', 'lspDocumentRequest', lspDocumentRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/lsp/did-open`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      localVarHeaderParameter['Content-Type'] = 'application/json'
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(
        lspDocumentRequest,
        localVarRequestOptions,
        configuration,
      )
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * The document symbol request is sent from the client to the server.
     * @summary Call Lsp DocumentSymbols
     * @param {string} sandboxId
     * @param {string} languageId
     * @param {string} pathToProject
     * @param {string} uri
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspDocumentSymbols: async (sandboxId, languageId, pathToProject, uri, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('lspDocumentSymbols', 'sandboxId', sandboxId)
      // verify required parameter 'languageId' is not null or undefined
      ;(0, common_1.assertParamExists)('lspDocumentSymbols', 'languageId', languageId)
      // verify required parameter 'pathToProject' is not null or undefined
      ;(0, common_1.assertParamExists)('lspDocumentSymbols', 'pathToProject', pathToProject)
      // verify required parameter 'uri' is not null or undefined
      ;(0, common_1.assertParamExists)('lspDocumentSymbols', 'uri', uri)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/lsp/document-symbols`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      if (languageId !== undefined) {
        localVarQueryParameter['languageId'] = languageId
      }
      if (pathToProject !== undefined) {
        localVarQueryParameter['pathToProject'] = pathToProject
      }
      if (uri !== undefined) {
        localVarQueryParameter['uri'] = uri
      }
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Start Lsp server process inside sandbox project
     * @summary Start Lsp server
     * @param {string} sandboxId
     * @param {LspServerRequest} lspServerRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspStart: async (sandboxId, lspServerRequest, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('lspStart', 'sandboxId', sandboxId)
      // verify required parameter 'lspServerRequest' is not null or undefined
      ;(0, common_1.assertParamExists)('lspStart', 'lspServerRequest', lspServerRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/lsp/start`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      localVarHeaderParameter['Content-Type'] = 'application/json'
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(
        lspServerRequest,
        localVarRequestOptions,
        configuration,
      )
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Stop Lsp server process inside sandbox project
     * @summary Stop Lsp server
     * @param {string} sandboxId
     * @param {LspServerRequest} lspServerRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspStop: async (sandboxId, lspServerRequest, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('lspStop', 'sandboxId', sandboxId)
      // verify required parameter 'lspServerRequest' is not null or undefined
      ;(0, common_1.assertParamExists)('lspStop', 'lspServerRequest', lspServerRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/lsp/stop`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      localVarHeaderParameter['Content-Type'] = 'application/json'
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(
        lspServerRequest,
        localVarRequestOptions,
        configuration,
      )
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.
     * @summary Call Lsp WorkspaceSymbols
     * @param {string} sandboxId
     * @param {string} languageId
     * @param {string} pathToProject
     * @param {string} query
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspWorkspaceSymbols: async (sandboxId, languageId, pathToProject, query, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('lspWorkspaceSymbols', 'sandboxId', sandboxId)
      // verify required parameter 'languageId' is not null or undefined
      ;(0, common_1.assertParamExists)('lspWorkspaceSymbols', 'languageId', languageId)
      // verify required parameter 'pathToProject' is not null or undefined
      ;(0, common_1.assertParamExists)('lspWorkspaceSymbols', 'pathToProject', pathToProject)
      // verify required parameter 'query' is not null or undefined
      ;(0, common_1.assertParamExists)('lspWorkspaceSymbols', 'query', query)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/lsp/workspace-symbols`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      if (languageId !== undefined) {
        localVarQueryParameter['languageId'] = languageId
      }
      if (pathToProject !== undefined) {
        localVarQueryParameter['pathToProject'] = pathToProject
      }
      if (query !== undefined) {
        localVarQueryParameter['query'] = query
      }
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Move file inside sandbox
     * @summary Move file
     * @param {string} sandboxId
     * @param {string} source
     * @param {string} destination
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moveFile: async (sandboxId, source, destination, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('moveFile', 'sandboxId', sandboxId)
      // verify required parameter 'source' is not null or undefined
      ;(0, common_1.assertParamExists)('moveFile', 'source', source)
      // verify required parameter 'destination' is not null or undefined
      ;(0, common_1.assertParamExists)('moveFile', 'destination', destination)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files/move`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      if (source !== undefined) {
        localVarQueryParameter['source'] = source
      }
      if (destination !== undefined) {
        localVarQueryParameter['destination'] = destination
      }
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Replace text/pattern in multiple files inside sandbox
     * @summary Replace in files
     * @param {string} sandboxId
     * @param {ReplaceRequest} replaceRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceInFiles: async (sandboxId, replaceRequest, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('replaceInFiles', 'sandboxId', sandboxId)
      // verify required parameter 'replaceRequest' is not null or undefined
      ;(0, common_1.assertParamExists)('replaceInFiles', 'replaceRequest', replaceRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files/replace`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      localVarHeaderParameter['Content-Type'] = 'application/json'
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(
        replaceRequest,
        localVarRequestOptions,
        configuration,
      )
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Search for files inside sandbox
     * @summary Search files
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} pattern
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchFiles: async (sandboxId, path, pattern, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('searchFiles', 'sandboxId', sandboxId)
      // verify required parameter 'path' is not null or undefined
      ;(0, common_1.assertParamExists)('searchFiles', 'path', path)
      // verify required parameter 'pattern' is not null or undefined
      ;(0, common_1.assertParamExists)('searchFiles', 'pattern', pattern)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files/search`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }
      if (pattern !== undefined) {
        localVarQueryParameter['pattern'] = pattern
      }
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Set file owner/group/permissions inside sandbox
     * @summary Set file permissions
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {string} [owner]
     * @param {string} [group]
     * @param {string} [mode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFilePermissions: async (sandboxId, path, xDaytonaOrganizationID, owner, group, mode, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('setFilePermissions', 'sandboxId', sandboxId)
      // verify required parameter 'path' is not null or undefined
      ;(0, common_1.assertParamExists)('setFilePermissions', 'path', path)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files/permissions`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }
      if (owner !== undefined) {
        localVarQueryParameter['owner'] = owner
      }
      if (group !== undefined) {
        localVarQueryParameter['group'] = group
      }
      if (mode !== undefined) {
        localVarQueryParameter['mode'] = mode
      }
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Upload file inside sandbox
     * @summary Upload file
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {File} [file]
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    uploadFile: async (sandboxId, path, xDaytonaOrganizationID, file, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('uploadFile', 'sandboxId', sandboxId)
      // verify required parameter 'path' is not null or undefined
      ;(0, common_1.assertParamExists)('uploadFile', 'path', path)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files/upload`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)()
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }
      if (file !== undefined) {
        localVarFormParams.append('file', file)
      }
      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = localVarFormParams
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Upload multiple files inside sandbox
     * @summary Upload multiple files
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFiles: async (sandboxId, xDaytonaOrganizationID, options = {}) => {
      // verify required parameter 'sandboxId' is not null or undefined
      ;(0, common_1.assertParamExists)('uploadFiles', 'sandboxId', sandboxId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files/bulk-upload`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {}
      const localVarQueryParameter = {}
      // authentication bearer required
      // http bearer authentication required
      await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)
      // authentication oauth2 required
      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      ;(0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      return {
        url: (0, common_1.toPathString)(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}
exports.ToolboxApiAxiosParamCreator = ToolboxApiAxiosParamCreator
/**
 * ToolboxApi - functional programming interface
 * @export
 */
const ToolboxApiFp = function (configuration) {
  const localVarAxiosParamCreator = (0, exports.ToolboxApiAxiosParamCreator)(configuration)
  return {
    /**
     * Create folder inside sandbox
     * @summary Create folder
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} mode
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFolder(sandboxId, path, mode, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createFolder(
        sandboxId,
        path,
        mode,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.createFolder']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Create a new session in the sandbox
     * @summary Create session
     * @param {string} sandboxId
     * @param {CreateSessionRequest} createSessionRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSession(sandboxId, createSessionRequest, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createSession(
        sandboxId,
        createSessionRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.createSession']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Delete file inside sandbox
     * @summary Delete file
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFile(sandboxId, path, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(
        sandboxId,
        path,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.deleteFile']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Delete a specific session
     * @summary Delete session
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSession(sandboxId, sessionId, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSession(
        sandboxId,
        sessionId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.deleteSession']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Download file from sandbox
     * @summary Download file
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadFile(sandboxId, path, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(
        sandboxId,
        path,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.downloadFile']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Execute command synchronously inside sandbox
     * @summary Execute command
     * @param {string} sandboxId
     * @param {ExecuteRequest} executeRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async executeCommand(sandboxId, executeRequest, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.executeCommand(
        sandboxId,
        executeRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.executeCommand']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Execute a command in a specific session
     * @summary Execute command in session
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {SessionExecuteRequest} sessionExecuteRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async executeSessionCommand(sandboxId, sessionId, sessionExecuteRequest, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.executeSessionCommand(
        sandboxId,
        sessionId,
        sessionExecuteRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.executeSessionCommand']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Search for text/pattern inside sandbox files
     * @summary Search for text/pattern in files
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} pattern
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findInFiles(sandboxId, path, pattern, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findInFiles(
        sandboxId,
        path,
        pattern,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.findInFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get file info inside sandbox
     * @summary Get file info
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFileInfo(sandboxId, path, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFileInfo(
        sandboxId,
        path,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.getFileInfo']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Get sandbox project dir
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProjectDir(sandboxId, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectDir(
        sandboxId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.getProjectDir']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get session by ID
     * @summary Get session
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSession(sandboxId, sessionId, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSession(
        sandboxId,
        sessionId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.getSession']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get session command by ID
     * @summary Get session command
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} commandId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSessionCommand(sandboxId, sessionId, commandId, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionCommand(
        sandboxId,
        sessionId,
        commandId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.getSessionCommand']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get logs for a specific command in a session
     * @summary Get command logs
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} commandId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {boolean} [follow]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSessionCommandLogs(sandboxId, sessionId, commandId, xDaytonaOrganizationID, follow, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionCommandLogs(
        sandboxId,
        sessionId,
        commandId,
        xDaytonaOrganizationID,
        follow,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.getSessionCommandLogs']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Add files to git commit
     * @summary Add files
     * @param {string} sandboxId
     * @param {GitAddRequest} gitAddRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitAddFiles(sandboxId, gitAddRequest, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitAddFiles(
        sandboxId,
        gitAddRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.gitAddFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Checkout branch or commit in git repository
     * @summary Checkout branch
     * @param {string} sandboxId
     * @param {GitCheckoutRequest} gitCheckoutRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitCheckoutBranch(sandboxId, gitCheckoutRequest, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitCheckoutBranch(
        sandboxId,
        gitCheckoutRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.gitCheckoutBranch']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Clone git repository
     * @summary Clone repository
     * @param {string} sandboxId
     * @param {GitCloneRequest} gitCloneRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitCloneRepository(sandboxId, gitCloneRequest, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitCloneRepository(
        sandboxId,
        gitCloneRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.gitCloneRepository']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Commit changes to git repository
     * @summary Commit changes
     * @param {string} sandboxId
     * @param {GitCommitRequest} gitCommitRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitCommitChanges(sandboxId, gitCommitRequest, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitCommitChanges(
        sandboxId,
        gitCommitRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.gitCommitChanges']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Create branch on git repository
     * @summary Create branch
     * @param {string} sandboxId
     * @param {GitBranchRequest} gitBranchRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitCreateBranch(sandboxId, gitBranchRequest, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitCreateBranch(
        sandboxId,
        gitBranchRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.gitCreateBranch']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Delete branch on git repository
     * @summary Delete branch
     * @param {string} sandboxId
     * @param {GitDeleteBranchRequest} gitDeleteBranchRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitDeleteBranch(sandboxId, gitDeleteBranchRequest, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitDeleteBranch(
        sandboxId,
        gitDeleteBranchRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.gitDeleteBranch']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get commit history from git repository
     * @summary Get commit history
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitGetHistory(sandboxId, path, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitGetHistory(
        sandboxId,
        path,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.gitGetHistory']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get status from git repository
     * @summary Get git status
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitGetStatus(sandboxId, path, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitGetStatus(
        sandboxId,
        path,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.gitGetStatus']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get branch list from git repository
     * @summary Get branch list
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitListBranches(sandboxId, path, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitListBranches(
        sandboxId,
        path,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.gitListBranches']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Pull changes from remote
     * @summary Pull changes
     * @param {string} sandboxId
     * @param {GitRepoRequest} gitRepoRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitPullChanges(sandboxId, gitRepoRequest, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitPullChanges(
        sandboxId,
        gitRepoRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.gitPullChanges']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Push changes to remote
     * @summary Push changes
     * @param {string} sandboxId
     * @param {GitRepoRequest} gitRepoRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitPushChanges(sandboxId, gitRepoRequest, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitPushChanges(
        sandboxId,
        gitRepoRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.gitPushChanges']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary List files
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {string} [path]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listFiles(sandboxId, xDaytonaOrganizationID, path, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listFiles(
        sandboxId,
        xDaytonaOrganizationID,
        path,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.listFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * List all active sessions in the sandbox
     * @summary List sessions
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listSessions(sandboxId, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listSessions(sandboxId, xDaytonaOrganizationID, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.listSessions']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * The Completion request is sent from the client to the server to compute completion items at a given cursor position.
     * @summary Get Lsp Completions
     * @param {string} sandboxId
     * @param {LspCompletionParams} lspCompletionParams
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lspCompletions(sandboxId, lspCompletionParams, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lspCompletions(
        sandboxId,
        lspCompletionParams,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.lspCompletions']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * The document close notification is sent from the client to the server when the document got closed in the client.
     * @summary Call Lsp DidClose
     * @param {string} sandboxId
     * @param {LspDocumentRequest} lspDocumentRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lspDidClose(sandboxId, lspDocumentRequest, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lspDidClose(
        sandboxId,
        lspDocumentRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.lspDidClose']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * The document open notification is sent from the client to the server to signal newly opened text documents.
     * @summary Call Lsp DidOpen
     * @param {string} sandboxId
     * @param {LspDocumentRequest} lspDocumentRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lspDidOpen(sandboxId, lspDocumentRequest, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lspDidOpen(
        sandboxId,
        lspDocumentRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.lspDidOpen']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * The document symbol request is sent from the client to the server.
     * @summary Call Lsp DocumentSymbols
     * @param {string} sandboxId
     * @param {string} languageId
     * @param {string} pathToProject
     * @param {string} uri
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lspDocumentSymbols(sandboxId, languageId, pathToProject, uri, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lspDocumentSymbols(
        sandboxId,
        languageId,
        pathToProject,
        uri,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.lspDocumentSymbols']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Start Lsp server process inside sandbox project
     * @summary Start Lsp server
     * @param {string} sandboxId
     * @param {LspServerRequest} lspServerRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lspStart(sandboxId, lspServerRequest, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lspStart(
        sandboxId,
        lspServerRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.lspStart']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Stop Lsp server process inside sandbox project
     * @summary Stop Lsp server
     * @param {string} sandboxId
     * @param {LspServerRequest} lspServerRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lspStop(sandboxId, lspServerRequest, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lspStop(
        sandboxId,
        lspServerRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.lspStop']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.
     * @summary Call Lsp WorkspaceSymbols
     * @param {string} sandboxId
     * @param {string} languageId
     * @param {string} pathToProject
     * @param {string} query
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lspWorkspaceSymbols(sandboxId, languageId, pathToProject, query, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lspWorkspaceSymbols(
        sandboxId,
        languageId,
        pathToProject,
        query,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.lspWorkspaceSymbols']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Move file inside sandbox
     * @summary Move file
     * @param {string} sandboxId
     * @param {string} source
     * @param {string} destination
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async moveFile(sandboxId, source, destination, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.moveFile(
        sandboxId,
        source,
        destination,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.moveFile']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Replace text/pattern in multiple files inside sandbox
     * @summary Replace in files
     * @param {string} sandboxId
     * @param {ReplaceRequest} replaceRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async replaceInFiles(sandboxId, replaceRequest, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.replaceInFiles(
        sandboxId,
        replaceRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.replaceInFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Search for files inside sandbox
     * @summary Search files
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} pattern
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchFiles(sandboxId, path, pattern, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchFiles(
        sandboxId,
        path,
        pattern,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.searchFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Set file owner/group/permissions inside sandbox
     * @summary Set file permissions
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {string} [owner]
     * @param {string} [group]
     * @param {string} [mode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setFilePermissions(sandboxId, path, xDaytonaOrganizationID, owner, group, mode, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setFilePermissions(
        sandboxId,
        path,
        xDaytonaOrganizationID,
        owner,
        group,
        mode,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.setFilePermissions']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Upload file inside sandbox
     * @summary Upload file
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {File} [file]
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async uploadFile(sandboxId, path, xDaytonaOrganizationID, file, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(
        sandboxId,
        path,
        xDaytonaOrganizationID,
        file,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.uploadFile']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Upload multiple files inside sandbox
     * @summary Upload multiple files
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadFiles(sandboxId, xDaytonaOrganizationID, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFiles(sandboxId, xDaytonaOrganizationID, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        base_1.operationServerMap['ToolboxApi.uploadFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        (0, common_1.createRequestFunction)(
          localVarAxiosArgs,
          axios_1.default,
          base_1.BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}
exports.ToolboxApiFp = ToolboxApiFp
/**
 * ToolboxApi - factory interface
 * @export
 */
const ToolboxApiFactory = function (configuration, basePath, axios) {
  const localVarFp = (0, exports.ToolboxApiFp)(configuration)
  return {
    /**
     * Create folder inside sandbox
     * @summary Create folder
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} mode
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFolder(sandboxId, path, mode, xDaytonaOrganizationID, options) {
      return localVarFp
        .createFolder(sandboxId, path, mode, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Create a new session in the sandbox
     * @summary Create session
     * @param {string} sandboxId
     * @param {CreateSessionRequest} createSessionRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSession(sandboxId, createSessionRequest, xDaytonaOrganizationID, options) {
      return localVarFp
        .createSession(sandboxId, createSessionRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete file inside sandbox
     * @summary Delete file
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(sandboxId, path, xDaytonaOrganizationID, options) {
      return localVarFp
        .deleteFile(sandboxId, path, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete a specific session
     * @summary Delete session
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSession(sandboxId, sessionId, xDaytonaOrganizationID, options) {
      return localVarFp
        .deleteSession(sandboxId, sessionId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Download file from sandbox
     * @summary Download file
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile(sandboxId, path, xDaytonaOrganizationID, options) {
      return localVarFp
        .downloadFile(sandboxId, path, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Execute command synchronously inside sandbox
     * @summary Execute command
     * @param {string} sandboxId
     * @param {ExecuteRequest} executeRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeCommand(sandboxId, executeRequest, xDaytonaOrganizationID, options) {
      return localVarFp
        .executeCommand(sandboxId, executeRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Execute a command in a specific session
     * @summary Execute command in session
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {SessionExecuteRequest} sessionExecuteRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeSessionCommand(sandboxId, sessionId, sessionExecuteRequest, xDaytonaOrganizationID, options) {
      return localVarFp
        .executeSessionCommand(sandboxId, sessionId, sessionExecuteRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Search for text/pattern inside sandbox files
     * @summary Search for text/pattern in files
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} pattern
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findInFiles(sandboxId, path, pattern, xDaytonaOrganizationID, options) {
      return localVarFp
        .findInFiles(sandboxId, path, pattern, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get file info inside sandbox
     * @summary Get file info
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileInfo(sandboxId, path, xDaytonaOrganizationID, options) {
      return localVarFp
        .getFileInfo(sandboxId, path, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get sandbox project dir
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectDir(sandboxId, xDaytonaOrganizationID, options) {
      return localVarFp
        .getProjectDir(sandboxId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get session by ID
     * @summary Get session
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSession(sandboxId, sessionId, xDaytonaOrganizationID, options) {
      return localVarFp
        .getSession(sandboxId, sessionId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get session command by ID
     * @summary Get session command
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} commandId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionCommand(sandboxId, sessionId, commandId, xDaytonaOrganizationID, options) {
      return localVarFp
        .getSessionCommand(sandboxId, sessionId, commandId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get logs for a specific command in a session
     * @summary Get command logs
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} commandId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {boolean} [follow]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionCommandLogs(sandboxId, sessionId, commandId, xDaytonaOrganizationID, follow, options) {
      return localVarFp
        .getSessionCommandLogs(sandboxId, sessionId, commandId, xDaytonaOrganizationID, follow, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Add files to git commit
     * @summary Add files
     * @param {string} sandboxId
     * @param {GitAddRequest} gitAddRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitAddFiles(sandboxId, gitAddRequest, xDaytonaOrganizationID, options) {
      return localVarFp
        .gitAddFiles(sandboxId, gitAddRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Checkout branch or commit in git repository
     * @summary Checkout branch
     * @param {string} sandboxId
     * @param {GitCheckoutRequest} gitCheckoutRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCheckoutBranch(sandboxId, gitCheckoutRequest, xDaytonaOrganizationID, options) {
      return localVarFp
        .gitCheckoutBranch(sandboxId, gitCheckoutRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Clone git repository
     * @summary Clone repository
     * @param {string} sandboxId
     * @param {GitCloneRequest} gitCloneRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCloneRepository(sandboxId, gitCloneRequest, xDaytonaOrganizationID, options) {
      return localVarFp
        .gitCloneRepository(sandboxId, gitCloneRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Commit changes to git repository
     * @summary Commit changes
     * @param {string} sandboxId
     * @param {GitCommitRequest} gitCommitRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCommitChanges(sandboxId, gitCommitRequest, xDaytonaOrganizationID, options) {
      return localVarFp
        .gitCommitChanges(sandboxId, gitCommitRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Create branch on git repository
     * @summary Create branch
     * @param {string} sandboxId
     * @param {GitBranchRequest} gitBranchRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCreateBranch(sandboxId, gitBranchRequest, xDaytonaOrganizationID, options) {
      return localVarFp
        .gitCreateBranch(sandboxId, gitBranchRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete branch on git repository
     * @summary Delete branch
     * @param {string} sandboxId
     * @param {GitDeleteBranchRequest} gitDeleteBranchRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitDeleteBranch(sandboxId, gitDeleteBranchRequest, xDaytonaOrganizationID, options) {
      return localVarFp
        .gitDeleteBranch(sandboxId, gitDeleteBranchRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get commit history from git repository
     * @summary Get commit history
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitGetHistory(sandboxId, path, xDaytonaOrganizationID, options) {
      return localVarFp
        .gitGetHistory(sandboxId, path, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get status from git repository
     * @summary Get git status
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitGetStatus(sandboxId, path, xDaytonaOrganizationID, options) {
      return localVarFp
        .gitGetStatus(sandboxId, path, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get branch list from git repository
     * @summary Get branch list
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitListBranches(sandboxId, path, xDaytonaOrganizationID, options) {
      return localVarFp
        .gitListBranches(sandboxId, path, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Pull changes from remote
     * @summary Pull changes
     * @param {string} sandboxId
     * @param {GitRepoRequest} gitRepoRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitPullChanges(sandboxId, gitRepoRequest, xDaytonaOrganizationID, options) {
      return localVarFp
        .gitPullChanges(sandboxId, gitRepoRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Push changes to remote
     * @summary Push changes
     * @param {string} sandboxId
     * @param {GitRepoRequest} gitRepoRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitPushChanges(sandboxId, gitRepoRequest, xDaytonaOrganizationID, options) {
      return localVarFp
        .gitPushChanges(sandboxId, gitRepoRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List files
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {string} [path]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFiles(sandboxId, xDaytonaOrganizationID, path, options) {
      return localVarFp
        .listFiles(sandboxId, xDaytonaOrganizationID, path, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List all active sessions in the sandbox
     * @summary List sessions
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSessions(sandboxId, xDaytonaOrganizationID, options) {
      return localVarFp
        .listSessions(sandboxId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * The Completion request is sent from the client to the server to compute completion items at a given cursor position.
     * @summary Get Lsp Completions
     * @param {string} sandboxId
     * @param {LspCompletionParams} lspCompletionParams
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspCompletions(sandboxId, lspCompletionParams, xDaytonaOrganizationID, options) {
      return localVarFp
        .lspCompletions(sandboxId, lspCompletionParams, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * The document close notification is sent from the client to the server when the document got closed in the client.
     * @summary Call Lsp DidClose
     * @param {string} sandboxId
     * @param {LspDocumentRequest} lspDocumentRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspDidClose(sandboxId, lspDocumentRequest, xDaytonaOrganizationID, options) {
      return localVarFp
        .lspDidClose(sandboxId, lspDocumentRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * The document open notification is sent from the client to the server to signal newly opened text documents.
     * @summary Call Lsp DidOpen
     * @param {string} sandboxId
     * @param {LspDocumentRequest} lspDocumentRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspDidOpen(sandboxId, lspDocumentRequest, xDaytonaOrganizationID, options) {
      return localVarFp
        .lspDidOpen(sandboxId, lspDocumentRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * The document symbol request is sent from the client to the server.
     * @summary Call Lsp DocumentSymbols
     * @param {string} sandboxId
     * @param {string} languageId
     * @param {string} pathToProject
     * @param {string} uri
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspDocumentSymbols(sandboxId, languageId, pathToProject, uri, xDaytonaOrganizationID, options) {
      return localVarFp
        .lspDocumentSymbols(sandboxId, languageId, pathToProject, uri, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Start Lsp server process inside sandbox project
     * @summary Start Lsp server
     * @param {string} sandboxId
     * @param {LspServerRequest} lspServerRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspStart(sandboxId, lspServerRequest, xDaytonaOrganizationID, options) {
      return localVarFp
        .lspStart(sandboxId, lspServerRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Stop Lsp server process inside sandbox project
     * @summary Stop Lsp server
     * @param {string} sandboxId
     * @param {LspServerRequest} lspServerRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspStop(sandboxId, lspServerRequest, xDaytonaOrganizationID, options) {
      return localVarFp
        .lspStop(sandboxId, lspServerRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.
     * @summary Call Lsp WorkspaceSymbols
     * @param {string} sandboxId
     * @param {string} languageId
     * @param {string} pathToProject
     * @param {string} query
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspWorkspaceSymbols(sandboxId, languageId, pathToProject, query, xDaytonaOrganizationID, options) {
      return localVarFp
        .lspWorkspaceSymbols(sandboxId, languageId, pathToProject, query, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Move file inside sandbox
     * @summary Move file
     * @param {string} sandboxId
     * @param {string} source
     * @param {string} destination
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moveFile(sandboxId, source, destination, xDaytonaOrganizationID, options) {
      return localVarFp
        .moveFile(sandboxId, source, destination, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Replace text/pattern in multiple files inside sandbox
     * @summary Replace in files
     * @param {string} sandboxId
     * @param {ReplaceRequest} replaceRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceInFiles(sandboxId, replaceRequest, xDaytonaOrganizationID, options) {
      return localVarFp
        .replaceInFiles(sandboxId, replaceRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Search for files inside sandbox
     * @summary Search files
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} pattern
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchFiles(sandboxId, path, pattern, xDaytonaOrganizationID, options) {
      return localVarFp
        .searchFiles(sandboxId, path, pattern, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Set file owner/group/permissions inside sandbox
     * @summary Set file permissions
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {string} [owner]
     * @param {string} [group]
     * @param {string} [mode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFilePermissions(sandboxId, path, xDaytonaOrganizationID, owner, group, mode, options) {
      return localVarFp
        .setFilePermissions(sandboxId, path, xDaytonaOrganizationID, owner, group, mode, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Upload file inside sandbox
     * @summary Upload file
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {File} [file]
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    uploadFile(sandboxId, path, xDaytonaOrganizationID, file, options) {
      return localVarFp
        .uploadFile(sandboxId, path, xDaytonaOrganizationID, file, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Upload multiple files inside sandbox
     * @summary Upload multiple files
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFiles(sandboxId, xDaytonaOrganizationID, options) {
      return localVarFp
        .uploadFiles(sandboxId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
  }
}
exports.ToolboxApiFactory = ToolboxApiFactory
/**
 * ToolboxApi - object-oriented interface
 * @export
 * @class ToolboxApi
 * @extends {BaseAPI}
 */
class ToolboxApi extends base_1.BaseAPI {
  /**
   * Create folder inside sandbox
   * @summary Create folder
   * @param {string} sandboxId
   * @param {string} path
   * @param {string} mode
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  createFolder(sandboxId, path, mode, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .createFolder(sandboxId, path, mode, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Create a new session in the sandbox
   * @summary Create session
   * @param {string} sandboxId
   * @param {CreateSessionRequest} createSessionRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  createSession(sandboxId, createSessionRequest, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .createSession(sandboxId, createSessionRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Delete file inside sandbox
   * @summary Delete file
   * @param {string} sandboxId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  deleteFile(sandboxId, path, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .deleteFile(sandboxId, path, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Delete a specific session
   * @summary Delete session
   * @param {string} sandboxId
   * @param {string} sessionId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  deleteSession(sandboxId, sessionId, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .deleteSession(sandboxId, sessionId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Download file from sandbox
   * @summary Download file
   * @param {string} sandboxId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  downloadFile(sandboxId, path, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .downloadFile(sandboxId, path, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Execute command synchronously inside sandbox
   * @summary Execute command
   * @param {string} sandboxId
   * @param {ExecuteRequest} executeRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  executeCommand(sandboxId, executeRequest, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .executeCommand(sandboxId, executeRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Execute a command in a specific session
   * @summary Execute command in session
   * @param {string} sandboxId
   * @param {string} sessionId
   * @param {SessionExecuteRequest} sessionExecuteRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  executeSessionCommand(sandboxId, sessionId, sessionExecuteRequest, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .executeSessionCommand(sandboxId, sessionId, sessionExecuteRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Search for text/pattern inside sandbox files
   * @summary Search for text/pattern in files
   * @param {string} sandboxId
   * @param {string} path
   * @param {string} pattern
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  findInFiles(sandboxId, path, pattern, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .findInFiles(sandboxId, path, pattern, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Get file info inside sandbox
   * @summary Get file info
   * @param {string} sandboxId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  getFileInfo(sandboxId, path, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .getFileInfo(sandboxId, path, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   *
   * @summary Get sandbox project dir
   * @param {string} sandboxId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  getProjectDir(sandboxId, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .getProjectDir(sandboxId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Get session by ID
   * @summary Get session
   * @param {string} sandboxId
   * @param {string} sessionId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  getSession(sandboxId, sessionId, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .getSession(sandboxId, sessionId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Get session command by ID
   * @summary Get session command
   * @param {string} sandboxId
   * @param {string} sessionId
   * @param {string} commandId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  getSessionCommand(sandboxId, sessionId, commandId, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .getSessionCommand(sandboxId, sessionId, commandId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Get logs for a specific command in a session
   * @summary Get command logs
   * @param {string} sandboxId
   * @param {string} sessionId
   * @param {string} commandId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {boolean} [follow]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  getSessionCommandLogs(sandboxId, sessionId, commandId, xDaytonaOrganizationID, follow, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .getSessionCommandLogs(sandboxId, sessionId, commandId, xDaytonaOrganizationID, follow, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Add files to git commit
   * @summary Add files
   * @param {string} sandboxId
   * @param {GitAddRequest} gitAddRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  gitAddFiles(sandboxId, gitAddRequest, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .gitAddFiles(sandboxId, gitAddRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Checkout branch or commit in git repository
   * @summary Checkout branch
   * @param {string} sandboxId
   * @param {GitCheckoutRequest} gitCheckoutRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  gitCheckoutBranch(sandboxId, gitCheckoutRequest, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .gitCheckoutBranch(sandboxId, gitCheckoutRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Clone git repository
   * @summary Clone repository
   * @param {string} sandboxId
   * @param {GitCloneRequest} gitCloneRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  gitCloneRepository(sandboxId, gitCloneRequest, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .gitCloneRepository(sandboxId, gitCloneRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Commit changes to git repository
   * @summary Commit changes
   * @param {string} sandboxId
   * @param {GitCommitRequest} gitCommitRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  gitCommitChanges(sandboxId, gitCommitRequest, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .gitCommitChanges(sandboxId, gitCommitRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Create branch on git repository
   * @summary Create branch
   * @param {string} sandboxId
   * @param {GitBranchRequest} gitBranchRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  gitCreateBranch(sandboxId, gitBranchRequest, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .gitCreateBranch(sandboxId, gitBranchRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Delete branch on git repository
   * @summary Delete branch
   * @param {string} sandboxId
   * @param {GitDeleteBranchRequest} gitDeleteBranchRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  gitDeleteBranch(sandboxId, gitDeleteBranchRequest, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .gitDeleteBranch(sandboxId, gitDeleteBranchRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Get commit history from git repository
   * @summary Get commit history
   * @param {string} sandboxId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  gitGetHistory(sandboxId, path, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .gitGetHistory(sandboxId, path, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Get status from git repository
   * @summary Get git status
   * @param {string} sandboxId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  gitGetStatus(sandboxId, path, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .gitGetStatus(sandboxId, path, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Get branch list from git repository
   * @summary Get branch list
   * @param {string} sandboxId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  gitListBranches(sandboxId, path, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .gitListBranches(sandboxId, path, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Pull changes from remote
   * @summary Pull changes
   * @param {string} sandboxId
   * @param {GitRepoRequest} gitRepoRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  gitPullChanges(sandboxId, gitRepoRequest, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .gitPullChanges(sandboxId, gitRepoRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Push changes to remote
   * @summary Push changes
   * @param {string} sandboxId
   * @param {GitRepoRequest} gitRepoRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  gitPushChanges(sandboxId, gitRepoRequest, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .gitPushChanges(sandboxId, gitRepoRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   *
   * @summary List files
   * @param {string} sandboxId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {string} [path]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  listFiles(sandboxId, xDaytonaOrganizationID, path, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .listFiles(sandboxId, xDaytonaOrganizationID, path, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * List all active sessions in the sandbox
   * @summary List sessions
   * @param {string} sandboxId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  listSessions(sandboxId, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .listSessions(sandboxId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * The Completion request is sent from the client to the server to compute completion items at a given cursor position.
   * @summary Get Lsp Completions
   * @param {string} sandboxId
   * @param {LspCompletionParams} lspCompletionParams
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  lspCompletions(sandboxId, lspCompletionParams, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .lspCompletions(sandboxId, lspCompletionParams, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * The document close notification is sent from the client to the server when the document got closed in the client.
   * @summary Call Lsp DidClose
   * @param {string} sandboxId
   * @param {LspDocumentRequest} lspDocumentRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  lspDidClose(sandboxId, lspDocumentRequest, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .lspDidClose(sandboxId, lspDocumentRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * The document open notification is sent from the client to the server to signal newly opened text documents.
   * @summary Call Lsp DidOpen
   * @param {string} sandboxId
   * @param {LspDocumentRequest} lspDocumentRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  lspDidOpen(sandboxId, lspDocumentRequest, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .lspDidOpen(sandboxId, lspDocumentRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * The document symbol request is sent from the client to the server.
   * @summary Call Lsp DocumentSymbols
   * @param {string} sandboxId
   * @param {string} languageId
   * @param {string} pathToProject
   * @param {string} uri
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  lspDocumentSymbols(sandboxId, languageId, pathToProject, uri, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .lspDocumentSymbols(sandboxId, languageId, pathToProject, uri, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Start Lsp server process inside sandbox project
   * @summary Start Lsp server
   * @param {string} sandboxId
   * @param {LspServerRequest} lspServerRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  lspStart(sandboxId, lspServerRequest, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .lspStart(sandboxId, lspServerRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Stop Lsp server process inside sandbox project
   * @summary Stop Lsp server
   * @param {string} sandboxId
   * @param {LspServerRequest} lspServerRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  lspStop(sandboxId, lspServerRequest, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .lspStop(sandboxId, lspServerRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.
   * @summary Call Lsp WorkspaceSymbols
   * @param {string} sandboxId
   * @param {string} languageId
   * @param {string} pathToProject
   * @param {string} query
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  lspWorkspaceSymbols(sandboxId, languageId, pathToProject, query, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .lspWorkspaceSymbols(sandboxId, languageId, pathToProject, query, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Move file inside sandbox
   * @summary Move file
   * @param {string} sandboxId
   * @param {string} source
   * @param {string} destination
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  moveFile(sandboxId, source, destination, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .moveFile(sandboxId, source, destination, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Replace text/pattern in multiple files inside sandbox
   * @summary Replace in files
   * @param {string} sandboxId
   * @param {ReplaceRequest} replaceRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  replaceInFiles(sandboxId, replaceRequest, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .replaceInFiles(sandboxId, replaceRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Search for files inside sandbox
   * @summary Search files
   * @param {string} sandboxId
   * @param {string} path
   * @param {string} pattern
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  searchFiles(sandboxId, path, pattern, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .searchFiles(sandboxId, path, pattern, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Set file owner/group/permissions inside sandbox
   * @summary Set file permissions
   * @param {string} sandboxId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {string} [owner]
   * @param {string} [group]
   * @param {string} [mode]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  setFilePermissions(sandboxId, path, xDaytonaOrganizationID, owner, group, mode, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .setFilePermissions(sandboxId, path, xDaytonaOrganizationID, owner, group, mode, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Upload file inside sandbox
   * @summary Upload file
   * @param {string} sandboxId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {File} [file]
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  uploadFile(sandboxId, path, xDaytonaOrganizationID, file, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .uploadFile(sandboxId, path, xDaytonaOrganizationID, file, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * Upload multiple files inside sandbox
   * @summary Upload multiple files
   * @param {string} sandboxId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  uploadFiles(sandboxId, xDaytonaOrganizationID, options) {
    return (0, exports.ToolboxApiFp)(this.configuration)
      .uploadFiles(sandboxId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
exports.ToolboxApi = ToolboxApi
//# sourceMappingURL=toolbox-api.js.map
