/* tslint:disable */
/* eslint-disable */
/**
 * Daytona
 * Daytona AI platform API Docs
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@daytona.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from '../configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from '../common'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base'
// @ts-ignore
import type { Command } from '../models'
// @ts-ignore
import type { CompletionList } from '../models'
// @ts-ignore
import type { CompressedScreenshotResponse } from '../models'
// @ts-ignore
import type { ComputerUseStartResponse } from '../models'
// @ts-ignore
import type { ComputerUseStatusResponse } from '../models'
// @ts-ignore
import type { ComputerUseStopResponse } from '../models'
// @ts-ignore
import type { CreateSessionRequest } from '../models'
// @ts-ignore
import type { DisplayInfoResponse } from '../models'
// @ts-ignore
import type { ExecuteRequest } from '../models'
// @ts-ignore
import type { ExecuteResponse } from '../models'
// @ts-ignore
import type { FileInfo } from '../models'
// @ts-ignore
import type { GitAddRequest } from '../models'
// @ts-ignore
import type { GitBranchRequest } from '../models'
// @ts-ignore
import type { GitCheckoutRequest } from '../models'
// @ts-ignore
import type { GitCloneRequest } from '../models'
// @ts-ignore
import type { GitCommitInfo } from '../models'
// @ts-ignore
import type { GitCommitRequest } from '../models'
// @ts-ignore
import type { GitCommitResponse } from '../models'
// @ts-ignore
import type { GitDeleteBranchRequest } from '../models'
// @ts-ignore
import type { GitRepoRequest } from '../models'
// @ts-ignore
import type { GitStatus } from '../models'
// @ts-ignore
import type { KeyboardHotkeyRequest } from '../models'
// @ts-ignore
import type { KeyboardPressRequest } from '../models'
// @ts-ignore
import type { KeyboardTypeRequest } from '../models'
// @ts-ignore
import type { ListBranchResponse } from '../models'
// @ts-ignore
import type { LspCompletionParams } from '../models'
// @ts-ignore
import type { LspDocumentRequest } from '../models'
// @ts-ignore
import type { LspServerRequest } from '../models'
// @ts-ignore
import type { LspSymbol } from '../models'
// @ts-ignore
import type { Match } from '../models'
// @ts-ignore
import type { MouseClickRequest } from '../models'
// @ts-ignore
import type { MouseClickResponse } from '../models'
// @ts-ignore
import type { MouseDragRequest } from '../models'
// @ts-ignore
import type { MouseDragResponse } from '../models'
// @ts-ignore
import type { MouseMoveRequest } from '../models'
// @ts-ignore
import type { MouseMoveResponse } from '../models'
// @ts-ignore
import type { MousePosition } from '../models'
// @ts-ignore
import type { MouseScrollRequest } from '../models'
// @ts-ignore
import type { MouseScrollResponse } from '../models'
// @ts-ignore
import type { ProcessErrorsResponse } from '../models'
// @ts-ignore
import type { ProcessLogsResponse } from '../models'
// @ts-ignore
import type { ProcessRestartResponse } from '../models'
// @ts-ignore
import type { ProcessStatusResponse } from '../models'
// @ts-ignore
import type { ProjectDirResponse } from '../models'
// @ts-ignore
import type { RegionScreenshotResponse } from '../models'
// @ts-ignore
import type { ReplaceRequest } from '../models'
// @ts-ignore
import type { ReplaceResult } from '../models'
// @ts-ignore
import type { ScreenshotResponse } from '../models'
// @ts-ignore
import type { SearchFilesResponse } from '../models'
// @ts-ignore
import type { Session } from '../models'
// @ts-ignore
import type { SessionExecuteRequest } from '../models'
// @ts-ignore
import type { SessionExecuteResponse } from '../models'
// @ts-ignore
import type { WindowsResponse } from '../models'
/**
 * ToolboxApi - axios parameter creator
 * @export
 */
export const ToolboxApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Click mouse at specified coordinates
     * @summary Click mouse
     * @param {string} sandboxId
     * @param {MouseClickRequest} mouseClickRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clickMouse: async (
      sandboxId: string,
      mouseClickRequest: MouseClickRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('clickMouse', 'sandboxId', sandboxId)
      // verify required parameter 'mouseClickRequest' is not null or undefined
      assertParamExists('clickMouse', 'mouseClickRequest', mouseClickRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/computeruse/mouse/click`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(mouseClickRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create folder inside sandbox
     * @summary Create folder
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} mode
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFolder: async (
      sandboxId: string,
      path: string,
      mode: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('createFolder', 'sandboxId', sandboxId)
      // verify required parameter 'path' is not null or undefined
      assertParamExists('createFolder', 'path', path)
      // verify required parameter 'mode' is not null or undefined
      assertParamExists('createFolder', 'mode', mode)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files/folder`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (mode !== undefined) {
        localVarQueryParameter['mode'] = mode
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create a new session in the sandbox
     * @summary Create session
     * @param {string} sandboxId
     * @param {CreateSessionRequest} createSessionRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSession: async (
      sandboxId: string,
      createSessionRequest: CreateSessionRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('createSession', 'sandboxId', sandboxId)
      // verify required parameter 'createSessionRequest' is not null or undefined
      assertParamExists('createSession', 'createSessionRequest', createSessionRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/process/session`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createSessionRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete file inside sandbox
     * @summary Delete file
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile: async (
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('deleteFile', 'sandboxId', sandboxId)
      // verify required parameter 'path' is not null or undefined
      assertParamExists('deleteFile', 'path', path)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete a specific session
     * @summary Delete session
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSession: async (
      sandboxId: string,
      sessionId: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('deleteSession', 'sandboxId', sandboxId)
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists('deleteSession', 'sessionId', sessionId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/process/session/{sessionId}`
        .replace(`{${'sandboxId'}}`, encodeURIComponent(String(sandboxId)))
        .replace(`{${'sessionId'}}`, encodeURIComponent(String(sessionId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Download file from sandbox
     * @summary Download file
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile: async (
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('downloadFile', 'sandboxId', sandboxId)
      // verify required parameter 'path' is not null or undefined
      assertParamExists('downloadFile', 'path', path)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files/download`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Drag mouse from start to end coordinates
     * @summary Drag mouse
     * @param {string} sandboxId
     * @param {MouseDragRequest} mouseDragRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dragMouse: async (
      sandboxId: string,
      mouseDragRequest: MouseDragRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('dragMouse', 'sandboxId', sandboxId)
      // verify required parameter 'mouseDragRequest' is not null or undefined
      assertParamExists('dragMouse', 'mouseDragRequest', mouseDragRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/computeruse/mouse/drag`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(mouseDragRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Execute command synchronously inside sandbox
     * @summary Execute command
     * @param {string} sandboxId
     * @param {ExecuteRequest} executeRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeCommand: async (
      sandboxId: string,
      executeRequest: ExecuteRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('executeCommand', 'sandboxId', sandboxId)
      // verify required parameter 'executeRequest' is not null or undefined
      assertParamExists('executeCommand', 'executeRequest', executeRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/process/execute`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(executeRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Execute a command in a specific session
     * @summary Execute command in session
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {SessionExecuteRequest} sessionExecuteRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeSessionCommand: async (
      sandboxId: string,
      sessionId: string,
      sessionExecuteRequest: SessionExecuteRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('executeSessionCommand', 'sandboxId', sandboxId)
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists('executeSessionCommand', 'sessionId', sessionId)
      // verify required parameter 'sessionExecuteRequest' is not null or undefined
      assertParamExists('executeSessionCommand', 'sessionExecuteRequest', sessionExecuteRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/process/session/{sessionId}/exec`
        .replace(`{${'sandboxId'}}`, encodeURIComponent(String(sandboxId)))
        .replace(`{${'sessionId'}}`, encodeURIComponent(String(sessionId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(sessionExecuteRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Search for text/pattern inside sandbox files
     * @summary Search for text/pattern in files
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} pattern
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findInFiles: async (
      sandboxId: string,
      path: string,
      pattern: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('findInFiles', 'sandboxId', sandboxId)
      // verify required parameter 'path' is not null or undefined
      assertParamExists('findInFiles', 'path', path)
      // verify required parameter 'pattern' is not null or undefined
      assertParamExists('findInFiles', 'pattern', pattern)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files/find`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (pattern !== undefined) {
        localVarQueryParameter['pattern'] = pattern
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get status of all VNC desktop processes
     * @summary Get computer use status
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getComputerUseStatus: async (
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('getComputerUseStatus', 'sandboxId', sandboxId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/computeruse/status`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get information about displays
     * @summary Get display info
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDisplayInfo: async (
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('getDisplayInfo', 'sandboxId', sandboxId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/computeruse/display/info`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get file info inside sandbox
     * @summary Get file info
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileInfo: async (
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('getFileInfo', 'sandboxId', sandboxId)
      // verify required parameter 'path' is not null or undefined
      assertParamExists('getFileInfo', 'path', path)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files/info`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get current mouse cursor position
     * @summary Get mouse position
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMousePosition: async (
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('getMousePosition', 'sandboxId', sandboxId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/computeruse/mouse/position`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get error logs for a specific VNC process
     * @summary Get process errors
     * @param {string} processName
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProcessErrors: async (
      processName: string,
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'processName' is not null or undefined
      assertParamExists('getProcessErrors', 'processName', processName)
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('getProcessErrors', 'sandboxId', sandboxId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/computeruse/process/{processName}/errors`
        .replace(`{${'processName'}}`, encodeURIComponent(String(processName)))
        .replace(`{${'sandboxId'}}`, encodeURIComponent(String(sandboxId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get logs for a specific VNC process
     * @summary Get process logs
     * @param {string} processName
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProcessLogs: async (
      processName: string,
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'processName' is not null or undefined
      assertParamExists('getProcessLogs', 'processName', processName)
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('getProcessLogs', 'sandboxId', sandboxId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/computeruse/process/{processName}/logs`
        .replace(`{${'processName'}}`, encodeURIComponent(String(processName)))
        .replace(`{${'sandboxId'}}`, encodeURIComponent(String(sandboxId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get status of a specific VNC process
     * @summary Get process status
     * @param {string} processName
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProcessStatus: async (
      processName: string,
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'processName' is not null or undefined
      assertParamExists('getProcessStatus', 'processName', processName)
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('getProcessStatus', 'sandboxId', sandboxId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/computeruse/process/{processName}/status`
        .replace(`{${'processName'}}`, encodeURIComponent(String(processName)))
        .replace(`{${'sandboxId'}}`, encodeURIComponent(String(sandboxId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get sandbox project dir
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectDir: async (
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('getProjectDir', 'sandboxId', sandboxId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/project-dir`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get session by ID
     * @summary Get session
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSession: async (
      sandboxId: string,
      sessionId: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('getSession', 'sandboxId', sandboxId)
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists('getSession', 'sessionId', sessionId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/process/session/{sessionId}`
        .replace(`{${'sandboxId'}}`, encodeURIComponent(String(sandboxId)))
        .replace(`{${'sessionId'}}`, encodeURIComponent(String(sessionId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get session command by ID
     * @summary Get session command
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} commandId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionCommand: async (
      sandboxId: string,
      sessionId: string,
      commandId: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('getSessionCommand', 'sandboxId', sandboxId)
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists('getSessionCommand', 'sessionId', sessionId)
      // verify required parameter 'commandId' is not null or undefined
      assertParamExists('getSessionCommand', 'commandId', commandId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/process/session/{sessionId}/command/{commandId}`
        .replace(`{${'sandboxId'}}`, encodeURIComponent(String(sandboxId)))
        .replace(`{${'sessionId'}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${'commandId'}}`, encodeURIComponent(String(commandId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get logs for a specific command in a session
     * @summary Get command logs
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} commandId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {boolean} [follow]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionCommandLogs: async (
      sandboxId: string,
      sessionId: string,
      commandId: string,
      xDaytonaOrganizationID?: string,
      follow?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('getSessionCommandLogs', 'sandboxId', sandboxId)
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists('getSessionCommandLogs', 'sessionId', sessionId)
      // verify required parameter 'commandId' is not null or undefined
      assertParamExists('getSessionCommandLogs', 'commandId', commandId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/process/session/{sessionId}/command/{commandId}/logs`
        .replace(`{${'sandboxId'}}`, encodeURIComponent(String(sandboxId)))
        .replace(`{${'sessionId'}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${'commandId'}}`, encodeURIComponent(String(commandId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (follow !== undefined) {
        localVarQueryParameter['follow'] = follow
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get list of open windows
     * @summary Get windows
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWindows: async (
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('getWindows', 'sandboxId', sandboxId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/computeruse/display/windows`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Add files to git commit
     * @summary Add files
     * @param {string} sandboxId
     * @param {GitAddRequest} gitAddRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitAddFiles: async (
      sandboxId: string,
      gitAddRequest: GitAddRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('gitAddFiles', 'sandboxId', sandboxId)
      // verify required parameter 'gitAddRequest' is not null or undefined
      assertParamExists('gitAddFiles', 'gitAddRequest', gitAddRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/git/add`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(gitAddRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Checkout branch or commit in git repository
     * @summary Checkout branch
     * @param {string} sandboxId
     * @param {GitCheckoutRequest} gitCheckoutRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCheckoutBranch: async (
      sandboxId: string,
      gitCheckoutRequest: GitCheckoutRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('gitCheckoutBranch', 'sandboxId', sandboxId)
      // verify required parameter 'gitCheckoutRequest' is not null or undefined
      assertParamExists('gitCheckoutBranch', 'gitCheckoutRequest', gitCheckoutRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/git/checkout`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(gitCheckoutRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Clone git repository
     * @summary Clone repository
     * @param {string} sandboxId
     * @param {GitCloneRequest} gitCloneRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCloneRepository: async (
      sandboxId: string,
      gitCloneRequest: GitCloneRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('gitCloneRepository', 'sandboxId', sandboxId)
      // verify required parameter 'gitCloneRequest' is not null or undefined
      assertParamExists('gitCloneRepository', 'gitCloneRequest', gitCloneRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/git/clone`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(gitCloneRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Commit changes to git repository
     * @summary Commit changes
     * @param {string} sandboxId
     * @param {GitCommitRequest} gitCommitRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCommitChanges: async (
      sandboxId: string,
      gitCommitRequest: GitCommitRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('gitCommitChanges', 'sandboxId', sandboxId)
      // verify required parameter 'gitCommitRequest' is not null or undefined
      assertParamExists('gitCommitChanges', 'gitCommitRequest', gitCommitRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/git/commit`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(gitCommitRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create branch on git repository
     * @summary Create branch
     * @param {string} sandboxId
     * @param {GitBranchRequest} gitBranchRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCreateBranch: async (
      sandboxId: string,
      gitBranchRequest: GitBranchRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('gitCreateBranch', 'sandboxId', sandboxId)
      // verify required parameter 'gitBranchRequest' is not null or undefined
      assertParamExists('gitCreateBranch', 'gitBranchRequest', gitBranchRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/git/branches`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(gitBranchRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete branch on git repository
     * @summary Delete branch
     * @param {string} sandboxId
     * @param {GitDeleteBranchRequest} gitDeleteBranchRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitDeleteBranch: async (
      sandboxId: string,
      gitDeleteBranchRequest: GitDeleteBranchRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('gitDeleteBranch', 'sandboxId', sandboxId)
      // verify required parameter 'gitDeleteBranchRequest' is not null or undefined
      assertParamExists('gitDeleteBranch', 'gitDeleteBranchRequest', gitDeleteBranchRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/git/branches`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(gitDeleteBranchRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get commit history from git repository
     * @summary Get commit history
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitGetHistory: async (
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('gitGetHistory', 'sandboxId', sandboxId)
      // verify required parameter 'path' is not null or undefined
      assertParamExists('gitGetHistory', 'path', path)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/git/history`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get status from git repository
     * @summary Get git status
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitGetStatus: async (
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('gitGetStatus', 'sandboxId', sandboxId)
      // verify required parameter 'path' is not null or undefined
      assertParamExists('gitGetStatus', 'path', path)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/git/status`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get branch list from git repository
     * @summary Get branch list
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitListBranches: async (
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('gitListBranches', 'sandboxId', sandboxId)
      // verify required parameter 'path' is not null or undefined
      assertParamExists('gitListBranches', 'path', path)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/git/branches`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Pull changes from remote
     * @summary Pull changes
     * @param {string} sandboxId
     * @param {GitRepoRequest} gitRepoRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitPullChanges: async (
      sandboxId: string,
      gitRepoRequest: GitRepoRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('gitPullChanges', 'sandboxId', sandboxId)
      // verify required parameter 'gitRepoRequest' is not null or undefined
      assertParamExists('gitPullChanges', 'gitRepoRequest', gitRepoRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/git/pull`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(gitRepoRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Push changes to remote
     * @summary Push changes
     * @param {string} sandboxId
     * @param {GitRepoRequest} gitRepoRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitPushChanges: async (
      sandboxId: string,
      gitRepoRequest: GitRepoRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('gitPushChanges', 'sandboxId', sandboxId)
      // verify required parameter 'gitRepoRequest' is not null or undefined
      assertParamExists('gitPushChanges', 'gitRepoRequest', gitRepoRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/git/push`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(gitRepoRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List files
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {string} [path]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFiles: async (
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      path?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('listFiles', 'sandboxId', sandboxId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List all active sessions in the sandbox
     * @summary List sessions
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSessions: async (
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('listSessions', 'sandboxId', sandboxId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/process/session`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * The Completion request is sent from the client to the server to compute completion items at a given cursor position.
     * @summary Get Lsp Completions
     * @param {string} sandboxId
     * @param {LspCompletionParams} lspCompletionParams
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspCompletions: async (
      sandboxId: string,
      lspCompletionParams: LspCompletionParams,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('lspCompletions', 'sandboxId', sandboxId)
      // verify required parameter 'lspCompletionParams' is not null or undefined
      assertParamExists('lspCompletions', 'lspCompletionParams', lspCompletionParams)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/lsp/completions`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(lspCompletionParams, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * The document close notification is sent from the client to the server when the document got closed in the client.
     * @summary Call Lsp DidClose
     * @param {string} sandboxId
     * @param {LspDocumentRequest} lspDocumentRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspDidClose: async (
      sandboxId: string,
      lspDocumentRequest: LspDocumentRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('lspDidClose', 'sandboxId', sandboxId)
      // verify required parameter 'lspDocumentRequest' is not null or undefined
      assertParamExists('lspDidClose', 'lspDocumentRequest', lspDocumentRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/lsp/did-close`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(lspDocumentRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * The document open notification is sent from the client to the server to signal newly opened text documents.
     * @summary Call Lsp DidOpen
     * @param {string} sandboxId
     * @param {LspDocumentRequest} lspDocumentRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspDidOpen: async (
      sandboxId: string,
      lspDocumentRequest: LspDocumentRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('lspDidOpen', 'sandboxId', sandboxId)
      // verify required parameter 'lspDocumentRequest' is not null or undefined
      assertParamExists('lspDidOpen', 'lspDocumentRequest', lspDocumentRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/lsp/did-open`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(lspDocumentRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * The document symbol request is sent from the client to the server.
     * @summary Call Lsp DocumentSymbols
     * @param {string} sandboxId
     * @param {string} languageId
     * @param {string} pathToProject
     * @param {string} uri
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspDocumentSymbols: async (
      sandboxId: string,
      languageId: string,
      pathToProject: string,
      uri: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('lspDocumentSymbols', 'sandboxId', sandboxId)
      // verify required parameter 'languageId' is not null or undefined
      assertParamExists('lspDocumentSymbols', 'languageId', languageId)
      // verify required parameter 'pathToProject' is not null or undefined
      assertParamExists('lspDocumentSymbols', 'pathToProject', pathToProject)
      // verify required parameter 'uri' is not null or undefined
      assertParamExists('lspDocumentSymbols', 'uri', uri)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/lsp/document-symbols`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (languageId !== undefined) {
        localVarQueryParameter['languageId'] = languageId
      }

      if (pathToProject !== undefined) {
        localVarQueryParameter['pathToProject'] = pathToProject
      }

      if (uri !== undefined) {
        localVarQueryParameter['uri'] = uri
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Start Lsp server process inside sandbox project
     * @summary Start Lsp server
     * @param {string} sandboxId
     * @param {LspServerRequest} lspServerRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspStart: async (
      sandboxId: string,
      lspServerRequest: LspServerRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('lspStart', 'sandboxId', sandboxId)
      // verify required parameter 'lspServerRequest' is not null or undefined
      assertParamExists('lspStart', 'lspServerRequest', lspServerRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/lsp/start`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(lspServerRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Stop Lsp server process inside sandbox project
     * @summary Stop Lsp server
     * @param {string} sandboxId
     * @param {LspServerRequest} lspServerRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspStop: async (
      sandboxId: string,
      lspServerRequest: LspServerRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('lspStop', 'sandboxId', sandboxId)
      // verify required parameter 'lspServerRequest' is not null or undefined
      assertParamExists('lspStop', 'lspServerRequest', lspServerRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/lsp/stop`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(lspServerRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.
     * @summary Call Lsp WorkspaceSymbols
     * @param {string} sandboxId
     * @param {string} languageId
     * @param {string} pathToProject
     * @param {string} query
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspWorkspaceSymbols: async (
      sandboxId: string,
      languageId: string,
      pathToProject: string,
      query: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('lspWorkspaceSymbols', 'sandboxId', sandboxId)
      // verify required parameter 'languageId' is not null or undefined
      assertParamExists('lspWorkspaceSymbols', 'languageId', languageId)
      // verify required parameter 'pathToProject' is not null or undefined
      assertParamExists('lspWorkspaceSymbols', 'pathToProject', pathToProject)
      // verify required parameter 'query' is not null or undefined
      assertParamExists('lspWorkspaceSymbols', 'query', query)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/lsp/workspace-symbols`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (languageId !== undefined) {
        localVarQueryParameter['languageId'] = languageId
      }

      if (pathToProject !== undefined) {
        localVarQueryParameter['pathToProject'] = pathToProject
      }

      if (query !== undefined) {
        localVarQueryParameter['query'] = query
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Move file inside sandbox
     * @summary Move file
     * @param {string} sandboxId
     * @param {string} source
     * @param {string} destination
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moveFile: async (
      sandboxId: string,
      source: string,
      destination: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('moveFile', 'sandboxId', sandboxId)
      // verify required parameter 'source' is not null or undefined
      assertParamExists('moveFile', 'source', source)
      // verify required parameter 'destination' is not null or undefined
      assertParamExists('moveFile', 'destination', destination)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files/move`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (source !== undefined) {
        localVarQueryParameter['source'] = source
      }

      if (destination !== undefined) {
        localVarQueryParameter['destination'] = destination
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Move mouse cursor to specified coordinates
     * @summary Move mouse
     * @param {string} sandboxId
     * @param {MouseMoveRequest} mouseMoveRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moveMouse: async (
      sandboxId: string,
      mouseMoveRequest: MouseMoveRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('moveMouse', 'sandboxId', sandboxId)
      // verify required parameter 'mouseMoveRequest' is not null or undefined
      assertParamExists('moveMouse', 'mouseMoveRequest', mouseMoveRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/computeruse/mouse/move`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(mouseMoveRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Press a hotkey combination
     * @summary Press hotkey
     * @param {string} sandboxId
     * @param {KeyboardHotkeyRequest} keyboardHotkeyRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pressHotkey: async (
      sandboxId: string,
      keyboardHotkeyRequest: KeyboardHotkeyRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('pressHotkey', 'sandboxId', sandboxId)
      // verify required parameter 'keyboardHotkeyRequest' is not null or undefined
      assertParamExists('pressHotkey', 'keyboardHotkeyRequest', keyboardHotkeyRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/computeruse/keyboard/hotkey`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(keyboardHotkeyRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Press a key with optional modifiers
     * @summary Press key
     * @param {string} sandboxId
     * @param {KeyboardPressRequest} keyboardPressRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pressKey: async (
      sandboxId: string,
      keyboardPressRequest: KeyboardPressRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('pressKey', 'sandboxId', sandboxId)
      // verify required parameter 'keyboardPressRequest' is not null or undefined
      assertParamExists('pressKey', 'keyboardPressRequest', keyboardPressRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/computeruse/keyboard/key`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(keyboardPressRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Replace text/pattern in multiple files inside sandbox
     * @summary Replace in files
     * @param {string} sandboxId
     * @param {ReplaceRequest} replaceRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceInFiles: async (
      sandboxId: string,
      replaceRequest: ReplaceRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('replaceInFiles', 'sandboxId', sandboxId)
      // verify required parameter 'replaceRequest' is not null or undefined
      assertParamExists('replaceInFiles', 'replaceRequest', replaceRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files/replace`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(replaceRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Restart a specific VNC process
     * @summary Restart process
     * @param {string} processName
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restartProcess: async (
      processName: string,
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'processName' is not null or undefined
      assertParamExists('restartProcess', 'processName', processName)
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('restartProcess', 'sandboxId', sandboxId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/computeruse/process/{processName}/restart`
        .replace(`{${'processName'}}`, encodeURIComponent(String(processName)))
        .replace(`{${'sandboxId'}}`, encodeURIComponent(String(sandboxId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Scroll mouse at specified coordinates
     * @summary Scroll mouse
     * @param {string} sandboxId
     * @param {MouseScrollRequest} mouseScrollRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scrollMouse: async (
      sandboxId: string,
      mouseScrollRequest: MouseScrollRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('scrollMouse', 'sandboxId', sandboxId)
      // verify required parameter 'mouseScrollRequest' is not null or undefined
      assertParamExists('scrollMouse', 'mouseScrollRequest', mouseScrollRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/computeruse/mouse/scroll`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(mouseScrollRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Search for files inside sandbox
     * @summary Search files
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} pattern
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchFiles: async (
      sandboxId: string,
      path: string,
      pattern: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('searchFiles', 'sandboxId', sandboxId)
      // verify required parameter 'path' is not null or undefined
      assertParamExists('searchFiles', 'path', path)
      // verify required parameter 'pattern' is not null or undefined
      assertParamExists('searchFiles', 'pattern', pattern)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files/search`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (pattern !== undefined) {
        localVarQueryParameter['pattern'] = pattern
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Set file owner/group/permissions inside sandbox
     * @summary Set file permissions
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {string} [owner]
     * @param {string} [group]
     * @param {string} [mode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFilePermissions: async (
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      owner?: string,
      group?: string,
      mode?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('setFilePermissions', 'sandboxId', sandboxId)
      // verify required parameter 'path' is not null or undefined
      assertParamExists('setFilePermissions', 'path', path)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files/permissions`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (owner !== undefined) {
        localVarQueryParameter['owner'] = owner
      }

      if (group !== undefined) {
        localVarQueryParameter['group'] = group
      }

      if (mode !== undefined) {
        localVarQueryParameter['mode'] = mode
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Start all VNC desktop processes (Xvfb, xfce4, x11vnc, novnc)
     * @summary Start computer use processes
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startComputerUse: async (
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('startComputerUse', 'sandboxId', sandboxId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/computeruse/start`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Stop all VNC desktop processes (Xvfb, xfce4, x11vnc, novnc)
     * @summary Stop computer use processes
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopComputerUse: async (
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('stopComputerUse', 'sandboxId', sandboxId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/computeruse/stop`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Take a compressed screenshot of a specific region
     * @summary Take compressed region screenshot
     * @param {string} sandboxId
     * @param {number} height
     * @param {number} width
     * @param {number} y
     * @param {number} x
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {number} [scale]
     * @param {number} [quality]
     * @param {string} [format]
     * @param {boolean} [showCursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    takeCompressedRegionScreenshot: async (
      sandboxId: string,
      height: number,
      width: number,
      y: number,
      x: number,
      xDaytonaOrganizationID?: string,
      scale?: number,
      quality?: number,
      format?: string,
      showCursor?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('takeCompressedRegionScreenshot', 'sandboxId', sandboxId)
      // verify required parameter 'height' is not null or undefined
      assertParamExists('takeCompressedRegionScreenshot', 'height', height)
      // verify required parameter 'width' is not null or undefined
      assertParamExists('takeCompressedRegionScreenshot', 'width', width)
      // verify required parameter 'y' is not null or undefined
      assertParamExists('takeCompressedRegionScreenshot', 'y', y)
      // verify required parameter 'x' is not null or undefined
      assertParamExists('takeCompressedRegionScreenshot', 'x', x)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/computeruse/screenshot/region/compressed`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (scale !== undefined) {
        localVarQueryParameter['scale'] = scale
      }

      if (quality !== undefined) {
        localVarQueryParameter['quality'] = quality
      }

      if (format !== undefined) {
        localVarQueryParameter['format'] = format
      }

      if (showCursor !== undefined) {
        localVarQueryParameter['show_cursor'] = showCursor
      }

      if (height !== undefined) {
        localVarQueryParameter['height'] = height
      }

      if (width !== undefined) {
        localVarQueryParameter['width'] = width
      }

      if (y !== undefined) {
        localVarQueryParameter['y'] = y
      }

      if (x !== undefined) {
        localVarQueryParameter['x'] = x
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Take a compressed screenshot with format, quality, and scale options
     * @summary Take compressed screenshot
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {number} [scale]
     * @param {number} [quality]
     * @param {string} [format]
     * @param {boolean} [showCursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    takeCompressedScreenshot: async (
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      scale?: number,
      quality?: number,
      format?: string,
      showCursor?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('takeCompressedScreenshot', 'sandboxId', sandboxId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/computeruse/screenshot/compressed`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (scale !== undefined) {
        localVarQueryParameter['scale'] = scale
      }

      if (quality !== undefined) {
        localVarQueryParameter['quality'] = quality
      }

      if (format !== undefined) {
        localVarQueryParameter['format'] = format
      }

      if (showCursor !== undefined) {
        localVarQueryParameter['show_cursor'] = showCursor
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Take a screenshot of a specific region
     * @summary Take region screenshot
     * @param {string} sandboxId
     * @param {number} height
     * @param {number} width
     * @param {number} y
     * @param {number} x
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {boolean} [showCursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    takeRegionScreenshot: async (
      sandboxId: string,
      height: number,
      width: number,
      y: number,
      x: number,
      xDaytonaOrganizationID?: string,
      showCursor?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('takeRegionScreenshot', 'sandboxId', sandboxId)
      // verify required parameter 'height' is not null or undefined
      assertParamExists('takeRegionScreenshot', 'height', height)
      // verify required parameter 'width' is not null or undefined
      assertParamExists('takeRegionScreenshot', 'width', width)
      // verify required parameter 'y' is not null or undefined
      assertParamExists('takeRegionScreenshot', 'y', y)
      // verify required parameter 'x' is not null or undefined
      assertParamExists('takeRegionScreenshot', 'x', x)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/computeruse/screenshot/region`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (showCursor !== undefined) {
        localVarQueryParameter['show_cursor'] = showCursor
      }

      if (height !== undefined) {
        localVarQueryParameter['height'] = height
      }

      if (width !== undefined) {
        localVarQueryParameter['width'] = width
      }

      if (y !== undefined) {
        localVarQueryParameter['y'] = y
      }

      if (x !== undefined) {
        localVarQueryParameter['x'] = x
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Take a screenshot of the entire screen
     * @summary Take screenshot
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {boolean} [showCursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    takeScreenshot: async (
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      showCursor?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('takeScreenshot', 'sandboxId', sandboxId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/computeruse/screenshot`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (showCursor !== undefined) {
        localVarQueryParameter['show_cursor'] = showCursor
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Type text using keyboard
     * @summary Type text
     * @param {string} sandboxId
     * @param {KeyboardTypeRequest} keyboardTypeRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    typeText: async (
      sandboxId: string,
      keyboardTypeRequest: KeyboardTypeRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('typeText', 'sandboxId', sandboxId)
      // verify required parameter 'keyboardTypeRequest' is not null or undefined
      assertParamExists('typeText', 'keyboardTypeRequest', keyboardTypeRequest)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/computeruse/keyboard/type`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(keyboardTypeRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Upload file inside sandbox
     * @summary Upload file
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {File} [file]
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    uploadFile: async (
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      file?: File,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('uploadFile', 'sandboxId', sandboxId)
      // verify required parameter 'path' is not null or undefined
      assertParamExists('uploadFile', 'path', path)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files/upload`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)()

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (file !== undefined) {
        localVarFormParams.append('file', file as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Upload multiple files inside sandbox
     * @summary Upload multiple files
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFiles: async (
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sandboxId' is not null or undefined
      assertParamExists('uploadFiles', 'sandboxId', sandboxId)
      const localVarPath = `/toolbox/{sandboxId}/toolbox/files/bulk-upload`.replace(
        `{${'sandboxId'}}`,
        encodeURIComponent(String(sandboxId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ToolboxApi - functional programming interface
 * @export
 */
export const ToolboxApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ToolboxApiAxiosParamCreator(configuration)
  return {
    /**
     * Click mouse at specified coordinates
     * @summary Click mouse
     * @param {string} sandboxId
     * @param {MouseClickRequest} mouseClickRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async clickMouse(
      sandboxId: string,
      mouseClickRequest: MouseClickRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MouseClickResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.clickMouse(
        sandboxId,
        mouseClickRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.clickMouse']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Create folder inside sandbox
     * @summary Create folder
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} mode
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFolder(
      sandboxId: string,
      path: string,
      mode: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createFolder(
        sandboxId,
        path,
        mode,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.createFolder']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Create a new session in the sandbox
     * @summary Create session
     * @param {string} sandboxId
     * @param {CreateSessionRequest} createSessionRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSession(
      sandboxId: string,
      createSessionRequest: CreateSessionRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createSession(
        sandboxId,
        createSessionRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.createSession']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Delete file inside sandbox
     * @summary Delete file
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFile(
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(
        sandboxId,
        path,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.deleteFile']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Delete a specific session
     * @summary Delete session
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSession(
      sandboxId: string,
      sessionId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSession(
        sandboxId,
        sessionId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.deleteSession']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Download file from sandbox
     * @summary Download file
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadFile(
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(
        sandboxId,
        path,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.downloadFile']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Drag mouse from start to end coordinates
     * @summary Drag mouse
     * @param {string} sandboxId
     * @param {MouseDragRequest} mouseDragRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async dragMouse(
      sandboxId: string,
      mouseDragRequest: MouseDragRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MouseDragResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.dragMouse(
        sandboxId,
        mouseDragRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.dragMouse']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Execute command synchronously inside sandbox
     * @summary Execute command
     * @param {string} sandboxId
     * @param {ExecuteRequest} executeRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async executeCommand(
      sandboxId: string,
      executeRequest: ExecuteRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.executeCommand(
        sandboxId,
        executeRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.executeCommand']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Execute a command in a specific session
     * @summary Execute command in session
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {SessionExecuteRequest} sessionExecuteRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async executeSessionCommand(
      sandboxId: string,
      sessionId: string,
      sessionExecuteRequest: SessionExecuteRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionExecuteResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.executeSessionCommand(
        sandboxId,
        sessionId,
        sessionExecuteRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.executeSessionCommand']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Search for text/pattern inside sandbox files
     * @summary Search for text/pattern in files
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} pattern
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findInFiles(
      sandboxId: string,
      path: string,
      pattern: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Match>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findInFiles(
        sandboxId,
        path,
        pattern,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.findInFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get status of all VNC desktop processes
     * @summary Get computer use status
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getComputerUseStatus(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ComputerUseStatusResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getComputerUseStatus(
        sandboxId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.getComputerUseStatus']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get information about displays
     * @summary Get display info
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDisplayInfo(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisplayInfoResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDisplayInfo(
        sandboxId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.getDisplayInfo']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get file info inside sandbox
     * @summary Get file info
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFileInfo(
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFileInfo(
        sandboxId,
        path,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.getFileInfo']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get current mouse cursor position
     * @summary Get mouse position
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMousePosition(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MousePosition>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMousePosition(
        sandboxId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.getMousePosition']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get error logs for a specific VNC process
     * @summary Get process errors
     * @param {string} processName
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProcessErrors(
      processName: string,
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessErrorsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessErrors(
        processName,
        sandboxId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.getProcessErrors']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get logs for a specific VNC process
     * @summary Get process logs
     * @param {string} processName
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProcessLogs(
      processName: string,
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessLogsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessLogs(
        processName,
        sandboxId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.getProcessLogs']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get status of a specific VNC process
     * @summary Get process status
     * @param {string} processName
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProcessStatus(
      processName: string,
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessStatusResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessStatus(
        processName,
        sandboxId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.getProcessStatus']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Get sandbox project dir
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProjectDir(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDirResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectDir(
        sandboxId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.getProjectDir']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get session by ID
     * @summary Get session
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSession(
      sandboxId: string,
      sessionId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSession(
        sandboxId,
        sessionId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.getSession']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get session command by ID
     * @summary Get session command
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} commandId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSessionCommand(
      sandboxId: string,
      sessionId: string,
      commandId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Command>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionCommand(
        sandboxId,
        sessionId,
        commandId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.getSessionCommand']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get logs for a specific command in a session
     * @summary Get command logs
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} commandId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {boolean} [follow]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSessionCommandLogs(
      sandboxId: string,
      sessionId: string,
      commandId: string,
      xDaytonaOrganizationID?: string,
      follow?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionCommandLogs(
        sandboxId,
        sessionId,
        commandId,
        xDaytonaOrganizationID,
        follow,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.getSessionCommandLogs']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get list of open windows
     * @summary Get windows
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWindows(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WindowsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getWindows(sandboxId, xDaytonaOrganizationID, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.getWindows']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Add files to git commit
     * @summary Add files
     * @param {string} sandboxId
     * @param {GitAddRequest} gitAddRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitAddFiles(
      sandboxId: string,
      gitAddRequest: GitAddRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitAddFiles(
        sandboxId,
        gitAddRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.gitAddFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Checkout branch or commit in git repository
     * @summary Checkout branch
     * @param {string} sandboxId
     * @param {GitCheckoutRequest} gitCheckoutRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitCheckoutBranch(
      sandboxId: string,
      gitCheckoutRequest: GitCheckoutRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitCheckoutBranch(
        sandboxId,
        gitCheckoutRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.gitCheckoutBranch']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Clone git repository
     * @summary Clone repository
     * @param {string} sandboxId
     * @param {GitCloneRequest} gitCloneRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitCloneRepository(
      sandboxId: string,
      gitCloneRequest: GitCloneRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitCloneRepository(
        sandboxId,
        gitCloneRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.gitCloneRepository']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Commit changes to git repository
     * @summary Commit changes
     * @param {string} sandboxId
     * @param {GitCommitRequest} gitCommitRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitCommitChanges(
      sandboxId: string,
      gitCommitRequest: GitCommitRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitCommitResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitCommitChanges(
        sandboxId,
        gitCommitRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.gitCommitChanges']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Create branch on git repository
     * @summary Create branch
     * @param {string} sandboxId
     * @param {GitBranchRequest} gitBranchRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitCreateBranch(
      sandboxId: string,
      gitBranchRequest: GitBranchRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitCreateBranch(
        sandboxId,
        gitBranchRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.gitCreateBranch']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Delete branch on git repository
     * @summary Delete branch
     * @param {string} sandboxId
     * @param {GitDeleteBranchRequest} gitDeleteBranchRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitDeleteBranch(
      sandboxId: string,
      gitDeleteBranchRequest: GitDeleteBranchRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitDeleteBranch(
        sandboxId,
        gitDeleteBranchRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.gitDeleteBranch']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get commit history from git repository
     * @summary Get commit history
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitGetHistory(
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GitCommitInfo>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitGetHistory(
        sandboxId,
        path,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.gitGetHistory']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get status from git repository
     * @summary Get git status
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitGetStatus(
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitStatus>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitGetStatus(
        sandboxId,
        path,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.gitGetStatus']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get branch list from git repository
     * @summary Get branch list
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitListBranches(
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBranchResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitListBranches(
        sandboxId,
        path,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.gitListBranches']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Pull changes from remote
     * @summary Pull changes
     * @param {string} sandboxId
     * @param {GitRepoRequest} gitRepoRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitPullChanges(
      sandboxId: string,
      gitRepoRequest: GitRepoRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitPullChanges(
        sandboxId,
        gitRepoRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.gitPullChanges']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Push changes to remote
     * @summary Push changes
     * @param {string} sandboxId
     * @param {GitRepoRequest} gitRepoRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitPushChanges(
      sandboxId: string,
      gitRepoRequest: GitRepoRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitPushChanges(
        sandboxId,
        gitRepoRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.gitPushChanges']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary List files
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {string} [path]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listFiles(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      path?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileInfo>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listFiles(
        sandboxId,
        xDaytonaOrganizationID,
        path,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.listFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * List all active sessions in the sandbox
     * @summary List sessions
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listSessions(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Session>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listSessions(sandboxId, xDaytonaOrganizationID, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.listSessions']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * The Completion request is sent from the client to the server to compute completion items at a given cursor position.
     * @summary Get Lsp Completions
     * @param {string} sandboxId
     * @param {LspCompletionParams} lspCompletionParams
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lspCompletions(
      sandboxId: string,
      lspCompletionParams: LspCompletionParams,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompletionList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lspCompletions(
        sandboxId,
        lspCompletionParams,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.lspCompletions']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * The document close notification is sent from the client to the server when the document got closed in the client.
     * @summary Call Lsp DidClose
     * @param {string} sandboxId
     * @param {LspDocumentRequest} lspDocumentRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lspDidClose(
      sandboxId: string,
      lspDocumentRequest: LspDocumentRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lspDidClose(
        sandboxId,
        lspDocumentRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.lspDidClose']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * The document open notification is sent from the client to the server to signal newly opened text documents.
     * @summary Call Lsp DidOpen
     * @param {string} sandboxId
     * @param {LspDocumentRequest} lspDocumentRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lspDidOpen(
      sandboxId: string,
      lspDocumentRequest: LspDocumentRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lspDidOpen(
        sandboxId,
        lspDocumentRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.lspDidOpen']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * The document symbol request is sent from the client to the server.
     * @summary Call Lsp DocumentSymbols
     * @param {string} sandboxId
     * @param {string} languageId
     * @param {string} pathToProject
     * @param {string} uri
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lspDocumentSymbols(
      sandboxId: string,
      languageId: string,
      pathToProject: string,
      uri: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LspSymbol>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lspDocumentSymbols(
        sandboxId,
        languageId,
        pathToProject,
        uri,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.lspDocumentSymbols']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Start Lsp server process inside sandbox project
     * @summary Start Lsp server
     * @param {string} sandboxId
     * @param {LspServerRequest} lspServerRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lspStart(
      sandboxId: string,
      lspServerRequest: LspServerRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lspStart(
        sandboxId,
        lspServerRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.lspStart']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Stop Lsp server process inside sandbox project
     * @summary Stop Lsp server
     * @param {string} sandboxId
     * @param {LspServerRequest} lspServerRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lspStop(
      sandboxId: string,
      lspServerRequest: LspServerRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lspStop(
        sandboxId,
        lspServerRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.lspStop']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.
     * @summary Call Lsp WorkspaceSymbols
     * @param {string} sandboxId
     * @param {string} languageId
     * @param {string} pathToProject
     * @param {string} query
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lspWorkspaceSymbols(
      sandboxId: string,
      languageId: string,
      pathToProject: string,
      query: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LspSymbol>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lspWorkspaceSymbols(
        sandboxId,
        languageId,
        pathToProject,
        query,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.lspWorkspaceSymbols']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Move file inside sandbox
     * @summary Move file
     * @param {string} sandboxId
     * @param {string} source
     * @param {string} destination
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async moveFile(
      sandboxId: string,
      source: string,
      destination: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.moveFile(
        sandboxId,
        source,
        destination,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.moveFile']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Move mouse cursor to specified coordinates
     * @summary Move mouse
     * @param {string} sandboxId
     * @param {MouseMoveRequest} mouseMoveRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async moveMouse(
      sandboxId: string,
      mouseMoveRequest: MouseMoveRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MouseMoveResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.moveMouse(
        sandboxId,
        mouseMoveRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.moveMouse']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Press a hotkey combination
     * @summary Press hotkey
     * @param {string} sandboxId
     * @param {KeyboardHotkeyRequest} keyboardHotkeyRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pressHotkey(
      sandboxId: string,
      keyboardHotkeyRequest: KeyboardHotkeyRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pressHotkey(
        sandboxId,
        keyboardHotkeyRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.pressHotkey']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Press a key with optional modifiers
     * @summary Press key
     * @param {string} sandboxId
     * @param {KeyboardPressRequest} keyboardPressRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pressKey(
      sandboxId: string,
      keyboardPressRequest: KeyboardPressRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pressKey(
        sandboxId,
        keyboardPressRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.pressKey']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Replace text/pattern in multiple files inside sandbox
     * @summary Replace in files
     * @param {string} sandboxId
     * @param {ReplaceRequest} replaceRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async replaceInFiles(
      sandboxId: string,
      replaceRequest: ReplaceRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReplaceResult>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.replaceInFiles(
        sandboxId,
        replaceRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.replaceInFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Restart a specific VNC process
     * @summary Restart process
     * @param {string} processName
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async restartProcess(
      processName: string,
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessRestartResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.restartProcess(
        processName,
        sandboxId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.restartProcess']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Scroll mouse at specified coordinates
     * @summary Scroll mouse
     * @param {string} sandboxId
     * @param {MouseScrollRequest} mouseScrollRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scrollMouse(
      sandboxId: string,
      mouseScrollRequest: MouseScrollRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MouseScrollResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scrollMouse(
        sandboxId,
        mouseScrollRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.scrollMouse']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Search for files inside sandbox
     * @summary Search files
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} pattern
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchFiles(
      sandboxId: string,
      path: string,
      pattern: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchFilesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchFiles(
        sandboxId,
        path,
        pattern,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.searchFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Set file owner/group/permissions inside sandbox
     * @summary Set file permissions
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {string} [owner]
     * @param {string} [group]
     * @param {string} [mode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setFilePermissions(
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      owner?: string,
      group?: string,
      mode?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setFilePermissions(
        sandboxId,
        path,
        xDaytonaOrganizationID,
        owner,
        group,
        mode,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.setFilePermissions']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Start all VNC desktop processes (Xvfb, xfce4, x11vnc, novnc)
     * @summary Start computer use processes
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async startComputerUse(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ComputerUseStartResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.startComputerUse(
        sandboxId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.startComputerUse']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Stop all VNC desktop processes (Xvfb, xfce4, x11vnc, novnc)
     * @summary Stop computer use processes
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async stopComputerUse(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ComputerUseStopResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.stopComputerUse(
        sandboxId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.stopComputerUse']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Take a compressed screenshot of a specific region
     * @summary Take compressed region screenshot
     * @param {string} sandboxId
     * @param {number} height
     * @param {number} width
     * @param {number} y
     * @param {number} x
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {number} [scale]
     * @param {number} [quality]
     * @param {string} [format]
     * @param {boolean} [showCursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async takeCompressedRegionScreenshot(
      sandboxId: string,
      height: number,
      width: number,
      y: number,
      x: number,
      xDaytonaOrganizationID?: string,
      scale?: number,
      quality?: number,
      format?: string,
      showCursor?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompressedScreenshotResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.takeCompressedRegionScreenshot(
        sandboxId,
        height,
        width,
        y,
        x,
        xDaytonaOrganizationID,
        scale,
        quality,
        format,
        showCursor,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.takeCompressedRegionScreenshot']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Take a compressed screenshot with format, quality, and scale options
     * @summary Take compressed screenshot
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {number} [scale]
     * @param {number} [quality]
     * @param {string} [format]
     * @param {boolean} [showCursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async takeCompressedScreenshot(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      scale?: number,
      quality?: number,
      format?: string,
      showCursor?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompressedScreenshotResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.takeCompressedScreenshot(
        sandboxId,
        xDaytonaOrganizationID,
        scale,
        quality,
        format,
        showCursor,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.takeCompressedScreenshot']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Take a screenshot of a specific region
     * @summary Take region screenshot
     * @param {string} sandboxId
     * @param {number} height
     * @param {number} width
     * @param {number} y
     * @param {number} x
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {boolean} [showCursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async takeRegionScreenshot(
      sandboxId: string,
      height: number,
      width: number,
      y: number,
      x: number,
      xDaytonaOrganizationID?: string,
      showCursor?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionScreenshotResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.takeRegionScreenshot(
        sandboxId,
        height,
        width,
        y,
        x,
        xDaytonaOrganizationID,
        showCursor,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.takeRegionScreenshot']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Take a screenshot of the entire screen
     * @summary Take screenshot
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {boolean} [showCursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async takeScreenshot(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      showCursor?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScreenshotResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.takeScreenshot(
        sandboxId,
        xDaytonaOrganizationID,
        showCursor,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.takeScreenshot']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Type text using keyboard
     * @summary Type text
     * @param {string} sandboxId
     * @param {KeyboardTypeRequest} keyboardTypeRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async typeText(
      sandboxId: string,
      keyboardTypeRequest: KeyboardTypeRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.typeText(
        sandboxId,
        keyboardTypeRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.typeText']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Upload file inside sandbox
     * @summary Upload file
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {File} [file]
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async uploadFile(
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      file?: File,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(
        sandboxId,
        path,
        xDaytonaOrganizationID,
        file,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.uploadFile']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Upload multiple files inside sandbox
     * @summary Upload multiple files
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadFiles(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFiles(sandboxId, xDaytonaOrganizationID, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.uploadFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ToolboxApi - factory interface
 * @export
 */
export const ToolboxApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ToolboxApiFp(configuration)
  return {
    /**
     * Click mouse at specified coordinates
     * @summary Click mouse
     * @param {string} sandboxId
     * @param {MouseClickRequest} mouseClickRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clickMouse(
      sandboxId: string,
      mouseClickRequest: MouseClickRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<MouseClickResponse> {
      return localVarFp
        .clickMouse(sandboxId, mouseClickRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Create folder inside sandbox
     * @summary Create folder
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} mode
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFolder(
      sandboxId: string,
      path: string,
      mode: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .createFolder(sandboxId, path, mode, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Create a new session in the sandbox
     * @summary Create session
     * @param {string} sandboxId
     * @param {CreateSessionRequest} createSessionRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSession(
      sandboxId: string,
      createSessionRequest: CreateSessionRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .createSession(sandboxId, createSessionRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete file inside sandbox
     * @summary Delete file
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteFile(sandboxId, path, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete a specific session
     * @summary Delete session
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSession(
      sandboxId: string,
      sessionId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteSession(sandboxId, sessionId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Download file from sandbox
     * @summary Download file
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile(
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<File> {
      return localVarFp
        .downloadFile(sandboxId, path, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Drag mouse from start to end coordinates
     * @summary Drag mouse
     * @param {string} sandboxId
     * @param {MouseDragRequest} mouseDragRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dragMouse(
      sandboxId: string,
      mouseDragRequest: MouseDragRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<MouseDragResponse> {
      return localVarFp
        .dragMouse(sandboxId, mouseDragRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Execute command synchronously inside sandbox
     * @summary Execute command
     * @param {string} sandboxId
     * @param {ExecuteRequest} executeRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeCommand(
      sandboxId: string,
      executeRequest: ExecuteRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ExecuteResponse> {
      return localVarFp
        .executeCommand(sandboxId, executeRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Execute a command in a specific session
     * @summary Execute command in session
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {SessionExecuteRequest} sessionExecuteRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeSessionCommand(
      sandboxId: string,
      sessionId: string,
      sessionExecuteRequest: SessionExecuteRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SessionExecuteResponse> {
      return localVarFp
        .executeSessionCommand(sandboxId, sessionId, sessionExecuteRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Search for text/pattern inside sandbox files
     * @summary Search for text/pattern in files
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} pattern
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findInFiles(
      sandboxId: string,
      path: string,
      pattern: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<Match>> {
      return localVarFp
        .findInFiles(sandboxId, path, pattern, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get status of all VNC desktop processes
     * @summary Get computer use status
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getComputerUseStatus(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ComputerUseStatusResponse> {
      return localVarFp
        .getComputerUseStatus(sandboxId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get information about displays
     * @summary Get display info
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDisplayInfo(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DisplayInfoResponse> {
      return localVarFp
        .getDisplayInfo(sandboxId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get file info inside sandbox
     * @summary Get file info
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileInfo(
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<FileInfo> {
      return localVarFp
        .getFileInfo(sandboxId, path, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get current mouse cursor position
     * @summary Get mouse position
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMousePosition(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<MousePosition> {
      return localVarFp
        .getMousePosition(sandboxId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get error logs for a specific VNC process
     * @summary Get process errors
     * @param {string} processName
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProcessErrors(
      processName: string,
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProcessErrorsResponse> {
      return localVarFp
        .getProcessErrors(processName, sandboxId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get logs for a specific VNC process
     * @summary Get process logs
     * @param {string} processName
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProcessLogs(
      processName: string,
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProcessLogsResponse> {
      return localVarFp
        .getProcessLogs(processName, sandboxId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get status of a specific VNC process
     * @summary Get process status
     * @param {string} processName
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProcessStatus(
      processName: string,
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProcessStatusResponse> {
      return localVarFp
        .getProcessStatus(processName, sandboxId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get sandbox project dir
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectDir(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProjectDirResponse> {
      return localVarFp
        .getProjectDir(sandboxId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get session by ID
     * @summary Get session
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSession(
      sandboxId: string,
      sessionId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Session> {
      return localVarFp
        .getSession(sandboxId, sessionId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get session command by ID
     * @summary Get session command
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} commandId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionCommand(
      sandboxId: string,
      sessionId: string,
      commandId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Command> {
      return localVarFp
        .getSessionCommand(sandboxId, sessionId, commandId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get logs for a specific command in a session
     * @summary Get command logs
     * @param {string} sandboxId
     * @param {string} sessionId
     * @param {string} commandId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {boolean} [follow]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionCommandLogs(
      sandboxId: string,
      sessionId: string,
      commandId: string,
      xDaytonaOrganizationID?: string,
      follow?: boolean,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<string> {
      return localVarFp
        .getSessionCommandLogs(sandboxId, sessionId, commandId, xDaytonaOrganizationID, follow, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get list of open windows
     * @summary Get windows
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWindows(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<WindowsResponse> {
      return localVarFp
        .getWindows(sandboxId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Add files to git commit
     * @summary Add files
     * @param {string} sandboxId
     * @param {GitAddRequest} gitAddRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitAddFiles(
      sandboxId: string,
      gitAddRequest: GitAddRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .gitAddFiles(sandboxId, gitAddRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Checkout branch or commit in git repository
     * @summary Checkout branch
     * @param {string} sandboxId
     * @param {GitCheckoutRequest} gitCheckoutRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCheckoutBranch(
      sandboxId: string,
      gitCheckoutRequest: GitCheckoutRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .gitCheckoutBranch(sandboxId, gitCheckoutRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Clone git repository
     * @summary Clone repository
     * @param {string} sandboxId
     * @param {GitCloneRequest} gitCloneRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCloneRepository(
      sandboxId: string,
      gitCloneRequest: GitCloneRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .gitCloneRepository(sandboxId, gitCloneRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Commit changes to git repository
     * @summary Commit changes
     * @param {string} sandboxId
     * @param {GitCommitRequest} gitCommitRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCommitChanges(
      sandboxId: string,
      gitCommitRequest: GitCommitRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GitCommitResponse> {
      return localVarFp
        .gitCommitChanges(sandboxId, gitCommitRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Create branch on git repository
     * @summary Create branch
     * @param {string} sandboxId
     * @param {GitBranchRequest} gitBranchRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCreateBranch(
      sandboxId: string,
      gitBranchRequest: GitBranchRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .gitCreateBranch(sandboxId, gitBranchRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete branch on git repository
     * @summary Delete branch
     * @param {string} sandboxId
     * @param {GitDeleteBranchRequest} gitDeleteBranchRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitDeleteBranch(
      sandboxId: string,
      gitDeleteBranchRequest: GitDeleteBranchRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .gitDeleteBranch(sandboxId, gitDeleteBranchRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get commit history from git repository
     * @summary Get commit history
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitGetHistory(
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<GitCommitInfo>> {
      return localVarFp
        .gitGetHistory(sandboxId, path, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get status from git repository
     * @summary Get git status
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitGetStatus(
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GitStatus> {
      return localVarFp
        .gitGetStatus(sandboxId, path, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get branch list from git repository
     * @summary Get branch list
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitListBranches(
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ListBranchResponse> {
      return localVarFp
        .gitListBranches(sandboxId, path, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Pull changes from remote
     * @summary Pull changes
     * @param {string} sandboxId
     * @param {GitRepoRequest} gitRepoRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitPullChanges(
      sandboxId: string,
      gitRepoRequest: GitRepoRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .gitPullChanges(sandboxId, gitRepoRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Push changes to remote
     * @summary Push changes
     * @param {string} sandboxId
     * @param {GitRepoRequest} gitRepoRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitPushChanges(
      sandboxId: string,
      gitRepoRequest: GitRepoRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .gitPushChanges(sandboxId, gitRepoRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List files
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {string} [path]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFiles(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      path?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<FileInfo>> {
      return localVarFp
        .listFiles(sandboxId, xDaytonaOrganizationID, path, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List all active sessions in the sandbox
     * @summary List sessions
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSessions(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<Session>> {
      return localVarFp
        .listSessions(sandboxId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * The Completion request is sent from the client to the server to compute completion items at a given cursor position.
     * @summary Get Lsp Completions
     * @param {string} sandboxId
     * @param {LspCompletionParams} lspCompletionParams
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspCompletions(
      sandboxId: string,
      lspCompletionParams: LspCompletionParams,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CompletionList> {
      return localVarFp
        .lspCompletions(sandboxId, lspCompletionParams, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * The document close notification is sent from the client to the server when the document got closed in the client.
     * @summary Call Lsp DidClose
     * @param {string} sandboxId
     * @param {LspDocumentRequest} lspDocumentRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspDidClose(
      sandboxId: string,
      lspDocumentRequest: LspDocumentRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .lspDidClose(sandboxId, lspDocumentRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * The document open notification is sent from the client to the server to signal newly opened text documents.
     * @summary Call Lsp DidOpen
     * @param {string} sandboxId
     * @param {LspDocumentRequest} lspDocumentRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspDidOpen(
      sandboxId: string,
      lspDocumentRequest: LspDocumentRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .lspDidOpen(sandboxId, lspDocumentRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * The document symbol request is sent from the client to the server.
     * @summary Call Lsp DocumentSymbols
     * @param {string} sandboxId
     * @param {string} languageId
     * @param {string} pathToProject
     * @param {string} uri
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspDocumentSymbols(
      sandboxId: string,
      languageId: string,
      pathToProject: string,
      uri: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<LspSymbol>> {
      return localVarFp
        .lspDocumentSymbols(sandboxId, languageId, pathToProject, uri, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Start Lsp server process inside sandbox project
     * @summary Start Lsp server
     * @param {string} sandboxId
     * @param {LspServerRequest} lspServerRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspStart(
      sandboxId: string,
      lspServerRequest: LspServerRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .lspStart(sandboxId, lspServerRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Stop Lsp server process inside sandbox project
     * @summary Stop Lsp server
     * @param {string} sandboxId
     * @param {LspServerRequest} lspServerRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspStop(
      sandboxId: string,
      lspServerRequest: LspServerRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .lspStop(sandboxId, lspServerRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.
     * @summary Call Lsp WorkspaceSymbols
     * @param {string} sandboxId
     * @param {string} languageId
     * @param {string} pathToProject
     * @param {string} query
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspWorkspaceSymbols(
      sandboxId: string,
      languageId: string,
      pathToProject: string,
      query: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<LspSymbol>> {
      return localVarFp
        .lspWorkspaceSymbols(sandboxId, languageId, pathToProject, query, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Move file inside sandbox
     * @summary Move file
     * @param {string} sandboxId
     * @param {string} source
     * @param {string} destination
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moveFile(
      sandboxId: string,
      source: string,
      destination: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .moveFile(sandboxId, source, destination, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Move mouse cursor to specified coordinates
     * @summary Move mouse
     * @param {string} sandboxId
     * @param {MouseMoveRequest} mouseMoveRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moveMouse(
      sandboxId: string,
      mouseMoveRequest: MouseMoveRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<MouseMoveResponse> {
      return localVarFp
        .moveMouse(sandboxId, mouseMoveRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Press a hotkey combination
     * @summary Press hotkey
     * @param {string} sandboxId
     * @param {KeyboardHotkeyRequest} keyboardHotkeyRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pressHotkey(
      sandboxId: string,
      keyboardHotkeyRequest: KeyboardHotkeyRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .pressHotkey(sandboxId, keyboardHotkeyRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Press a key with optional modifiers
     * @summary Press key
     * @param {string} sandboxId
     * @param {KeyboardPressRequest} keyboardPressRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pressKey(
      sandboxId: string,
      keyboardPressRequest: KeyboardPressRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .pressKey(sandboxId, keyboardPressRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Replace text/pattern in multiple files inside sandbox
     * @summary Replace in files
     * @param {string} sandboxId
     * @param {ReplaceRequest} replaceRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceInFiles(
      sandboxId: string,
      replaceRequest: ReplaceRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ReplaceResult>> {
      return localVarFp
        .replaceInFiles(sandboxId, replaceRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Restart a specific VNC process
     * @summary Restart process
     * @param {string} processName
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restartProcess(
      processName: string,
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProcessRestartResponse> {
      return localVarFp
        .restartProcess(processName, sandboxId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Scroll mouse at specified coordinates
     * @summary Scroll mouse
     * @param {string} sandboxId
     * @param {MouseScrollRequest} mouseScrollRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scrollMouse(
      sandboxId: string,
      mouseScrollRequest: MouseScrollRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<MouseScrollResponse> {
      return localVarFp
        .scrollMouse(sandboxId, mouseScrollRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Search for files inside sandbox
     * @summary Search files
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} pattern
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchFiles(
      sandboxId: string,
      path: string,
      pattern: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SearchFilesResponse> {
      return localVarFp
        .searchFiles(sandboxId, path, pattern, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Set file owner/group/permissions inside sandbox
     * @summary Set file permissions
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {string} [owner]
     * @param {string} [group]
     * @param {string} [mode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFilePermissions(
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      owner?: string,
      group?: string,
      mode?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .setFilePermissions(sandboxId, path, xDaytonaOrganizationID, owner, group, mode, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Start all VNC desktop processes (Xvfb, xfce4, x11vnc, novnc)
     * @summary Start computer use processes
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startComputerUse(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ComputerUseStartResponse> {
      return localVarFp
        .startComputerUse(sandboxId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Stop all VNC desktop processes (Xvfb, xfce4, x11vnc, novnc)
     * @summary Stop computer use processes
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopComputerUse(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ComputerUseStopResponse> {
      return localVarFp
        .stopComputerUse(sandboxId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Take a compressed screenshot of a specific region
     * @summary Take compressed region screenshot
     * @param {string} sandboxId
     * @param {number} height
     * @param {number} width
     * @param {number} y
     * @param {number} x
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {number} [scale]
     * @param {number} [quality]
     * @param {string} [format]
     * @param {boolean} [showCursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    takeCompressedRegionScreenshot(
      sandboxId: string,
      height: number,
      width: number,
      y: number,
      x: number,
      xDaytonaOrganizationID?: string,
      scale?: number,
      quality?: number,
      format?: string,
      showCursor?: boolean,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CompressedScreenshotResponse> {
      return localVarFp
        .takeCompressedRegionScreenshot(
          sandboxId,
          height,
          width,
          y,
          x,
          xDaytonaOrganizationID,
          scale,
          quality,
          format,
          showCursor,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Take a compressed screenshot with format, quality, and scale options
     * @summary Take compressed screenshot
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {number} [scale]
     * @param {number} [quality]
     * @param {string} [format]
     * @param {boolean} [showCursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    takeCompressedScreenshot(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      scale?: number,
      quality?: number,
      format?: string,
      showCursor?: boolean,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CompressedScreenshotResponse> {
      return localVarFp
        .takeCompressedScreenshot(sandboxId, xDaytonaOrganizationID, scale, quality, format, showCursor, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Take a screenshot of a specific region
     * @summary Take region screenshot
     * @param {string} sandboxId
     * @param {number} height
     * @param {number} width
     * @param {number} y
     * @param {number} x
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {boolean} [showCursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    takeRegionScreenshot(
      sandboxId: string,
      height: number,
      width: number,
      y: number,
      x: number,
      xDaytonaOrganizationID?: string,
      showCursor?: boolean,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<RegionScreenshotResponse> {
      return localVarFp
        .takeRegionScreenshot(sandboxId, height, width, y, x, xDaytonaOrganizationID, showCursor, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Take a screenshot of the entire screen
     * @summary Take screenshot
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {boolean} [showCursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    takeScreenshot(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      showCursor?: boolean,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ScreenshotResponse> {
      return localVarFp
        .takeScreenshot(sandboxId, xDaytonaOrganizationID, showCursor, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Type text using keyboard
     * @summary Type text
     * @param {string} sandboxId
     * @param {KeyboardTypeRequest} keyboardTypeRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    typeText(
      sandboxId: string,
      keyboardTypeRequest: KeyboardTypeRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .typeText(sandboxId, keyboardTypeRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Upload file inside sandbox
     * @summary Upload file
     * @param {string} sandboxId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {File} [file]
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    uploadFile(
      sandboxId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      file?: File,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .uploadFile(sandboxId, path, xDaytonaOrganizationID, file, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Upload multiple files inside sandbox
     * @summary Upload multiple files
     * @param {string} sandboxId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFiles(
      sandboxId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .uploadFiles(sandboxId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ToolboxApi - object-oriented interface
 * @export
 * @class ToolboxApi
 * @extends {BaseAPI}
 */
export class ToolboxApi extends BaseAPI {
  /**
   * Click mouse at specified coordinates
   * @summary Click mouse
   * @param {string} sandboxId
   * @param {MouseClickRequest} mouseClickRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public clickMouse(
    sandboxId: string,
    mouseClickRequest: MouseClickRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .clickMouse(sandboxId, mouseClickRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Create folder inside sandbox
   * @summary Create folder
   * @param {string} sandboxId
   * @param {string} path
   * @param {string} mode
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public createFolder(
    sandboxId: string,
    path: string,
    mode: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .createFolder(sandboxId, path, mode, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Create a new session in the sandbox
   * @summary Create session
   * @param {string} sandboxId
   * @param {CreateSessionRequest} createSessionRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public createSession(
    sandboxId: string,
    createSessionRequest: CreateSessionRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .createSession(sandboxId, createSessionRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete file inside sandbox
   * @summary Delete file
   * @param {string} sandboxId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public deleteFile(sandboxId: string, path: string, xDaytonaOrganizationID?: string, options?: RawAxiosRequestConfig) {
    return ToolboxApiFp(this.configuration)
      .deleteFile(sandboxId, path, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete a specific session
   * @summary Delete session
   * @param {string} sandboxId
   * @param {string} sessionId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public deleteSession(
    sandboxId: string,
    sessionId: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .deleteSession(sandboxId, sessionId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Download file from sandbox
   * @summary Download file
   * @param {string} sandboxId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public downloadFile(
    sandboxId: string,
    path: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .downloadFile(sandboxId, path, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Drag mouse from start to end coordinates
   * @summary Drag mouse
   * @param {string} sandboxId
   * @param {MouseDragRequest} mouseDragRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public dragMouse(
    sandboxId: string,
    mouseDragRequest: MouseDragRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .dragMouse(sandboxId, mouseDragRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Execute command synchronously inside sandbox
   * @summary Execute command
   * @param {string} sandboxId
   * @param {ExecuteRequest} executeRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public executeCommand(
    sandboxId: string,
    executeRequest: ExecuteRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .executeCommand(sandboxId, executeRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Execute a command in a specific session
   * @summary Execute command in session
   * @param {string} sandboxId
   * @param {string} sessionId
   * @param {SessionExecuteRequest} sessionExecuteRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public executeSessionCommand(
    sandboxId: string,
    sessionId: string,
    sessionExecuteRequest: SessionExecuteRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .executeSessionCommand(sandboxId, sessionId, sessionExecuteRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Search for text/pattern inside sandbox files
   * @summary Search for text/pattern in files
   * @param {string} sandboxId
   * @param {string} path
   * @param {string} pattern
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public findInFiles(
    sandboxId: string,
    path: string,
    pattern: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .findInFiles(sandboxId, path, pattern, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get status of all VNC desktop processes
   * @summary Get computer use status
   * @param {string} sandboxId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public getComputerUseStatus(sandboxId: string, xDaytonaOrganizationID?: string, options?: RawAxiosRequestConfig) {
    return ToolboxApiFp(this.configuration)
      .getComputerUseStatus(sandboxId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get information about displays
   * @summary Get display info
   * @param {string} sandboxId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public getDisplayInfo(sandboxId: string, xDaytonaOrganizationID?: string, options?: RawAxiosRequestConfig) {
    return ToolboxApiFp(this.configuration)
      .getDisplayInfo(sandboxId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get file info inside sandbox
   * @summary Get file info
   * @param {string} sandboxId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public getFileInfo(
    sandboxId: string,
    path: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .getFileInfo(sandboxId, path, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get current mouse cursor position
   * @summary Get mouse position
   * @param {string} sandboxId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public getMousePosition(sandboxId: string, xDaytonaOrganizationID?: string, options?: RawAxiosRequestConfig) {
    return ToolboxApiFp(this.configuration)
      .getMousePosition(sandboxId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get error logs for a specific VNC process
   * @summary Get process errors
   * @param {string} processName
   * @param {string} sandboxId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public getProcessErrors(
    processName: string,
    sandboxId: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .getProcessErrors(processName, sandboxId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get logs for a specific VNC process
   * @summary Get process logs
   * @param {string} processName
   * @param {string} sandboxId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public getProcessLogs(
    processName: string,
    sandboxId: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .getProcessLogs(processName, sandboxId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get status of a specific VNC process
   * @summary Get process status
   * @param {string} processName
   * @param {string} sandboxId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public getProcessStatus(
    processName: string,
    sandboxId: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .getProcessStatus(processName, sandboxId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get sandbox project dir
   * @param {string} sandboxId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public getProjectDir(sandboxId: string, xDaytonaOrganizationID?: string, options?: RawAxiosRequestConfig) {
    return ToolboxApiFp(this.configuration)
      .getProjectDir(sandboxId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get session by ID
   * @summary Get session
   * @param {string} sandboxId
   * @param {string} sessionId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public getSession(
    sandboxId: string,
    sessionId: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .getSession(sandboxId, sessionId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get session command by ID
   * @summary Get session command
   * @param {string} sandboxId
   * @param {string} sessionId
   * @param {string} commandId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public getSessionCommand(
    sandboxId: string,
    sessionId: string,
    commandId: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .getSessionCommand(sandboxId, sessionId, commandId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get logs for a specific command in a session
   * @summary Get command logs
   * @param {string} sandboxId
   * @param {string} sessionId
   * @param {string} commandId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {boolean} [follow]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public getSessionCommandLogs(
    sandboxId: string,
    sessionId: string,
    commandId: string,
    xDaytonaOrganizationID?: string,
    follow?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .getSessionCommandLogs(sandboxId, sessionId, commandId, xDaytonaOrganizationID, follow, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get list of open windows
   * @summary Get windows
   * @param {string} sandboxId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public getWindows(sandboxId: string, xDaytonaOrganizationID?: string, options?: RawAxiosRequestConfig) {
    return ToolboxApiFp(this.configuration)
      .getWindows(sandboxId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Add files to git commit
   * @summary Add files
   * @param {string} sandboxId
   * @param {GitAddRequest} gitAddRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public gitAddFiles(
    sandboxId: string,
    gitAddRequest: GitAddRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .gitAddFiles(sandboxId, gitAddRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Checkout branch or commit in git repository
   * @summary Checkout branch
   * @param {string} sandboxId
   * @param {GitCheckoutRequest} gitCheckoutRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public gitCheckoutBranch(
    sandboxId: string,
    gitCheckoutRequest: GitCheckoutRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .gitCheckoutBranch(sandboxId, gitCheckoutRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Clone git repository
   * @summary Clone repository
   * @param {string} sandboxId
   * @param {GitCloneRequest} gitCloneRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public gitCloneRepository(
    sandboxId: string,
    gitCloneRequest: GitCloneRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .gitCloneRepository(sandboxId, gitCloneRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Commit changes to git repository
   * @summary Commit changes
   * @param {string} sandboxId
   * @param {GitCommitRequest} gitCommitRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public gitCommitChanges(
    sandboxId: string,
    gitCommitRequest: GitCommitRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .gitCommitChanges(sandboxId, gitCommitRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Create branch on git repository
   * @summary Create branch
   * @param {string} sandboxId
   * @param {GitBranchRequest} gitBranchRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public gitCreateBranch(
    sandboxId: string,
    gitBranchRequest: GitBranchRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .gitCreateBranch(sandboxId, gitBranchRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete branch on git repository
   * @summary Delete branch
   * @param {string} sandboxId
   * @param {GitDeleteBranchRequest} gitDeleteBranchRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public gitDeleteBranch(
    sandboxId: string,
    gitDeleteBranchRequest: GitDeleteBranchRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .gitDeleteBranch(sandboxId, gitDeleteBranchRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get commit history from git repository
   * @summary Get commit history
   * @param {string} sandboxId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public gitGetHistory(
    sandboxId: string,
    path: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .gitGetHistory(sandboxId, path, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get status from git repository
   * @summary Get git status
   * @param {string} sandboxId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public gitGetStatus(
    sandboxId: string,
    path: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .gitGetStatus(sandboxId, path, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get branch list from git repository
   * @summary Get branch list
   * @param {string} sandboxId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public gitListBranches(
    sandboxId: string,
    path: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .gitListBranches(sandboxId, path, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Pull changes from remote
   * @summary Pull changes
   * @param {string} sandboxId
   * @param {GitRepoRequest} gitRepoRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public gitPullChanges(
    sandboxId: string,
    gitRepoRequest: GitRepoRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .gitPullChanges(sandboxId, gitRepoRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Push changes to remote
   * @summary Push changes
   * @param {string} sandboxId
   * @param {GitRepoRequest} gitRepoRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public gitPushChanges(
    sandboxId: string,
    gitRepoRequest: GitRepoRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .gitPushChanges(sandboxId, gitRepoRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List files
   * @param {string} sandboxId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {string} [path]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public listFiles(sandboxId: string, xDaytonaOrganizationID?: string, path?: string, options?: RawAxiosRequestConfig) {
    return ToolboxApiFp(this.configuration)
      .listFiles(sandboxId, xDaytonaOrganizationID, path, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List all active sessions in the sandbox
   * @summary List sessions
   * @param {string} sandboxId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public listSessions(sandboxId: string, xDaytonaOrganizationID?: string, options?: RawAxiosRequestConfig) {
    return ToolboxApiFp(this.configuration)
      .listSessions(sandboxId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * The Completion request is sent from the client to the server to compute completion items at a given cursor position.
   * @summary Get Lsp Completions
   * @param {string} sandboxId
   * @param {LspCompletionParams} lspCompletionParams
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public lspCompletions(
    sandboxId: string,
    lspCompletionParams: LspCompletionParams,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .lspCompletions(sandboxId, lspCompletionParams, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * The document close notification is sent from the client to the server when the document got closed in the client.
   * @summary Call Lsp DidClose
   * @param {string} sandboxId
   * @param {LspDocumentRequest} lspDocumentRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public lspDidClose(
    sandboxId: string,
    lspDocumentRequest: LspDocumentRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .lspDidClose(sandboxId, lspDocumentRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * The document open notification is sent from the client to the server to signal newly opened text documents.
   * @summary Call Lsp DidOpen
   * @param {string} sandboxId
   * @param {LspDocumentRequest} lspDocumentRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public lspDidOpen(
    sandboxId: string,
    lspDocumentRequest: LspDocumentRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .lspDidOpen(sandboxId, lspDocumentRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * The document symbol request is sent from the client to the server.
   * @summary Call Lsp DocumentSymbols
   * @param {string} sandboxId
   * @param {string} languageId
   * @param {string} pathToProject
   * @param {string} uri
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public lspDocumentSymbols(
    sandboxId: string,
    languageId: string,
    pathToProject: string,
    uri: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .lspDocumentSymbols(sandboxId, languageId, pathToProject, uri, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Start Lsp server process inside sandbox project
   * @summary Start Lsp server
   * @param {string} sandboxId
   * @param {LspServerRequest} lspServerRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public lspStart(
    sandboxId: string,
    lspServerRequest: LspServerRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .lspStart(sandboxId, lspServerRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Stop Lsp server process inside sandbox project
   * @summary Stop Lsp server
   * @param {string} sandboxId
   * @param {LspServerRequest} lspServerRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public lspStop(
    sandboxId: string,
    lspServerRequest: LspServerRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .lspStop(sandboxId, lspServerRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.
   * @summary Call Lsp WorkspaceSymbols
   * @param {string} sandboxId
   * @param {string} languageId
   * @param {string} pathToProject
   * @param {string} query
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public lspWorkspaceSymbols(
    sandboxId: string,
    languageId: string,
    pathToProject: string,
    query: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .lspWorkspaceSymbols(sandboxId, languageId, pathToProject, query, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Move file inside sandbox
   * @summary Move file
   * @param {string} sandboxId
   * @param {string} source
   * @param {string} destination
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public moveFile(
    sandboxId: string,
    source: string,
    destination: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .moveFile(sandboxId, source, destination, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Move mouse cursor to specified coordinates
   * @summary Move mouse
   * @param {string} sandboxId
   * @param {MouseMoveRequest} mouseMoveRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public moveMouse(
    sandboxId: string,
    mouseMoveRequest: MouseMoveRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .moveMouse(sandboxId, mouseMoveRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Press a hotkey combination
   * @summary Press hotkey
   * @param {string} sandboxId
   * @param {KeyboardHotkeyRequest} keyboardHotkeyRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public pressHotkey(
    sandboxId: string,
    keyboardHotkeyRequest: KeyboardHotkeyRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .pressHotkey(sandboxId, keyboardHotkeyRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Press a key with optional modifiers
   * @summary Press key
   * @param {string} sandboxId
   * @param {KeyboardPressRequest} keyboardPressRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public pressKey(
    sandboxId: string,
    keyboardPressRequest: KeyboardPressRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .pressKey(sandboxId, keyboardPressRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Replace text/pattern in multiple files inside sandbox
   * @summary Replace in files
   * @param {string} sandboxId
   * @param {ReplaceRequest} replaceRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public replaceInFiles(
    sandboxId: string,
    replaceRequest: ReplaceRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .replaceInFiles(sandboxId, replaceRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Restart a specific VNC process
   * @summary Restart process
   * @param {string} processName
   * @param {string} sandboxId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public restartProcess(
    processName: string,
    sandboxId: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .restartProcess(processName, sandboxId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Scroll mouse at specified coordinates
   * @summary Scroll mouse
   * @param {string} sandboxId
   * @param {MouseScrollRequest} mouseScrollRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public scrollMouse(
    sandboxId: string,
    mouseScrollRequest: MouseScrollRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .scrollMouse(sandboxId, mouseScrollRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Search for files inside sandbox
   * @summary Search files
   * @param {string} sandboxId
   * @param {string} path
   * @param {string} pattern
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public searchFiles(
    sandboxId: string,
    path: string,
    pattern: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .searchFiles(sandboxId, path, pattern, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Set file owner/group/permissions inside sandbox
   * @summary Set file permissions
   * @param {string} sandboxId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {string} [owner]
   * @param {string} [group]
   * @param {string} [mode]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public setFilePermissions(
    sandboxId: string,
    path: string,
    xDaytonaOrganizationID?: string,
    owner?: string,
    group?: string,
    mode?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .setFilePermissions(sandboxId, path, xDaytonaOrganizationID, owner, group, mode, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Start all VNC desktop processes (Xvfb, xfce4, x11vnc, novnc)
   * @summary Start computer use processes
   * @param {string} sandboxId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public startComputerUse(sandboxId: string, xDaytonaOrganizationID?: string, options?: RawAxiosRequestConfig) {
    return ToolboxApiFp(this.configuration)
      .startComputerUse(sandboxId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Stop all VNC desktop processes (Xvfb, xfce4, x11vnc, novnc)
   * @summary Stop computer use processes
   * @param {string} sandboxId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public stopComputerUse(sandboxId: string, xDaytonaOrganizationID?: string, options?: RawAxiosRequestConfig) {
    return ToolboxApiFp(this.configuration)
      .stopComputerUse(sandboxId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Take a compressed screenshot of a specific region
   * @summary Take compressed region screenshot
   * @param {string} sandboxId
   * @param {number} height
   * @param {number} width
   * @param {number} y
   * @param {number} x
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {number} [scale]
   * @param {number} [quality]
   * @param {string} [format]
   * @param {boolean} [showCursor]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public takeCompressedRegionScreenshot(
    sandboxId: string,
    height: number,
    width: number,
    y: number,
    x: number,
    xDaytonaOrganizationID?: string,
    scale?: number,
    quality?: number,
    format?: string,
    showCursor?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .takeCompressedRegionScreenshot(
        sandboxId,
        height,
        width,
        y,
        x,
        xDaytonaOrganizationID,
        scale,
        quality,
        format,
        showCursor,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Take a compressed screenshot with format, quality, and scale options
   * @summary Take compressed screenshot
   * @param {string} sandboxId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {number} [scale]
   * @param {number} [quality]
   * @param {string} [format]
   * @param {boolean} [showCursor]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public takeCompressedScreenshot(
    sandboxId: string,
    xDaytonaOrganizationID?: string,
    scale?: number,
    quality?: number,
    format?: string,
    showCursor?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .takeCompressedScreenshot(sandboxId, xDaytonaOrganizationID, scale, quality, format, showCursor, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Take a screenshot of a specific region
   * @summary Take region screenshot
   * @param {string} sandboxId
   * @param {number} height
   * @param {number} width
   * @param {number} y
   * @param {number} x
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {boolean} [showCursor]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public takeRegionScreenshot(
    sandboxId: string,
    height: number,
    width: number,
    y: number,
    x: number,
    xDaytonaOrganizationID?: string,
    showCursor?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .takeRegionScreenshot(sandboxId, height, width, y, x, xDaytonaOrganizationID, showCursor, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Take a screenshot of the entire screen
   * @summary Take screenshot
   * @param {string} sandboxId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {boolean} [showCursor]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public takeScreenshot(
    sandboxId: string,
    xDaytonaOrganizationID?: string,
    showCursor?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .takeScreenshot(sandboxId, xDaytonaOrganizationID, showCursor, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Type text using keyboard
   * @summary Type text
   * @param {string} sandboxId
   * @param {KeyboardTypeRequest} keyboardTypeRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public typeText(
    sandboxId: string,
    keyboardTypeRequest: KeyboardTypeRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .typeText(sandboxId, keyboardTypeRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Upload file inside sandbox
   * @summary Upload file
   * @param {string} sandboxId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {File} [file]
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public uploadFile(
    sandboxId: string,
    path: string,
    xDaytonaOrganizationID?: string,
    file?: File,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .uploadFile(sandboxId, path, xDaytonaOrganizationID, file, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Upload multiple files inside sandbox
   * @summary Upload multiple files
   * @param {string} sandboxId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public uploadFiles(sandboxId: string, xDaytonaOrganizationID?: string, options?: RawAxiosRequestConfig) {
    return ToolboxApiFp(this.configuration)
      .uploadFiles(sandboxId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
