/* tslint:disable */
/* eslint-disable */
/**
 * Daytona
 * Daytona AI platform API Docs
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@daytona.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from '../configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from '../common'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base'
// @ts-ignore
import type { Command } from '../models'
// @ts-ignore
import type { CompletionList } from '../models'
// @ts-ignore
import type { CreateSessionRequest } from '../models'
// @ts-ignore
import type { ExecuteRequest } from '../models'
// @ts-ignore
import type { ExecuteResponse } from '../models'
// @ts-ignore
import type { FileInfo } from '../models'
// @ts-ignore
import type { GitAddRequest } from '../models'
// @ts-ignore
import type { GitBranchRequest } from '../models'
// @ts-ignore
import type { GitCheckoutRequest } from '../models'
// @ts-ignore
import type { GitCloneRequest } from '../models'
// @ts-ignore
import type { GitCommitInfo } from '../models'
// @ts-ignore
import type { GitCommitRequest } from '../models'
// @ts-ignore
import type { GitCommitResponse } from '../models'
// @ts-ignore
import type { GitDeleteBranchRequest } from '../models'
// @ts-ignore
import type { GitRepoRequest } from '../models'
// @ts-ignore
import type { GitStatus } from '../models'
// @ts-ignore
import type { ListBranchResponse } from '../models'
// @ts-ignore
import type { LspCompletionParams } from '../models'
// @ts-ignore
import type { LspDocumentRequest } from '../models'
// @ts-ignore
import type { LspServerRequest } from '../models'
// @ts-ignore
import type { LspSymbol } from '../models'
// @ts-ignore
import type { Match } from '../models'
// @ts-ignore
import type { ProjectDirResponse } from '../models'
// @ts-ignore
import type { ReplaceRequest } from '../models'
// @ts-ignore
import type { ReplaceResult } from '../models'
// @ts-ignore
import type { SearchFilesResponse } from '../models'
// @ts-ignore
import type { Session } from '../models'
// @ts-ignore
import type { SessionExecuteRequest } from '../models'
// @ts-ignore
import type { SessionExecuteResponse } from '../models'
/**
 * ToolboxApi - axios parameter creator
 * @export
 */
export const ToolboxApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create folder inside workspace
     * @summary Create folder
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} mode
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFolder: async (
      workspaceId: string,
      path: string,
      mode: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('createFolder', 'workspaceId', workspaceId)
      // verify required parameter 'path' is not null or undefined
      assertParamExists('createFolder', 'path', path)
      // verify required parameter 'mode' is not null or undefined
      assertParamExists('createFolder', 'mode', mode)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/files/folder`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (mode !== undefined) {
        localVarQueryParameter['mode'] = mode
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create a new session in the workspace
     * @summary Create session
     * @param {string} workspaceId
     * @param {CreateSessionRequest} createSessionRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSession: async (
      workspaceId: string,
      createSessionRequest: CreateSessionRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('createSession', 'workspaceId', workspaceId)
      // verify required parameter 'createSessionRequest' is not null or undefined
      assertParamExists('createSession', 'createSessionRequest', createSessionRequest)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/process/session`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createSessionRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete file inside workspace
     * @summary Delete file
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile: async (
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('deleteFile', 'workspaceId', workspaceId)
      // verify required parameter 'path' is not null or undefined
      assertParamExists('deleteFile', 'path', path)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/files`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete a specific session
     * @summary Delete session
     * @param {string} workspaceId
     * @param {string} sessionId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSession: async (
      workspaceId: string,
      sessionId: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('deleteSession', 'workspaceId', workspaceId)
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists('deleteSession', 'sessionId', sessionId)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/process/session/{sessionId}`
        .replace(`{${'workspaceId'}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${'sessionId'}}`, encodeURIComponent(String(sessionId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Download file from workspace
     * @summary Download file
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile: async (
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('downloadFile', 'workspaceId', workspaceId)
      // verify required parameter 'path' is not null or undefined
      assertParamExists('downloadFile', 'path', path)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/files/download`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Execute command synchronously inside workspace
     * @summary Execute command
     * @param {string} workspaceId
     * @param {ExecuteRequest} executeRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeCommand: async (
      workspaceId: string,
      executeRequest: ExecuteRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('executeCommand', 'workspaceId', workspaceId)
      // verify required parameter 'executeRequest' is not null or undefined
      assertParamExists('executeCommand', 'executeRequest', executeRequest)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/process/execute`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(executeRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Execute a command in a specific session
     * @summary Execute command in session
     * @param {string} workspaceId
     * @param {string} sessionId
     * @param {SessionExecuteRequest} sessionExecuteRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeSessionCommand: async (
      workspaceId: string,
      sessionId: string,
      sessionExecuteRequest: SessionExecuteRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('executeSessionCommand', 'workspaceId', workspaceId)
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists('executeSessionCommand', 'sessionId', sessionId)
      // verify required parameter 'sessionExecuteRequest' is not null or undefined
      assertParamExists('executeSessionCommand', 'sessionExecuteRequest', sessionExecuteRequest)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/process/session/{sessionId}/exec`
        .replace(`{${'workspaceId'}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${'sessionId'}}`, encodeURIComponent(String(sessionId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(sessionExecuteRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Search for text/pattern inside workspace files
     * @summary Search for text/pattern in files
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} pattern
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findInFiles: async (
      workspaceId: string,
      path: string,
      pattern: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('findInFiles', 'workspaceId', workspaceId)
      // verify required parameter 'path' is not null or undefined
      assertParamExists('findInFiles', 'path', path)
      // verify required parameter 'pattern' is not null or undefined
      assertParamExists('findInFiles', 'pattern', pattern)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/files/find`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (pattern !== undefined) {
        localVarQueryParameter['pattern'] = pattern
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get file info inside workspace
     * @summary Get file info
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileInfo: async (
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('getFileInfo', 'workspaceId', workspaceId)
      // verify required parameter 'path' is not null or undefined
      assertParamExists('getFileInfo', 'path', path)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/files/info`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get workspace project dir
     * @param {string} workspaceId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectDir: async (
      workspaceId: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('getProjectDir', 'workspaceId', workspaceId)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/project-dir`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get session by ID
     * @summary Get session
     * @param {string} workspaceId
     * @param {string} sessionId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSession: async (
      workspaceId: string,
      sessionId: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('getSession', 'workspaceId', workspaceId)
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists('getSession', 'sessionId', sessionId)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/process/session/{sessionId}`
        .replace(`{${'workspaceId'}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${'sessionId'}}`, encodeURIComponent(String(sessionId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get session command by ID
     * @summary Get session command
     * @param {string} workspaceId
     * @param {string} sessionId
     * @param {string} commandId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionCommand: async (
      workspaceId: string,
      sessionId: string,
      commandId: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('getSessionCommand', 'workspaceId', workspaceId)
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists('getSessionCommand', 'sessionId', sessionId)
      // verify required parameter 'commandId' is not null or undefined
      assertParamExists('getSessionCommand', 'commandId', commandId)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/process/session/{sessionId}/command/{commandId}`
        .replace(`{${'workspaceId'}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${'sessionId'}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${'commandId'}}`, encodeURIComponent(String(commandId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get logs for a specific command in a session
     * @summary Get command logs
     * @param {string} workspaceId
     * @param {string} sessionId
     * @param {string} commandId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {boolean} [follow]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionCommandLogs: async (
      workspaceId: string,
      sessionId: string,
      commandId: string,
      xDaytonaOrganizationID?: string,
      follow?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('getSessionCommandLogs', 'workspaceId', workspaceId)
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists('getSessionCommandLogs', 'sessionId', sessionId)
      // verify required parameter 'commandId' is not null or undefined
      assertParamExists('getSessionCommandLogs', 'commandId', commandId)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/process/session/{sessionId}/command/{commandId}/logs`
        .replace(`{${'workspaceId'}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${'sessionId'}}`, encodeURIComponent(String(sessionId)))
        .replace(`{${'commandId'}}`, encodeURIComponent(String(commandId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (follow !== undefined) {
        localVarQueryParameter['follow'] = follow
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Add files to git commit
     * @summary Add files
     * @param {string} workspaceId
     * @param {GitAddRequest} gitAddRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitAddFiles: async (
      workspaceId: string,
      gitAddRequest: GitAddRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('gitAddFiles', 'workspaceId', workspaceId)
      // verify required parameter 'gitAddRequest' is not null or undefined
      assertParamExists('gitAddFiles', 'gitAddRequest', gitAddRequest)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/git/add`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(gitAddRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Checkout branch or commit in git repository
     * @summary Checkout branch
     * @param {string} workspaceId
     * @param {GitCheckoutRequest} gitCheckoutRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCheckoutBranch: async (
      workspaceId: string,
      gitCheckoutRequest: GitCheckoutRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('gitCheckoutBranch', 'workspaceId', workspaceId)
      // verify required parameter 'gitCheckoutRequest' is not null or undefined
      assertParamExists('gitCheckoutBranch', 'gitCheckoutRequest', gitCheckoutRequest)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/git/checkout`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(gitCheckoutRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Clone git repository
     * @summary Clone repository
     * @param {string} workspaceId
     * @param {GitCloneRequest} gitCloneRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCloneRepository: async (
      workspaceId: string,
      gitCloneRequest: GitCloneRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('gitCloneRepository', 'workspaceId', workspaceId)
      // verify required parameter 'gitCloneRequest' is not null or undefined
      assertParamExists('gitCloneRepository', 'gitCloneRequest', gitCloneRequest)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/git/clone`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(gitCloneRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Commit changes to git repository
     * @summary Commit changes
     * @param {string} workspaceId
     * @param {GitCommitRequest} gitCommitRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCommitChanges: async (
      workspaceId: string,
      gitCommitRequest: GitCommitRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('gitCommitChanges', 'workspaceId', workspaceId)
      // verify required parameter 'gitCommitRequest' is not null or undefined
      assertParamExists('gitCommitChanges', 'gitCommitRequest', gitCommitRequest)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/git/commit`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(gitCommitRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create branch on git repository
     * @summary Create branch
     * @param {string} workspaceId
     * @param {GitBranchRequest} gitBranchRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCreateBranch: async (
      workspaceId: string,
      gitBranchRequest: GitBranchRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('gitCreateBranch', 'workspaceId', workspaceId)
      // verify required parameter 'gitBranchRequest' is not null or undefined
      assertParamExists('gitCreateBranch', 'gitBranchRequest', gitBranchRequest)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/git/branches`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(gitBranchRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete branch on git repository
     * @summary Delete branch
     * @param {string} workspaceId
     * @param {GitDeleteBranchRequest} gitDeleteBranchRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitDeleteBranch: async (
      workspaceId: string,
      gitDeleteBranchRequest: GitDeleteBranchRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('gitDeleteBranch', 'workspaceId', workspaceId)
      // verify required parameter 'gitDeleteBranchRequest' is not null or undefined
      assertParamExists('gitDeleteBranch', 'gitDeleteBranchRequest', gitDeleteBranchRequest)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/git/branches`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(gitDeleteBranchRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get commit history from git repository
     * @summary Get commit history
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitGetHistory: async (
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('gitGetHistory', 'workspaceId', workspaceId)
      // verify required parameter 'path' is not null or undefined
      assertParamExists('gitGetHistory', 'path', path)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/git/history`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get status from git repository
     * @summary Get git status
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitGetStatus: async (
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('gitGetStatus', 'workspaceId', workspaceId)
      // verify required parameter 'path' is not null or undefined
      assertParamExists('gitGetStatus', 'path', path)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/git/status`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get branch list from git repository
     * @summary Get branch list
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitListBranches: async (
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('gitListBranches', 'workspaceId', workspaceId)
      // verify required parameter 'path' is not null or undefined
      assertParamExists('gitListBranches', 'path', path)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/git/branches`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Pull changes from remote
     * @summary Pull changes
     * @param {string} workspaceId
     * @param {GitRepoRequest} gitRepoRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitPullChanges: async (
      workspaceId: string,
      gitRepoRequest: GitRepoRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('gitPullChanges', 'workspaceId', workspaceId)
      // verify required parameter 'gitRepoRequest' is not null or undefined
      assertParamExists('gitPullChanges', 'gitRepoRequest', gitRepoRequest)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/git/pull`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(gitRepoRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Push changes to remote
     * @summary Push changes
     * @param {string} workspaceId
     * @param {GitRepoRequest} gitRepoRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitPushChanges: async (
      workspaceId: string,
      gitRepoRequest: GitRepoRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('gitPushChanges', 'workspaceId', workspaceId)
      // verify required parameter 'gitRepoRequest' is not null or undefined
      assertParamExists('gitPushChanges', 'gitRepoRequest', gitRepoRequest)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/git/push`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(gitRepoRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List files
     * @param {string} workspaceId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {string} [path]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFiles: async (
      workspaceId: string,
      xDaytonaOrganizationID?: string,
      path?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('listFiles', 'workspaceId', workspaceId)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/files`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List all active sessions in the workspace
     * @summary List sessions
     * @param {string} workspaceId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSessions: async (
      workspaceId: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('listSessions', 'workspaceId', workspaceId)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/process/session`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * The Completion request is sent from the client to the server to compute completion items at a given cursor position.
     * @summary Get Lsp Completions
     * @param {string} workspaceId
     * @param {LspCompletionParams} lspCompletionParams
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspCompletions: async (
      workspaceId: string,
      lspCompletionParams: LspCompletionParams,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('lspCompletions', 'workspaceId', workspaceId)
      // verify required parameter 'lspCompletionParams' is not null or undefined
      assertParamExists('lspCompletions', 'lspCompletionParams', lspCompletionParams)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/lsp/completions`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(lspCompletionParams, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * The document close notification is sent from the client to the server when the document got closed in the client.
     * @summary Call Lsp DidClose
     * @param {string} workspaceId
     * @param {LspDocumentRequest} lspDocumentRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspDidClose: async (
      workspaceId: string,
      lspDocumentRequest: LspDocumentRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('lspDidClose', 'workspaceId', workspaceId)
      // verify required parameter 'lspDocumentRequest' is not null or undefined
      assertParamExists('lspDidClose', 'lspDocumentRequest', lspDocumentRequest)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/lsp/did-close`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(lspDocumentRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * The document open notification is sent from the client to the server to signal newly opened text documents.
     * @summary Call Lsp DidOpen
     * @param {string} workspaceId
     * @param {LspDocumentRequest} lspDocumentRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspDidOpen: async (
      workspaceId: string,
      lspDocumentRequest: LspDocumentRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('lspDidOpen', 'workspaceId', workspaceId)
      // verify required parameter 'lspDocumentRequest' is not null or undefined
      assertParamExists('lspDidOpen', 'lspDocumentRequest', lspDocumentRequest)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/lsp/did-open`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(lspDocumentRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * The document symbol request is sent from the client to the server.
     * @summary Call Lsp DocumentSymbols
     * @param {string} workspaceId
     * @param {string} languageId
     * @param {string} pathToProject
     * @param {string} uri
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspDocumentSymbols: async (
      workspaceId: string,
      languageId: string,
      pathToProject: string,
      uri: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('lspDocumentSymbols', 'workspaceId', workspaceId)
      // verify required parameter 'languageId' is not null or undefined
      assertParamExists('lspDocumentSymbols', 'languageId', languageId)
      // verify required parameter 'pathToProject' is not null or undefined
      assertParamExists('lspDocumentSymbols', 'pathToProject', pathToProject)
      // verify required parameter 'uri' is not null or undefined
      assertParamExists('lspDocumentSymbols', 'uri', uri)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/lsp/document-symbols`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (languageId !== undefined) {
        localVarQueryParameter['languageId'] = languageId
      }

      if (pathToProject !== undefined) {
        localVarQueryParameter['pathToProject'] = pathToProject
      }

      if (uri !== undefined) {
        localVarQueryParameter['uri'] = uri
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Start Lsp server process inside workspace project
     * @summary Start Lsp server
     * @param {string} workspaceId
     * @param {LspServerRequest} lspServerRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspStart: async (
      workspaceId: string,
      lspServerRequest: LspServerRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('lspStart', 'workspaceId', workspaceId)
      // verify required parameter 'lspServerRequest' is not null or undefined
      assertParamExists('lspStart', 'lspServerRequest', lspServerRequest)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/lsp/start`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(lspServerRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Stop Lsp server process inside workspace project
     * @summary Stop Lsp server
     * @param {string} workspaceId
     * @param {LspServerRequest} lspServerRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspStop: async (
      workspaceId: string,
      lspServerRequest: LspServerRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('lspStop', 'workspaceId', workspaceId)
      // verify required parameter 'lspServerRequest' is not null or undefined
      assertParamExists('lspStop', 'lspServerRequest', lspServerRequest)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/lsp/stop`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(lspServerRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.
     * @summary Call Lsp WorkspaceSymbols
     * @param {string} workspaceId
     * @param {string} languageId
     * @param {string} pathToProject
     * @param {string} query
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspWorkspaceSymbols: async (
      workspaceId: string,
      languageId: string,
      pathToProject: string,
      query: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('lspWorkspaceSymbols', 'workspaceId', workspaceId)
      // verify required parameter 'languageId' is not null or undefined
      assertParamExists('lspWorkspaceSymbols', 'languageId', languageId)
      // verify required parameter 'pathToProject' is not null or undefined
      assertParamExists('lspWorkspaceSymbols', 'pathToProject', pathToProject)
      // verify required parameter 'query' is not null or undefined
      assertParamExists('lspWorkspaceSymbols', 'query', query)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/lsp/workspace-symbols`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (languageId !== undefined) {
        localVarQueryParameter['languageId'] = languageId
      }

      if (pathToProject !== undefined) {
        localVarQueryParameter['pathToProject'] = pathToProject
      }

      if (query !== undefined) {
        localVarQueryParameter['query'] = query
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Move file inside workspace
     * @summary Move file
     * @param {string} workspaceId
     * @param {string} source
     * @param {string} destination
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moveFile: async (
      workspaceId: string,
      source: string,
      destination: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('moveFile', 'workspaceId', workspaceId)
      // verify required parameter 'source' is not null or undefined
      assertParamExists('moveFile', 'source', source)
      // verify required parameter 'destination' is not null or undefined
      assertParamExists('moveFile', 'destination', destination)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/files/move`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (source !== undefined) {
        localVarQueryParameter['source'] = source
      }

      if (destination !== undefined) {
        localVarQueryParameter['destination'] = destination
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Replace text/pattern in multiple files inside workspace
     * @summary Replace in files
     * @param {string} workspaceId
     * @param {ReplaceRequest} replaceRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceInFiles: async (
      workspaceId: string,
      replaceRequest: ReplaceRequest,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('replaceInFiles', 'workspaceId', workspaceId)
      // verify required parameter 'replaceRequest' is not null or undefined
      assertParamExists('replaceInFiles', 'replaceRequest', replaceRequest)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/files/replace`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(replaceRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Search for files inside workspace
     * @summary Search files
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} pattern
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchFiles: async (
      workspaceId: string,
      path: string,
      pattern: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('searchFiles', 'workspaceId', workspaceId)
      // verify required parameter 'path' is not null or undefined
      assertParamExists('searchFiles', 'path', path)
      // verify required parameter 'pattern' is not null or undefined
      assertParamExists('searchFiles', 'pattern', pattern)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/files/search`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (pattern !== undefined) {
        localVarQueryParameter['pattern'] = pattern
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Set file owner/group/permissions inside workspace
     * @summary Set file permissions
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {string} [owner]
     * @param {string} [group]
     * @param {string} [mode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFilePermissions: async (
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      owner?: string,
      group?: string,
      mode?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('setFilePermissions', 'workspaceId', workspaceId)
      // verify required parameter 'path' is not null or undefined
      assertParamExists('setFilePermissions', 'path', path)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/files/permissions`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (owner !== undefined) {
        localVarQueryParameter['owner'] = owner
      }

      if (group !== undefined) {
        localVarQueryParameter['group'] = group
      }

      if (mode !== undefined) {
        localVarQueryParameter['mode'] = mode
      }

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Upload file inside workspace
     * @summary Upload file
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {File} [file]
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    uploadFile: async (
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      file?: File,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('uploadFile', 'workspaceId', workspaceId)
      // verify required parameter 'path' is not null or undefined
      assertParamExists('uploadFile', 'path', path)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/files/upload`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)()

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (file !== undefined) {
        localVarFormParams.append('file', file as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Upload multiple files inside workspace
     * @summary Upload multiple files
     * @param {string} workspaceId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFiles: async (
      workspaceId: string,
      xDaytonaOrganizationID?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('uploadFiles', 'workspaceId', workspaceId)
      const localVarPath = `/toolbox/{workspaceId}/toolbox/files/bulk-upload`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication oauth2 required

      if (xDaytonaOrganizationID != null) {
        localVarHeaderParameter['X-Daytona-Organization-ID'] = String(xDaytonaOrganizationID)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ToolboxApi - functional programming interface
 * @export
 */
export const ToolboxApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ToolboxApiAxiosParamCreator(configuration)
  return {
    /**
     * Create folder inside workspace
     * @summary Create folder
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} mode
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFolder(
      workspaceId: string,
      path: string,
      mode: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createFolder(
        workspaceId,
        path,
        mode,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.createFolder']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Create a new session in the workspace
     * @summary Create session
     * @param {string} workspaceId
     * @param {CreateSessionRequest} createSessionRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSession(
      workspaceId: string,
      createSessionRequest: CreateSessionRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createSession(
        workspaceId,
        createSessionRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.createSession']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Delete file inside workspace
     * @summary Delete file
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFile(
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(
        workspaceId,
        path,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.deleteFile']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Delete a specific session
     * @summary Delete session
     * @param {string} workspaceId
     * @param {string} sessionId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSession(
      workspaceId: string,
      sessionId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSession(
        workspaceId,
        sessionId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.deleteSession']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Download file from workspace
     * @summary Download file
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadFile(
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(
        workspaceId,
        path,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.downloadFile']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Execute command synchronously inside workspace
     * @summary Execute command
     * @param {string} workspaceId
     * @param {ExecuteRequest} executeRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async executeCommand(
      workspaceId: string,
      executeRequest: ExecuteRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.executeCommand(
        workspaceId,
        executeRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.executeCommand']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Execute a command in a specific session
     * @summary Execute command in session
     * @param {string} workspaceId
     * @param {string} sessionId
     * @param {SessionExecuteRequest} sessionExecuteRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async executeSessionCommand(
      workspaceId: string,
      sessionId: string,
      sessionExecuteRequest: SessionExecuteRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionExecuteResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.executeSessionCommand(
        workspaceId,
        sessionId,
        sessionExecuteRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.executeSessionCommand']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Search for text/pattern inside workspace files
     * @summary Search for text/pattern in files
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} pattern
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findInFiles(
      workspaceId: string,
      path: string,
      pattern: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Match>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findInFiles(
        workspaceId,
        path,
        pattern,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.findInFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get file info inside workspace
     * @summary Get file info
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFileInfo(
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFileInfo(
        workspaceId,
        path,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.getFileInfo']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Get workspace project dir
     * @param {string} workspaceId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProjectDir(
      workspaceId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDirResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectDir(
        workspaceId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.getProjectDir']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get session by ID
     * @summary Get session
     * @param {string} workspaceId
     * @param {string} sessionId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSession(
      workspaceId: string,
      sessionId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSession(
        workspaceId,
        sessionId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.getSession']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get session command by ID
     * @summary Get session command
     * @param {string} workspaceId
     * @param {string} sessionId
     * @param {string} commandId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSessionCommand(
      workspaceId: string,
      sessionId: string,
      commandId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Command>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionCommand(
        workspaceId,
        sessionId,
        commandId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.getSessionCommand']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get logs for a specific command in a session
     * @summary Get command logs
     * @param {string} workspaceId
     * @param {string} sessionId
     * @param {string} commandId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {boolean} [follow]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSessionCommandLogs(
      workspaceId: string,
      sessionId: string,
      commandId: string,
      xDaytonaOrganizationID?: string,
      follow?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionCommandLogs(
        workspaceId,
        sessionId,
        commandId,
        xDaytonaOrganizationID,
        follow,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.getSessionCommandLogs']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Add files to git commit
     * @summary Add files
     * @param {string} workspaceId
     * @param {GitAddRequest} gitAddRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitAddFiles(
      workspaceId: string,
      gitAddRequest: GitAddRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitAddFiles(
        workspaceId,
        gitAddRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.gitAddFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Checkout branch or commit in git repository
     * @summary Checkout branch
     * @param {string} workspaceId
     * @param {GitCheckoutRequest} gitCheckoutRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitCheckoutBranch(
      workspaceId: string,
      gitCheckoutRequest: GitCheckoutRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitCheckoutBranch(
        workspaceId,
        gitCheckoutRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.gitCheckoutBranch']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Clone git repository
     * @summary Clone repository
     * @param {string} workspaceId
     * @param {GitCloneRequest} gitCloneRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitCloneRepository(
      workspaceId: string,
      gitCloneRequest: GitCloneRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitCloneRepository(
        workspaceId,
        gitCloneRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.gitCloneRepository']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Commit changes to git repository
     * @summary Commit changes
     * @param {string} workspaceId
     * @param {GitCommitRequest} gitCommitRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitCommitChanges(
      workspaceId: string,
      gitCommitRequest: GitCommitRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitCommitResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitCommitChanges(
        workspaceId,
        gitCommitRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.gitCommitChanges']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Create branch on git repository
     * @summary Create branch
     * @param {string} workspaceId
     * @param {GitBranchRequest} gitBranchRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitCreateBranch(
      workspaceId: string,
      gitBranchRequest: GitBranchRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitCreateBranch(
        workspaceId,
        gitBranchRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.gitCreateBranch']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Delete branch on git repository
     * @summary Delete branch
     * @param {string} workspaceId
     * @param {GitDeleteBranchRequest} gitDeleteBranchRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitDeleteBranch(
      workspaceId: string,
      gitDeleteBranchRequest: GitDeleteBranchRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitDeleteBranch(
        workspaceId,
        gitDeleteBranchRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.gitDeleteBranch']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get commit history from git repository
     * @summary Get commit history
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitGetHistory(
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GitCommitInfo>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitGetHistory(
        workspaceId,
        path,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.gitGetHistory']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get status from git repository
     * @summary Get git status
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitGetStatus(
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitStatus>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitGetStatus(
        workspaceId,
        path,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.gitGetStatus']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get branch list from git repository
     * @summary Get branch list
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitListBranches(
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBranchResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitListBranches(
        workspaceId,
        path,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.gitListBranches']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Pull changes from remote
     * @summary Pull changes
     * @param {string} workspaceId
     * @param {GitRepoRequest} gitRepoRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitPullChanges(
      workspaceId: string,
      gitRepoRequest: GitRepoRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitPullChanges(
        workspaceId,
        gitRepoRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.gitPullChanges']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Push changes to remote
     * @summary Push changes
     * @param {string} workspaceId
     * @param {GitRepoRequest} gitRepoRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gitPushChanges(
      workspaceId: string,
      gitRepoRequest: GitRepoRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gitPushChanges(
        workspaceId,
        gitRepoRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.gitPushChanges']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary List files
     * @param {string} workspaceId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {string} [path]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listFiles(
      workspaceId: string,
      xDaytonaOrganizationID?: string,
      path?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileInfo>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listFiles(
        workspaceId,
        xDaytonaOrganizationID,
        path,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.listFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * List all active sessions in the workspace
     * @summary List sessions
     * @param {string} workspaceId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listSessions(
      workspaceId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Session>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listSessions(
        workspaceId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.listSessions']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * The Completion request is sent from the client to the server to compute completion items at a given cursor position.
     * @summary Get Lsp Completions
     * @param {string} workspaceId
     * @param {LspCompletionParams} lspCompletionParams
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lspCompletions(
      workspaceId: string,
      lspCompletionParams: LspCompletionParams,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompletionList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lspCompletions(
        workspaceId,
        lspCompletionParams,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.lspCompletions']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * The document close notification is sent from the client to the server when the document got closed in the client.
     * @summary Call Lsp DidClose
     * @param {string} workspaceId
     * @param {LspDocumentRequest} lspDocumentRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lspDidClose(
      workspaceId: string,
      lspDocumentRequest: LspDocumentRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lspDidClose(
        workspaceId,
        lspDocumentRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.lspDidClose']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * The document open notification is sent from the client to the server to signal newly opened text documents.
     * @summary Call Lsp DidOpen
     * @param {string} workspaceId
     * @param {LspDocumentRequest} lspDocumentRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lspDidOpen(
      workspaceId: string,
      lspDocumentRequest: LspDocumentRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lspDidOpen(
        workspaceId,
        lspDocumentRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.lspDidOpen']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * The document symbol request is sent from the client to the server.
     * @summary Call Lsp DocumentSymbols
     * @param {string} workspaceId
     * @param {string} languageId
     * @param {string} pathToProject
     * @param {string} uri
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lspDocumentSymbols(
      workspaceId: string,
      languageId: string,
      pathToProject: string,
      uri: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LspSymbol>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lspDocumentSymbols(
        workspaceId,
        languageId,
        pathToProject,
        uri,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.lspDocumentSymbols']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Start Lsp server process inside workspace project
     * @summary Start Lsp server
     * @param {string} workspaceId
     * @param {LspServerRequest} lspServerRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lspStart(
      workspaceId: string,
      lspServerRequest: LspServerRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lspStart(
        workspaceId,
        lspServerRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.lspStart']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Stop Lsp server process inside workspace project
     * @summary Stop Lsp server
     * @param {string} workspaceId
     * @param {LspServerRequest} lspServerRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lspStop(
      workspaceId: string,
      lspServerRequest: LspServerRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lspStop(
        workspaceId,
        lspServerRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.lspStop']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.
     * @summary Call Lsp WorkspaceSymbols
     * @param {string} workspaceId
     * @param {string} languageId
     * @param {string} pathToProject
     * @param {string} query
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lspWorkspaceSymbols(
      workspaceId: string,
      languageId: string,
      pathToProject: string,
      query: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LspSymbol>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lspWorkspaceSymbols(
        workspaceId,
        languageId,
        pathToProject,
        query,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.lspWorkspaceSymbols']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Move file inside workspace
     * @summary Move file
     * @param {string} workspaceId
     * @param {string} source
     * @param {string} destination
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async moveFile(
      workspaceId: string,
      source: string,
      destination: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.moveFile(
        workspaceId,
        source,
        destination,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.moveFile']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Replace text/pattern in multiple files inside workspace
     * @summary Replace in files
     * @param {string} workspaceId
     * @param {ReplaceRequest} replaceRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async replaceInFiles(
      workspaceId: string,
      replaceRequest: ReplaceRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReplaceResult>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.replaceInFiles(
        workspaceId,
        replaceRequest,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.replaceInFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Search for files inside workspace
     * @summary Search files
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} pattern
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchFiles(
      workspaceId: string,
      path: string,
      pattern: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchFilesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchFiles(
        workspaceId,
        path,
        pattern,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.searchFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Set file owner/group/permissions inside workspace
     * @summary Set file permissions
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {string} [owner]
     * @param {string} [group]
     * @param {string} [mode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setFilePermissions(
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      owner?: string,
      group?: string,
      mode?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setFilePermissions(
        workspaceId,
        path,
        xDaytonaOrganizationID,
        owner,
        group,
        mode,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.setFilePermissions']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Upload file inside workspace
     * @summary Upload file
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {File} [file]
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async uploadFile(
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      file?: File,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(
        workspaceId,
        path,
        xDaytonaOrganizationID,
        file,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.uploadFile']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Upload multiple files inside workspace
     * @summary Upload multiple files
     * @param {string} workspaceId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadFiles(
      workspaceId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFiles(
        workspaceId,
        xDaytonaOrganizationID,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ToolboxApi.uploadFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ToolboxApi - factory interface
 * @export
 */
export const ToolboxApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ToolboxApiFp(configuration)
  return {
    /**
     * Create folder inside workspace
     * @summary Create folder
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} mode
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFolder(
      workspaceId: string,
      path: string,
      mode: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .createFolder(workspaceId, path, mode, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Create a new session in the workspace
     * @summary Create session
     * @param {string} workspaceId
     * @param {CreateSessionRequest} createSessionRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSession(
      workspaceId: string,
      createSessionRequest: CreateSessionRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .createSession(workspaceId, createSessionRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete file inside workspace
     * @summary Delete file
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteFile(workspaceId, path, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete a specific session
     * @summary Delete session
     * @param {string} workspaceId
     * @param {string} sessionId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSession(
      workspaceId: string,
      sessionId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteSession(workspaceId, sessionId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Download file from workspace
     * @summary Download file
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile(
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<File> {
      return localVarFp
        .downloadFile(workspaceId, path, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Execute command synchronously inside workspace
     * @summary Execute command
     * @param {string} workspaceId
     * @param {ExecuteRequest} executeRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeCommand(
      workspaceId: string,
      executeRequest: ExecuteRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ExecuteResponse> {
      return localVarFp
        .executeCommand(workspaceId, executeRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Execute a command in a specific session
     * @summary Execute command in session
     * @param {string} workspaceId
     * @param {string} sessionId
     * @param {SessionExecuteRequest} sessionExecuteRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeSessionCommand(
      workspaceId: string,
      sessionId: string,
      sessionExecuteRequest: SessionExecuteRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SessionExecuteResponse> {
      return localVarFp
        .executeSessionCommand(workspaceId, sessionId, sessionExecuteRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Search for text/pattern inside workspace files
     * @summary Search for text/pattern in files
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} pattern
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findInFiles(
      workspaceId: string,
      path: string,
      pattern: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<Match>> {
      return localVarFp
        .findInFiles(workspaceId, path, pattern, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get file info inside workspace
     * @summary Get file info
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileInfo(
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<FileInfo> {
      return localVarFp
        .getFileInfo(workspaceId, path, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get workspace project dir
     * @param {string} workspaceId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectDir(
      workspaceId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProjectDirResponse> {
      return localVarFp
        .getProjectDir(workspaceId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get session by ID
     * @summary Get session
     * @param {string} workspaceId
     * @param {string} sessionId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSession(
      workspaceId: string,
      sessionId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Session> {
      return localVarFp
        .getSession(workspaceId, sessionId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get session command by ID
     * @summary Get session command
     * @param {string} workspaceId
     * @param {string} sessionId
     * @param {string} commandId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionCommand(
      workspaceId: string,
      sessionId: string,
      commandId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Command> {
      return localVarFp
        .getSessionCommand(workspaceId, sessionId, commandId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get logs for a specific command in a session
     * @summary Get command logs
     * @param {string} workspaceId
     * @param {string} sessionId
     * @param {string} commandId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {boolean} [follow]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionCommandLogs(
      workspaceId: string,
      sessionId: string,
      commandId: string,
      xDaytonaOrganizationID?: string,
      follow?: boolean,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<string> {
      return localVarFp
        .getSessionCommandLogs(workspaceId, sessionId, commandId, xDaytonaOrganizationID, follow, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Add files to git commit
     * @summary Add files
     * @param {string} workspaceId
     * @param {GitAddRequest} gitAddRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitAddFiles(
      workspaceId: string,
      gitAddRequest: GitAddRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .gitAddFiles(workspaceId, gitAddRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Checkout branch or commit in git repository
     * @summary Checkout branch
     * @param {string} workspaceId
     * @param {GitCheckoutRequest} gitCheckoutRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCheckoutBranch(
      workspaceId: string,
      gitCheckoutRequest: GitCheckoutRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .gitCheckoutBranch(workspaceId, gitCheckoutRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Clone git repository
     * @summary Clone repository
     * @param {string} workspaceId
     * @param {GitCloneRequest} gitCloneRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCloneRepository(
      workspaceId: string,
      gitCloneRequest: GitCloneRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .gitCloneRepository(workspaceId, gitCloneRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Commit changes to git repository
     * @summary Commit changes
     * @param {string} workspaceId
     * @param {GitCommitRequest} gitCommitRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCommitChanges(
      workspaceId: string,
      gitCommitRequest: GitCommitRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GitCommitResponse> {
      return localVarFp
        .gitCommitChanges(workspaceId, gitCommitRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Create branch on git repository
     * @summary Create branch
     * @param {string} workspaceId
     * @param {GitBranchRequest} gitBranchRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitCreateBranch(
      workspaceId: string,
      gitBranchRequest: GitBranchRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .gitCreateBranch(workspaceId, gitBranchRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete branch on git repository
     * @summary Delete branch
     * @param {string} workspaceId
     * @param {GitDeleteBranchRequest} gitDeleteBranchRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitDeleteBranch(
      workspaceId: string,
      gitDeleteBranchRequest: GitDeleteBranchRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .gitDeleteBranch(workspaceId, gitDeleteBranchRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get commit history from git repository
     * @summary Get commit history
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitGetHistory(
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<GitCommitInfo>> {
      return localVarFp
        .gitGetHistory(workspaceId, path, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get status from git repository
     * @summary Get git status
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitGetStatus(
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GitStatus> {
      return localVarFp
        .gitGetStatus(workspaceId, path, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get branch list from git repository
     * @summary Get branch list
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitListBranches(
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ListBranchResponse> {
      return localVarFp
        .gitListBranches(workspaceId, path, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Pull changes from remote
     * @summary Pull changes
     * @param {string} workspaceId
     * @param {GitRepoRequest} gitRepoRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitPullChanges(
      workspaceId: string,
      gitRepoRequest: GitRepoRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .gitPullChanges(workspaceId, gitRepoRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Push changes to remote
     * @summary Push changes
     * @param {string} workspaceId
     * @param {GitRepoRequest} gitRepoRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gitPushChanges(
      workspaceId: string,
      gitRepoRequest: GitRepoRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .gitPushChanges(workspaceId, gitRepoRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List files
     * @param {string} workspaceId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {string} [path]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFiles(
      workspaceId: string,
      xDaytonaOrganizationID?: string,
      path?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<FileInfo>> {
      return localVarFp
        .listFiles(workspaceId, xDaytonaOrganizationID, path, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List all active sessions in the workspace
     * @summary List sessions
     * @param {string} workspaceId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSessions(
      workspaceId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<Session>> {
      return localVarFp
        .listSessions(workspaceId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * The Completion request is sent from the client to the server to compute completion items at a given cursor position.
     * @summary Get Lsp Completions
     * @param {string} workspaceId
     * @param {LspCompletionParams} lspCompletionParams
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspCompletions(
      workspaceId: string,
      lspCompletionParams: LspCompletionParams,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CompletionList> {
      return localVarFp
        .lspCompletions(workspaceId, lspCompletionParams, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * The document close notification is sent from the client to the server when the document got closed in the client.
     * @summary Call Lsp DidClose
     * @param {string} workspaceId
     * @param {LspDocumentRequest} lspDocumentRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspDidClose(
      workspaceId: string,
      lspDocumentRequest: LspDocumentRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .lspDidClose(workspaceId, lspDocumentRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * The document open notification is sent from the client to the server to signal newly opened text documents.
     * @summary Call Lsp DidOpen
     * @param {string} workspaceId
     * @param {LspDocumentRequest} lspDocumentRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspDidOpen(
      workspaceId: string,
      lspDocumentRequest: LspDocumentRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .lspDidOpen(workspaceId, lspDocumentRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * The document symbol request is sent from the client to the server.
     * @summary Call Lsp DocumentSymbols
     * @param {string} workspaceId
     * @param {string} languageId
     * @param {string} pathToProject
     * @param {string} uri
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspDocumentSymbols(
      workspaceId: string,
      languageId: string,
      pathToProject: string,
      uri: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<LspSymbol>> {
      return localVarFp
        .lspDocumentSymbols(workspaceId, languageId, pathToProject, uri, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Start Lsp server process inside workspace project
     * @summary Start Lsp server
     * @param {string} workspaceId
     * @param {LspServerRequest} lspServerRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspStart(
      workspaceId: string,
      lspServerRequest: LspServerRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .lspStart(workspaceId, lspServerRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Stop Lsp server process inside workspace project
     * @summary Stop Lsp server
     * @param {string} workspaceId
     * @param {LspServerRequest} lspServerRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspStop(
      workspaceId: string,
      lspServerRequest: LspServerRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .lspStop(workspaceId, lspServerRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.
     * @summary Call Lsp WorkspaceSymbols
     * @param {string} workspaceId
     * @param {string} languageId
     * @param {string} pathToProject
     * @param {string} query
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lspWorkspaceSymbols(
      workspaceId: string,
      languageId: string,
      pathToProject: string,
      query: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<LspSymbol>> {
      return localVarFp
        .lspWorkspaceSymbols(workspaceId, languageId, pathToProject, query, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Move file inside workspace
     * @summary Move file
     * @param {string} workspaceId
     * @param {string} source
     * @param {string} destination
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moveFile(
      workspaceId: string,
      source: string,
      destination: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .moveFile(workspaceId, source, destination, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Replace text/pattern in multiple files inside workspace
     * @summary Replace in files
     * @param {string} workspaceId
     * @param {ReplaceRequest} replaceRequest
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceInFiles(
      workspaceId: string,
      replaceRequest: ReplaceRequest,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ReplaceResult>> {
      return localVarFp
        .replaceInFiles(workspaceId, replaceRequest, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Search for files inside workspace
     * @summary Search files
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} pattern
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchFiles(
      workspaceId: string,
      path: string,
      pattern: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SearchFilesResponse> {
      return localVarFp
        .searchFiles(workspaceId, path, pattern, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Set file owner/group/permissions inside workspace
     * @summary Set file permissions
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {string} [owner]
     * @param {string} [group]
     * @param {string} [mode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFilePermissions(
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      owner?: string,
      group?: string,
      mode?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .setFilePermissions(workspaceId, path, xDaytonaOrganizationID, owner, group, mode, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Upload file inside workspace
     * @summary Upload file
     * @param {string} workspaceId
     * @param {string} path
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {File} [file]
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    uploadFile(
      workspaceId: string,
      path: string,
      xDaytonaOrganizationID?: string,
      file?: File,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .uploadFile(workspaceId, path, xDaytonaOrganizationID, file, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Upload multiple files inside workspace
     * @summary Upload multiple files
     * @param {string} workspaceId
     * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFiles(
      workspaceId: string,
      xDaytonaOrganizationID?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .uploadFiles(workspaceId, xDaytonaOrganizationID, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ToolboxApi - object-oriented interface
 * @export
 * @class ToolboxApi
 * @extends {BaseAPI}
 */
export class ToolboxApi extends BaseAPI {
  /**
   * Create folder inside workspace
   * @summary Create folder
   * @param {string} workspaceId
   * @param {string} path
   * @param {string} mode
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public createFolder(
    workspaceId: string,
    path: string,
    mode: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .createFolder(workspaceId, path, mode, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Create a new session in the workspace
   * @summary Create session
   * @param {string} workspaceId
   * @param {CreateSessionRequest} createSessionRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public createSession(
    workspaceId: string,
    createSessionRequest: CreateSessionRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .createSession(workspaceId, createSessionRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete file inside workspace
   * @summary Delete file
   * @param {string} workspaceId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public deleteFile(
    workspaceId: string,
    path: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .deleteFile(workspaceId, path, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete a specific session
   * @summary Delete session
   * @param {string} workspaceId
   * @param {string} sessionId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public deleteSession(
    workspaceId: string,
    sessionId: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .deleteSession(workspaceId, sessionId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Download file from workspace
   * @summary Download file
   * @param {string} workspaceId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public downloadFile(
    workspaceId: string,
    path: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .downloadFile(workspaceId, path, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Execute command synchronously inside workspace
   * @summary Execute command
   * @param {string} workspaceId
   * @param {ExecuteRequest} executeRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public executeCommand(
    workspaceId: string,
    executeRequest: ExecuteRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .executeCommand(workspaceId, executeRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Execute a command in a specific session
   * @summary Execute command in session
   * @param {string} workspaceId
   * @param {string} sessionId
   * @param {SessionExecuteRequest} sessionExecuteRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public executeSessionCommand(
    workspaceId: string,
    sessionId: string,
    sessionExecuteRequest: SessionExecuteRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .executeSessionCommand(workspaceId, sessionId, sessionExecuteRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Search for text/pattern inside workspace files
   * @summary Search for text/pattern in files
   * @param {string} workspaceId
   * @param {string} path
   * @param {string} pattern
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public findInFiles(
    workspaceId: string,
    path: string,
    pattern: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .findInFiles(workspaceId, path, pattern, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get file info inside workspace
   * @summary Get file info
   * @param {string} workspaceId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public getFileInfo(
    workspaceId: string,
    path: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .getFileInfo(workspaceId, path, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get workspace project dir
   * @param {string} workspaceId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public getProjectDir(workspaceId: string, xDaytonaOrganizationID?: string, options?: RawAxiosRequestConfig) {
    return ToolboxApiFp(this.configuration)
      .getProjectDir(workspaceId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get session by ID
   * @summary Get session
   * @param {string} workspaceId
   * @param {string} sessionId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public getSession(
    workspaceId: string,
    sessionId: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .getSession(workspaceId, sessionId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get session command by ID
   * @summary Get session command
   * @param {string} workspaceId
   * @param {string} sessionId
   * @param {string} commandId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public getSessionCommand(
    workspaceId: string,
    sessionId: string,
    commandId: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .getSessionCommand(workspaceId, sessionId, commandId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get logs for a specific command in a session
   * @summary Get command logs
   * @param {string} workspaceId
   * @param {string} sessionId
   * @param {string} commandId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {boolean} [follow]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public getSessionCommandLogs(
    workspaceId: string,
    sessionId: string,
    commandId: string,
    xDaytonaOrganizationID?: string,
    follow?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .getSessionCommandLogs(workspaceId, sessionId, commandId, xDaytonaOrganizationID, follow, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Add files to git commit
   * @summary Add files
   * @param {string} workspaceId
   * @param {GitAddRequest} gitAddRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public gitAddFiles(
    workspaceId: string,
    gitAddRequest: GitAddRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .gitAddFiles(workspaceId, gitAddRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Checkout branch or commit in git repository
   * @summary Checkout branch
   * @param {string} workspaceId
   * @param {GitCheckoutRequest} gitCheckoutRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public gitCheckoutBranch(
    workspaceId: string,
    gitCheckoutRequest: GitCheckoutRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .gitCheckoutBranch(workspaceId, gitCheckoutRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Clone git repository
   * @summary Clone repository
   * @param {string} workspaceId
   * @param {GitCloneRequest} gitCloneRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public gitCloneRepository(
    workspaceId: string,
    gitCloneRequest: GitCloneRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .gitCloneRepository(workspaceId, gitCloneRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Commit changes to git repository
   * @summary Commit changes
   * @param {string} workspaceId
   * @param {GitCommitRequest} gitCommitRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public gitCommitChanges(
    workspaceId: string,
    gitCommitRequest: GitCommitRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .gitCommitChanges(workspaceId, gitCommitRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Create branch on git repository
   * @summary Create branch
   * @param {string} workspaceId
   * @param {GitBranchRequest} gitBranchRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public gitCreateBranch(
    workspaceId: string,
    gitBranchRequest: GitBranchRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .gitCreateBranch(workspaceId, gitBranchRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete branch on git repository
   * @summary Delete branch
   * @param {string} workspaceId
   * @param {GitDeleteBranchRequest} gitDeleteBranchRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public gitDeleteBranch(
    workspaceId: string,
    gitDeleteBranchRequest: GitDeleteBranchRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .gitDeleteBranch(workspaceId, gitDeleteBranchRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get commit history from git repository
   * @summary Get commit history
   * @param {string} workspaceId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public gitGetHistory(
    workspaceId: string,
    path: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .gitGetHistory(workspaceId, path, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get status from git repository
   * @summary Get git status
   * @param {string} workspaceId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public gitGetStatus(
    workspaceId: string,
    path: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .gitGetStatus(workspaceId, path, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get branch list from git repository
   * @summary Get branch list
   * @param {string} workspaceId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public gitListBranches(
    workspaceId: string,
    path: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .gitListBranches(workspaceId, path, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Pull changes from remote
   * @summary Pull changes
   * @param {string} workspaceId
   * @param {GitRepoRequest} gitRepoRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public gitPullChanges(
    workspaceId: string,
    gitRepoRequest: GitRepoRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .gitPullChanges(workspaceId, gitRepoRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Push changes to remote
   * @summary Push changes
   * @param {string} workspaceId
   * @param {GitRepoRequest} gitRepoRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public gitPushChanges(
    workspaceId: string,
    gitRepoRequest: GitRepoRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .gitPushChanges(workspaceId, gitRepoRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List files
   * @param {string} workspaceId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {string} [path]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public listFiles(
    workspaceId: string,
    xDaytonaOrganizationID?: string,
    path?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .listFiles(workspaceId, xDaytonaOrganizationID, path, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List all active sessions in the workspace
   * @summary List sessions
   * @param {string} workspaceId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public listSessions(workspaceId: string, xDaytonaOrganizationID?: string, options?: RawAxiosRequestConfig) {
    return ToolboxApiFp(this.configuration)
      .listSessions(workspaceId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * The Completion request is sent from the client to the server to compute completion items at a given cursor position.
   * @summary Get Lsp Completions
   * @param {string} workspaceId
   * @param {LspCompletionParams} lspCompletionParams
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public lspCompletions(
    workspaceId: string,
    lspCompletionParams: LspCompletionParams,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .lspCompletions(workspaceId, lspCompletionParams, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * The document close notification is sent from the client to the server when the document got closed in the client.
   * @summary Call Lsp DidClose
   * @param {string} workspaceId
   * @param {LspDocumentRequest} lspDocumentRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public lspDidClose(
    workspaceId: string,
    lspDocumentRequest: LspDocumentRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .lspDidClose(workspaceId, lspDocumentRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * The document open notification is sent from the client to the server to signal newly opened text documents.
   * @summary Call Lsp DidOpen
   * @param {string} workspaceId
   * @param {LspDocumentRequest} lspDocumentRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public lspDidOpen(
    workspaceId: string,
    lspDocumentRequest: LspDocumentRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .lspDidOpen(workspaceId, lspDocumentRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * The document symbol request is sent from the client to the server.
   * @summary Call Lsp DocumentSymbols
   * @param {string} workspaceId
   * @param {string} languageId
   * @param {string} pathToProject
   * @param {string} uri
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public lspDocumentSymbols(
    workspaceId: string,
    languageId: string,
    pathToProject: string,
    uri: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .lspDocumentSymbols(workspaceId, languageId, pathToProject, uri, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Start Lsp server process inside workspace project
   * @summary Start Lsp server
   * @param {string} workspaceId
   * @param {LspServerRequest} lspServerRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public lspStart(
    workspaceId: string,
    lspServerRequest: LspServerRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .lspStart(workspaceId, lspServerRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Stop Lsp server process inside workspace project
   * @summary Stop Lsp server
   * @param {string} workspaceId
   * @param {LspServerRequest} lspServerRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public lspStop(
    workspaceId: string,
    lspServerRequest: LspServerRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .lspStop(workspaceId, lspServerRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.
   * @summary Call Lsp WorkspaceSymbols
   * @param {string} workspaceId
   * @param {string} languageId
   * @param {string} pathToProject
   * @param {string} query
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public lspWorkspaceSymbols(
    workspaceId: string,
    languageId: string,
    pathToProject: string,
    query: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .lspWorkspaceSymbols(workspaceId, languageId, pathToProject, query, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Move file inside workspace
   * @summary Move file
   * @param {string} workspaceId
   * @param {string} source
   * @param {string} destination
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public moveFile(
    workspaceId: string,
    source: string,
    destination: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .moveFile(workspaceId, source, destination, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Replace text/pattern in multiple files inside workspace
   * @summary Replace in files
   * @param {string} workspaceId
   * @param {ReplaceRequest} replaceRequest
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public replaceInFiles(
    workspaceId: string,
    replaceRequest: ReplaceRequest,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .replaceInFiles(workspaceId, replaceRequest, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Search for files inside workspace
   * @summary Search files
   * @param {string} workspaceId
   * @param {string} path
   * @param {string} pattern
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public searchFiles(
    workspaceId: string,
    path: string,
    pattern: string,
    xDaytonaOrganizationID?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .searchFiles(workspaceId, path, pattern, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Set file owner/group/permissions inside workspace
   * @summary Set file permissions
   * @param {string} workspaceId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {string} [owner]
   * @param {string} [group]
   * @param {string} [mode]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public setFilePermissions(
    workspaceId: string,
    path: string,
    xDaytonaOrganizationID?: string,
    owner?: string,
    group?: string,
    mode?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .setFilePermissions(workspaceId, path, xDaytonaOrganizationID, owner, group, mode, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Upload file inside workspace
   * @summary Upload file
   * @param {string} workspaceId
   * @param {string} path
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {File} [file]
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public uploadFile(
    workspaceId: string,
    path: string,
    xDaytonaOrganizationID?: string,
    file?: File,
    options?: RawAxiosRequestConfig,
  ) {
    return ToolboxApiFp(this.configuration)
      .uploadFile(workspaceId, path, xDaytonaOrganizationID, file, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Upload multiple files inside workspace
   * @summary Upload multiple files
   * @param {string} workspaceId
   * @param {string} [xDaytonaOrganizationID] Use with JWT to specify the organization ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolboxApi
   */
  public uploadFiles(workspaceId: string, xDaytonaOrganizationID?: string, options?: RawAxiosRequestConfig) {
    return ToolboxApiFp(this.configuration)
      .uploadFiles(workspaceId, xDaytonaOrganizationID, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
