#!/usr/bin/env python3

# Copyright 2025 Daytona Platforms Inc.
# SPDX-License-Identifier: AGPL-3.0

"""
Script to convert async code to sync code using the unasync library.

This script transforms files from the _async folder to the _sync folder,
converting async/await patterns to synchronous equivalents, while:
  - preserving regions marked by # unasync: preserve start / # unasync: preserve end
  - dropping regions marked by # unasync: delete start / # unasync: delete end
  - stripping all Awaitable[...] and cleaning up Awaitable imports
  - replacing aiofiles.open calls with built-in open and removing aiofiles imports
  - translating await asyncio.to_thread(...) calls into direct method calls
  - removing unused asyncio imports
  - converting `await process_streaming_response(...)` into `asyncio.run(process_streaming_response(...))`
  - wrapping any unwrapped calls to `process_streaming_response(...)` in `asyncio.run(...)`
    (but not when `process_streaming_response` appears inside an import statement)
"""

import logging
import re
import sys
import tempfile
from pathlib import Path

import unasync

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(message)s")
logger = logging.getLogger(__name__)

# Project paths
project_root = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(project_root))

SOURCE_DIR = project_root / "src" / "daytona" / "_async"
TARGET_DIR = project_root / "src" / "daytona" / "_sync"

# Regex markers for blocks
MARKERS = {
    "preserve_start": re.compile(r"^\s*#\s*unasync:\s*preserve\s+start"),
    "preserve_end": re.compile(r"^\s*#\s*unasync:\s*preserve\s+end"),
    "delete_start": re.compile(r"^\s*#\s*unasync:\s*delete\s+start"),
    "delete_end": re.compile(r"^\s*#\s*unasync:\s*delete\s+end"),
}

# Simple token maps for unasync
ADDITIONAL_REPLACEMENTS = {
    # Async/await syntax
    "async def": "def",
    "async with": "with",
    "async for": "for",
    "await ": "",
    # Module & class renames
    "daytona_api_client_async": "daytona_api_client",
    "AsyncVolumeService": "VolumeService",
    "AsyncFileSystem": "FileSystem",
    "AsyncGit": "Git",
    "AsyncLspServer": "LspServer",
    "AsyncProcess": "Process",
    "AsyncDaytona": "Daytona",
    "AsyncSandbox": "Sandbox",
    # aiofiles replacement
    "aiofiles.open": "open",
    # aioboto3 replacement
    "aioboto3": "boto3",
}

# Complex regex-based tweaks
PRE_REPLACEMENTS = [
    (re.compile(r"\bAsync([A-Z]\w*)\b"), r"\1"),
]
POST_REPLACEMENTS = [
    # Remove any remaining 'await ' (including in docstrings)
    (re.compile(r"\bawait\s+"), ""),
    # Strip Sync prefix
    (re.compile(r"\bSync([A-Z]\w*)\b"), r"\1"),
    # httpx client fix
    (re.compile(r"httpx\.SyncClient\b"), "httpx.Client"),
    # Update module imports
    (re.compile(r"from daytona\._async"), "from daytona._sync"),
    # Documentation cleanup
    (re.compile(r"\basynchronous methods\b"), "methods"),
    (re.compile(r"\basynchronous\b"), "synchronous"),
    (re.compile(r"\basynchronously\b"), ""),
    # Replace aiofiles.open with built-in open
    (re.compile(r"\baiofiles\.open\b"), "open"),
    # Remove aiofiles imports
    (re.compile(r"^import aiofiles\s*$", flags=re.MULTILINE), ""),
    (re.compile(r"^from aiofiles(?:\.[\w_]+)? import .+$", flags=re.MULTILINE), ""),
]

# Auto-generation banner
AUTO_GEN_WARNING = (
    "# DO NOT EDIT THIS FILE MANUALLY.\n"
    "# This file is auto-generated by the unasync conversion script.\n"
    "# Edit the async source and re-run this script.\n\n"
)


def find_license_end(lines):
    """Locate end of license/header to inject banner."""
    license_end = 0
    for i, line in enumerate(lines):
        stripped = line.strip()
        if not stripped or stripped.startswith("#!") or stripped.startswith("#"):
            license_end = i + 1
        else:
            break
    return license_end


def transform_docstrings(text: str) -> str:
    """
    Transform docstrings so that code-block examples are converted from async to sync:
    1. async with AsyncDaytona() as var: -> var = Daytona()
    2. try/finally blocks with only daytona.close() -> remove try/finally, unindent body
    3. try/finally blocks with other content -> remove only daytona.close() line
    4. Properly handle indentation for all cases
    """

    def process_python_code_block(match):
        """Process individual ```python ... ``` blocks"""
        block = match.group(0)
        lines = block.split("\n")

        if len(lines) < 2:
            return block

        result_lines = [lines[0]]  # Keep opening fence
        i = 1

        while i < len(lines):
            line = lines[i]

            # Check for closing fence
            if line.strip() == "```":
                result_lines.append(line)
                break

            # Handle async with pattern
            async_with_match = re.match(
                r"^(\s*)async\s+with\s+(?:Async)?Daytona\(\)(?:\([^)]*\))?\s+as\s+(\w+):\s*(#.*)?$", line
            )
            if async_with_match:
                indent, var_name, comment = async_with_match.groups()
                # Transform to variable assignment
                new_line = f"{indent}{var_name} = Daytona()"
                if comment:
                    new_line += f"  {comment}"
                result_lines.append(new_line)

                # Process the block content, reducing indentation by 4 spaces
                i += 1
                async_with_indent = len(indent)

                while i < len(lines):
                    line = lines[i]

                    # Check for closing fence
                    if line.strip() == "```":
                        result_lines.append(line)
                        i = len(lines)  # Exit outer loop too
                        break

                    # Check if we've exited the async with block
                    line_indent = len(line) - len(line.lstrip()) if line.strip() else 0
                    if line.strip() and line_indent <= async_with_indent:
                        # We've exited the async with block, process this line normally
                        # Don't increment i here, let the outer loop handle it
                        break

                    # Reduce indentation by 4 spaces for lines inside async with
                    if line.strip():  # Skip empty lines
                        if line.startswith(" " * (async_with_indent + 4)):
                            new_line = line[4:]  # Remove 4 spaces
                        else:
                            new_line = line  # Keep as is if indentation is unexpected
                    else:
                        new_line = line  # Keep empty lines as is

                    result_lines.append(new_line)
                    i += 1
                continue

            # Handle try/finally blocks
            if line.strip() == "try:":
                try_indent = len(line) - len(line.lstrip())

                # Look for finally block
                j = i + 1
                finally_idx = None
                while j < len(lines):
                    if lines[j].strip() == "```":
                        break
                    if lines[j].strip() == "finally:":
                        finally_line_indent = len(lines[j]) - len(lines[j].lstrip())
                        if finally_line_indent == try_indent:
                            finally_idx = j
                            break
                    j += 1

                if finally_idx is not None:
                    # Check what's in the finally block
                    finally_content = []
                    k = finally_idx + 1
                    while k < len(lines):
                        if lines[k].strip() == "```":
                            break
                        finally_line_indent = len(lines[k]) - len(lines[k].lstrip()) if lines[k].strip() else 0
                        if lines[k].strip() and finally_line_indent <= try_indent:
                            break
                        finally_content.append(lines[k])
                        k += 1

                    # Check if finally only contains daytona.close()
                    non_empty_finally = [l for l in finally_content if l.strip()]
                    only_has_close = len(non_empty_finally) == 1 and (
                        re.search(r"daytona\w*\.close\(\)", non_empty_finally[0])
                        or re.search(r"await\s+daytona\w*\.close\(\)", non_empty_finally[0])
                    )

                    if only_has_close:
                        # Remove try/finally, unindent try body
                        # Skip the 'try:' line
                        i += 1

                        # Process try body with reduced indentation
                        while i < finally_idx:
                            line = lines[i]
                            if line.strip():  # Skip empty lines
                                if line.startswith(" " * (try_indent + 4)):
                                    new_line = " " * try_indent + line[try_indent + 4 :]
                                else:
                                    new_line = line
                            else:
                                new_line = line
                            result_lines.append(new_line)
                            i += 1

                        # Skip the finally block
                        i = k
                        continue
                    # Keep try/finally but remove daytona.close() lines
                    result_lines.append(line)  # Add 'try:' line
                    i += 1

                    # Add try body
                    while i < finally_idx:
                        result_lines.append(lines[i])
                        i += 1

                    # Add 'finally:' line
                    result_lines.append(lines[i])
                    i += 1

                    # Add finally body, filtering out daytona.close()
                    while i < k:
                        line = lines[i]
                        if not re.search(r"(?:await\s+)?daytona\w*\.close\(\)", line):
                            result_lines.append(line)
                        i += 1
                    continue

            # Regular line processing
            result_lines.append(line)
            i += 1

        return "\n".join(result_lines)

    # Process all python code blocks
    text = re.sub(r"(^[ \t]*```python\n.*?^[ \t]*```)", process_python_code_block, text, flags=re.MULTILINE | re.DOTALL)

    # Remove any stray daytona.close() lines outside code blocks
    text = re.sub(r"^\s*(?:await\s+)?daytona\w*\.close\(\)\s*$", "", text, flags=re.MULTILINE)

    # Clean up multiple blank lines
    text = re.sub(r"\n\s*\n\s*\n", "\n\n", text)

    # Remove await keywords outside code blocks
    text = re.sub(r"\bawait\s+", "", text)

    return text


def pre_filter(src: Path, dst: Path) -> dict:
    """
    Copy src to dst, removing delete-blocks and preserving verbatim sections.
    Returns a map of placeholder→block for all # unasync: preserve … blocks.
    """
    lines = src.read_text(encoding="utf-8").splitlines(keepends=True)
    out, block_map = [], {}
    buf, idx = [], 0
    in_preserve = in_delete = False

    for line in lines:
        if MARKERS["delete_start"].match(line):
            in_delete = True
            continue
        if MARKERS["delete_end"].match(line):
            in_delete = False
            continue
        if in_delete:
            continue
        if MARKERS["preserve_start"].match(line):
            in_preserve = True
            buf.clear()
            continue
        if MARKERS["preserve_end"].match(line):
            in_preserve = False
            placeholder = f"# UNASYNC_SKIP_BLOCK_{idx}\n"
            block_map[placeholder] = "".join(buf)
            out.append(placeholder)
            idx += 1
            continue
        if in_preserve:
            buf.append(line)
        else:
            out.append(line)

    dst.write_text("".join(out), encoding="utf-8")
    return block_map


def apply_replacements(text: str, replacements: list) -> str:
    """
    Apply a list of (pattern, replacement) to every line in 'text',
    skipping lines that contain 'run_async' (we never want to rewrite those).
    """
    lines = text.splitlines(keepends=True)
    processed = []
    for line in lines:
        if "run_async" in line:
            processed.append(line)
        else:
            tmp = line
            for pat, repl in replacements:
                tmp = pat.sub(repl, tmp)
            processed.append(tmp)
    return "".join(processed)


def replace_all_to_thread_calls(text: str) -> str:
    """
    Translate all occurrences of:
      await asyncio.to_thread(func_expr, arg1, arg2, ...)
    into:
      func_expr(arg1, arg2, ...)
    """

    result_parts = []
    i = 0
    while True:
        idx = text.find("asyncio.to_thread", i)
        if idx == -1:
            # No more occurrences; append the remaining text
            result_parts.append(text[i:])
            break

        # Append text up to the match
        result_parts.append(text[i:idx])

        # Find the opening parenthesis after "asyncio.to_thread"
        start_paren = text.find("(", idx)
        if start_paren == -1:
            # Malformed usage; just skip it
            i = idx + len("asyncio.to_thread")
            result_parts.append(text[idx:i])
            continue

        # Find the matching closing parenthesis
        paren_count = 0
        j = start_paren
        end_paren = None
        while j < len(text):
            if text[j] == "(":
                paren_count += 1
            elif text[j] == ")":
                paren_count -= 1
                if paren_count == 0:
                    end_paren = j
                    break
            j += 1

        if end_paren is None:
            # No matching closing parenthesis; skip
            i = idx
            result_parts.append(text[idx : idx + 1])
            continue

        # Extract the inside of the parentheses
        inside = text[start_paren + 1 : end_paren]

        # Split inside into function expression and arguments at top-level comma
        func_expr = ""
        rest_args = ""
        par = 0
        split_index = None
        for k, ch in enumerate(inside):
            if ch == "(":
                par += 1
            elif ch == ")":
                par -= 1
            elif ch == "," and par == 0:
                split_index = k
                break

        if split_index is not None:
            func_expr = inside[:split_index].strip()
            rest_args = inside[split_index + 1 :].strip()
        else:
            func_expr = inside.strip()
            rest_args = ""

        # Construct replacement text
        if rest_args:
            replacement = f"{func_expr}({rest_args})"
        else:
            replacement = f"{func_expr}()"

        result_parts.append(replacement)
        i = end_paren + 1

    return "".join(result_parts)


def replace_await_process_streaming(text: str) -> str:
    """
    Replace occurrences of:
      await process_streaming_response(...)

    with:
      asyncio.run(process_streaming_response(...))
    """
    result = []
    i = 0
    pattern = "await process_streaming_response"
    plen = len(pattern)

    while True:
        idx = text.find(pattern, i)
        if idx == -1:
            result.append(text[i:])
            break

        # Append text up to the match
        result.append(text[i:idx])

        # Find the opening parenthesis after the pattern
        start_paren = text.find("(", idx + plen)
        if start_paren == -1:
            # Malformed usage; just copy pattern and move on
            result.append(pattern)
            i = idx + plen
            continue

        # Now find the matching closing parenthesis for this call
        paren_count = 0
        j = start_paren
        end_paren = None
        while j < len(text):
            if text[j] == "(":
                paren_count += 1
            elif text[j] == ")":
                paren_count -= 1
                if paren_count == 0:
                    end_paren = j
                    break
            j += 1

        if end_paren is None:
            # Unbalanced parentheses; copy pattern and move on
            result.append(pattern)
            i = idx + plen
            continue

        # Extract the inside of the parentheses
        call_args = text[start_paren + 1 : end_paren]

        # Reconstruct the replacement:
        #   "asyncio.run(process_streaming_response(" + call_args + "))"
        replacement = f"asyncio.run(process_streaming_response({call_args}))"
        result.append(replacement)

        # Advance i past the original call
        i = end_paren + 1

    return "".join(result)


def replace_unwrapped_process_streaming(text: str) -> str:
    """
    Wrap standalone calls to process_streaming_response(...) with asyncio.run(...)
    if they are not already wrapped, and skip wrapping in import statements.
    """
    result_parts = []
    i = 0
    func_name = "process_streaming_response"
    wrapper_prefix = "asyncio.run("
    length_name = len(func_name)

    while True:
        idx = text.find(func_name, i)
        if idx == -1:
            result_parts.append(text[i:])
            break

        # Append text up to this occurrence
        result_parts.append(text[i:idx])

        # Determine the start of the current line
        line_start = text.rfind("\n", 0, idx) + 1
        line_prefix = text[line_start:idx].lstrip()

        # If this occurrence is inside an import statement, skip wrapping
        if line_prefix.startswith("import ") or line_prefix.startswith("from "):
            # Find end of this occurrence (skip over the function name and any following "()")
            j = idx + length_name
            # If next non-space character is '(', skip to matching ')'
            while j < len(text) and text[j].isspace():
                j += 1
            if j < len(text) and text[j] == "(":
                paren_count = 0
                k = j
                while k < len(text):
                    if text[k] == "(":
                        paren_count += 1
                    elif text[k] == ")":
                        paren_count -= 1
                        if paren_count == 0:
                            j = k + 1
                            break
                    k += 1
            result_parts.append(text[idx:j])
            i = j
            continue

        # Find opening parenthesis after the function name
        start_paren = text.find("(", idx + length_name)
        if start_paren == -1:
            # No parenthesis, skip this occurrence
            result_parts.append(text[idx : idx + length_name])
            i = idx + length_name
            continue

        # Find matching closing parenthesis
        paren_count = 0
        j = start_paren
        end_paren = None
        while j < len(text):
            if text[j] == "(":
                paren_count += 1
            elif text[j] == ")":
                paren_count -= 1
                if paren_count == 0:
                    end_paren = j
                    break
            j += 1
        if end_paren is None:
            # Unbalanced parentheses, copy as is and move on
            result_parts.append(text[idx : idx + length_name])
            i = idx + length_name
            continue

        # Check if already wrapped in asyncio.run(
        head = text[:idx]
        if re.search(r"asyncio\.run\s*\(\s*$", head):
            # Already within an asyncio.run(, so do not wrap
            result_parts.append(text[idx : end_paren + 1])
            i = end_paren + 1
            continue

        # Otherwise, wrap the call
        original_call = text[idx : end_paren + 1]
        wrapped = f"{wrapper_prefix}{original_call})"
        result_parts.append(wrapped)
        i = end_paren + 1

    return "".join(result_parts)


def manage_asyncio_imports(text: str) -> str:
    """
    Manage asyncio imports based on usage:
    - If asyncio is used in the text but not imported, add "import asyncio"
    - If asyncio is not used, remove any existing asyncio imports
    """
    lines = text.splitlines(keepends=True)

    # Check if asyncio is used anywhere in the text (excluding import lines)
    asyncio_used = False
    non_import_text = ""
    for line in lines:
        if not (line.strip().startswith("import asyncio") or line.strip().startswith("from asyncio import")):
            non_import_text += line

    if re.search(r"\basyncio\.", non_import_text):
        asyncio_used = True

    # Check if asyncio is already imported
    has_asyncio_import = False
    import_asyncio_line_idx = None

    new_lines = []
    for i, line in enumerate(lines):
        # Check for existing asyncio imports
        if re.match(r"^\s*import asyncio\s*$", line):
            has_asyncio_import = True
            if asyncio_used:
                new_lines.append(line)  # Keep the import
            # else: skip this line (remove unused import)
            continue

        # Check for "from asyncio import X, Y" - remove if not used
        m = re.match(r"^\s*from asyncio import (.+)$", line)
        if m:
            if asyncio_used:
                # Keep specific imports only if those specific names are used
                imported = [imp.strip() for imp in m.group(1).split(",")]
                used_imports = []
                for imp in imported:
                    pattern = rf"\b{re.escape(imp)}\b"
                    if re.search(pattern, non_import_text):
                        used_imports.append(imp)

                if used_imports:
                    new_lines.append(f"from asyncio import {', '.join(used_imports)}\n")
            # else: skip this line (remove unused import)
            continue

        new_lines.append(line)

        # Track where we could insert import asyncio (after other imports)
        if (
            not has_asyncio_import
            and import_asyncio_line_idx is None
            and line.strip()
            and not line.strip().startswith("#")
            and not line.strip().startswith("import")
            and not line.strip().startswith("from")
        ):
            import_asyncio_line_idx = len(new_lines) - 1

    # If asyncio is used but not imported, add the import
    if asyncio_used and not has_asyncio_import:
        if import_asyncio_line_idx is not None:
            # Insert after the last import but before other code
            # Find the best position - after imports but before other code
            insert_idx = 0
            for i, line in enumerate(new_lines):
                if (
                    line.strip().startswith("import")
                    or line.strip().startswith("from")
                    or line.strip().startswith("#")
                    or not line.strip()
                ):
                    insert_idx = i + 1
                else:
                    break
            new_lines.insert(insert_idx, "import asyncio\n")
        else:
            # If no good position found, add at the beginning after license/comments
            license_end = 0
            for i, line in enumerate(new_lines):
                stripped = line.strip()
                if not stripped or stripped.startswith("#"):
                    license_end = i + 1
                else:
                    break
            new_lines.insert(license_end, "import asyncio\n")

    return "".join(new_lines)


def restore_blocks(path: Path, block_map: dict):
    """
    Replace each placeholder "# UNASYNC_SKIP_BLOCK_n" with its original preserved block.
    """
    content = path.read_text(encoding="utf-8")
    for placeholder, block in block_map.items():
        content = content.replace(placeholder, block)
    path.write_text(content, encoding="utf-8")


def post_process(path: Path):
    """
    1) Call transform_docstrings()
    2) Apply POST_REPLACEMENTS (strip 'await', rename imports, etc.)
    3) Translate await asyncio.to_thread(...) calls
    4) Convert await process_streaming_response(...) calls
    5) Wrap any unwrapped process_streaming_response(...) calls
    6) Strip Awaitable[...] wrappers
    7) Clean up typing imports
    8) Remove any leftover daytona.close() lines
    9) Collapse >2 blank lines into exactly 2
    10) Manage asyncio imports (add if needed based on usage, remove if unused)
    11) Inject auto‐gen banner if missing
    """
    text = path.read_text(encoding="utf-8")
    original = text

    # 1) Transform docstrings so that code‐block examples go from async→sync
    text = transform_docstrings(text)

    # 2) Apply simple regex‐based post‐replacements (strip 'await', rename imports, etc.)
    text = apply_replacements(text, POST_REPLACEMENTS)

    # 3) Translate any "await asyncio.to_thread(...)" calls into direct calls
    text = replace_all_to_thread_calls(text)

    # 4) Convert "await process_streaming_response(...)" calls into "asyncio.run(...)"
    text = replace_await_process_streaming(text)

    # 5) Wrap any unwrapped "process_streaming_response(...)" calls with asyncio.run(...)
    #    (skipping lines where it appears inside an import statement)
    text = replace_unwrapped_process_streaming(text)

    # 6) Strip type Awaitable[...] wrappers
    text = re.sub(r"Awaitable\[(.*?)\]", r"\1", text)

    # 7) Clean up typing imports, dropping "Awaitable"
    def clean_imports(m):
        imps = [i.strip() for i in m.group(1).split(",") if i.strip() != "Awaitable"]
        return f"from typing import {', '.join(imps)}" if imps else ""

    text = re.sub(
        r"^from typing import (.+)$",
        clean_imports,
        text,
        flags=re.MULTILINE,
    )

    # 8) Remove any leftover "daytona.close()" lines
    text = re.sub(r"^\s*daytona\w*\.close\(\)\s*$", "", text, flags=re.MULTILINE)

    # 9) Collapse more than two blank lines into exactly two
    text = re.sub(r"\n\s*\n\s*\n", "\n\n", text)

    # 10) Manage asyncio imports (add if needed based on usage, remove if unused)
    text = manage_asyncio_imports(text)

    # 11) Inject auto‐gen banner if it's missing in the first few lines
    lines = text.splitlines(keepends=True)
    if not any("auto-generated by the unasync conversion script" in l for l in lines[:10]):
        idx = find_license_end(lines)
        lines.insert(idx, AUTO_GEN_WARNING)
        text = "".join(lines)

    if text != original:
        path.write_text(text, encoding="utf-8")
        logger.info(f"  Post-processed: {path.name}")


def main():
    TARGET_DIR.mkdir(parents=True, exist_ok=True)
    async_files = [f for f in SOURCE_DIR.glob("*.py") if not f.name.startswith("__")]

    with tempfile.TemporaryDirectory() as tmpdir:
        tmp_dir = Path(tmpdir)
        sync_tmp = tmp_dir / "sync"
        sync_tmp.mkdir()

        # 1) Pre‐filter each async file: strip out delete-blocks, capture preserve-blocks
        placeholders = {}
        for src in async_files:
            tmp_file = tmp_dir / src.name
            placeholders[src.name] = pre_filter(src, tmp_file)
            txt = tmp_file.read_text(encoding="utf-8")
            # 2) Apply PRE_REPLACEMENTS (strip "AsyncX" → "X", etc.)
            tmp_file.write_text(apply_replacements(txt, PRE_REPLACEMENTS), encoding="utf-8")

        # 3) Run unasync to create raw sync files
        rule = unasync.Rule(
            fromdir=str(tmp_dir),
            todir=str(sync_tmp),
            additional_replacements=ADDITIONAL_REPLACEMENTS,
        )
        unasync.unasync_files([str(tmp_dir / f.name) for f in async_files], [rule])

        # 4) Move generated files into TARGET_DIR, then post-process each
        for gen in sync_tmp.glob("*.py"):
            dest = TARGET_DIR / gen.name
            dest.write_text(gen.read_text(encoding="utf-8"), encoding="utf-8")
            post_process(dest)
            restore_blocks(dest, placeholders[gen.name])

    logger.info("Unasync transformation completed successfully!")
    return 0


if __name__ == "__main__":
    sys.exit(main())
