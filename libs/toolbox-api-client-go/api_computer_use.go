/*
Daytona Toolbox API

Daytona Toolbox API

API version: v0.0.0-dev
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package toolbox

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

type ComputerUseAPI interface {

	/*
		Click Click mouse button

		Click the mouse button at the specified coordinates

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ComputerUseAPIClickRequest
	*/
	Click(ctx context.Context) ComputerUseAPIClickRequest

	// ClickExecute executes the request
	//  @return MouseClickResponse
	ClickExecute(r ComputerUseAPIClickRequest) (*MouseClickResponse, *http.Response, error)

	/*
		DeleteRecording Delete a recording

		Delete a recording file by ID

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id Recording ID
		@return ComputerUseAPIDeleteRecordingRequest
	*/
	DeleteRecording(ctx context.Context, id string) ComputerUseAPIDeleteRecordingRequest

	// DeleteRecordingExecute executes the request
	DeleteRecordingExecute(r ComputerUseAPIDeleteRecordingRequest) (*http.Response, error)

	/*
		DownloadRecording Download a recording

		Download a recording by providing its ID

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id Recording ID
		@return ComputerUseAPIDownloadRecordingRequest
	*/
	DownloadRecording(ctx context.Context, id string) ComputerUseAPIDownloadRecordingRequest

	// DownloadRecordingExecute executes the request
	//  @return *os.File
	DownloadRecordingExecute(r ComputerUseAPIDownloadRecordingRequest) (*os.File, *http.Response, error)

	/*
		Drag Drag mouse

		Drag the mouse from start to end coordinates

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ComputerUseAPIDragRequest
	*/
	Drag(ctx context.Context) ComputerUseAPIDragRequest

	// DragExecute executes the request
	//  @return MouseDragResponse
	DragExecute(r ComputerUseAPIDragRequest) (*MouseDragResponse, *http.Response, error)

	/*
		GetComputerUseStatus Get computer use process status

		Get the status of all computer use processes

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ComputerUseAPIGetComputerUseStatusRequest
	*/
	GetComputerUseStatus(ctx context.Context) ComputerUseAPIGetComputerUseStatusRequest

	// GetComputerUseStatusExecute executes the request
	//  @return ComputerUseStatusResponse
	GetComputerUseStatusExecute(r ComputerUseAPIGetComputerUseStatusRequest) (*ComputerUseStatusResponse, *http.Response, error)

	/*
		GetComputerUseSystemStatus Get computer use status

		Get the current status of the computer use system

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ComputerUseAPIGetComputerUseSystemStatusRequest
	*/
	GetComputerUseSystemStatus(ctx context.Context) ComputerUseAPIGetComputerUseSystemStatusRequest

	// GetComputerUseSystemStatusExecute executes the request
	//  @return ComputerUseStatusResponse
	GetComputerUseSystemStatusExecute(r ComputerUseAPIGetComputerUseSystemStatusRequest) (*ComputerUseStatusResponse, *http.Response, error)

	/*
		GetDisplayInfo Get display information

		Get information about all available displays

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ComputerUseAPIGetDisplayInfoRequest
	*/
	GetDisplayInfo(ctx context.Context) ComputerUseAPIGetDisplayInfoRequest

	// GetDisplayInfoExecute executes the request
	//  @return DisplayInfoResponse
	GetDisplayInfoExecute(r ComputerUseAPIGetDisplayInfoRequest) (*DisplayInfoResponse, *http.Response, error)

	/*
		GetMousePosition Get mouse position

		Get the current mouse cursor position

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ComputerUseAPIGetMousePositionRequest
	*/
	GetMousePosition(ctx context.Context) ComputerUseAPIGetMousePositionRequest

	// GetMousePositionExecute executes the request
	//  @return MousePositionResponse
	GetMousePositionExecute(r ComputerUseAPIGetMousePositionRequest) (*MousePositionResponse, *http.Response, error)

	/*
		GetProcessErrors Get process errors

		Get errors for a specific computer use process

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param processName Process name to get errors for
		@return ComputerUseAPIGetProcessErrorsRequest
	*/
	GetProcessErrors(ctx context.Context, processName string) ComputerUseAPIGetProcessErrorsRequest

	// GetProcessErrorsExecute executes the request
	//  @return ProcessErrorsResponse
	GetProcessErrorsExecute(r ComputerUseAPIGetProcessErrorsRequest) (*ProcessErrorsResponse, *http.Response, error)

	/*
		GetProcessLogs Get process logs

		Get logs for a specific computer use process

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param processName Process name to get logs for
		@return ComputerUseAPIGetProcessLogsRequest
	*/
	GetProcessLogs(ctx context.Context, processName string) ComputerUseAPIGetProcessLogsRequest

	// GetProcessLogsExecute executes the request
	//  @return ProcessLogsResponse
	GetProcessLogsExecute(r ComputerUseAPIGetProcessLogsRequest) (*ProcessLogsResponse, *http.Response, error)

	/*
		GetProcessStatus Get specific process status

		Check if a specific computer use process is running

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param processName Process name to check
		@return ComputerUseAPIGetProcessStatusRequest
	*/
	GetProcessStatus(ctx context.Context, processName string) ComputerUseAPIGetProcessStatusRequest

	// GetProcessStatusExecute executes the request
	//  @return ProcessStatusResponse
	GetProcessStatusExecute(r ComputerUseAPIGetProcessStatusRequest) (*ProcessStatusResponse, *http.Response, error)

	/*
		GetRecording Get recording details

		Get details of a specific recording by ID

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id Recording ID
		@return ComputerUseAPIGetRecordingRequest
	*/
	GetRecording(ctx context.Context, id string) ComputerUseAPIGetRecordingRequest

	// GetRecordingExecute executes the request
	//  @return Recording
	GetRecordingExecute(r ComputerUseAPIGetRecordingRequest) (*Recording, *http.Response, error)

	/*
		GetWindows Get windows information

		Get information about all open windows

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ComputerUseAPIGetWindowsRequest
	*/
	GetWindows(ctx context.Context) ComputerUseAPIGetWindowsRequest

	// GetWindowsExecute executes the request
	//  @return WindowsResponse
	GetWindowsExecute(r ComputerUseAPIGetWindowsRequest) (*WindowsResponse, *http.Response, error)

	/*
		ListRecordings List all recordings

		Get a list of all recordings (active and completed)

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ComputerUseAPIListRecordingsRequest
	*/
	ListRecordings(ctx context.Context) ComputerUseAPIListRecordingsRequest

	// ListRecordingsExecute executes the request
	//  @return ListRecordingsResponse
	ListRecordingsExecute(r ComputerUseAPIListRecordingsRequest) (*ListRecordingsResponse, *http.Response, error)

	/*
		MoveMouse Move mouse cursor

		Move the mouse cursor to the specified coordinates

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ComputerUseAPIMoveMouseRequest
	*/
	MoveMouse(ctx context.Context) ComputerUseAPIMoveMouseRequest

	// MoveMouseExecute executes the request
	//  @return MousePositionResponse
	MoveMouseExecute(r ComputerUseAPIMoveMouseRequest) (*MousePositionResponse, *http.Response, error)

	/*
		PressHotkey Press hotkey

		Press a hotkey combination (e.g., ctrl+c, cmd+v)

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ComputerUseAPIPressHotkeyRequest
	*/
	PressHotkey(ctx context.Context) ComputerUseAPIPressHotkeyRequest

	// PressHotkeyExecute executes the request
	//  @return map[string]interface{}
	PressHotkeyExecute(r ComputerUseAPIPressHotkeyRequest) (map[string]interface{}, *http.Response, error)

	/*
		PressKey Press key

		Press a key with optional modifiers

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ComputerUseAPIPressKeyRequest
	*/
	PressKey(ctx context.Context) ComputerUseAPIPressKeyRequest

	// PressKeyExecute executes the request
	//  @return map[string]interface{}
	PressKeyExecute(r ComputerUseAPIPressKeyRequest) (map[string]interface{}, *http.Response, error)

	/*
		RestartProcess Restart specific process

		Restart a specific computer use process

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param processName Process name to restart
		@return ComputerUseAPIRestartProcessRequest
	*/
	RestartProcess(ctx context.Context, processName string) ComputerUseAPIRestartProcessRequest

	// RestartProcessExecute executes the request
	//  @return ProcessRestartResponse
	RestartProcessExecute(r ComputerUseAPIRestartProcessRequest) (*ProcessRestartResponse, *http.Response, error)

	/*
		Scroll Scroll mouse wheel

		Scroll the mouse wheel at the specified coordinates

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ComputerUseAPIScrollRequest
	*/
	Scroll(ctx context.Context) ComputerUseAPIScrollRequest

	// ScrollExecute executes the request
	//  @return ScrollResponse
	ScrollExecute(r ComputerUseAPIScrollRequest) (*ScrollResponse, *http.Response, error)

	/*
		StartComputerUse Start computer use processes

		Start all computer use processes and return their status

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ComputerUseAPIStartComputerUseRequest
	*/
	StartComputerUse(ctx context.Context) ComputerUseAPIStartComputerUseRequest

	// StartComputerUseExecute executes the request
	//  @return ComputerUseStartResponse
	StartComputerUseExecute(r ComputerUseAPIStartComputerUseRequest) (*ComputerUseStartResponse, *http.Response, error)

	/*
		StartRecording Start a new recording

		Start a new screen recording session

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ComputerUseAPIStartRecordingRequest
	*/
	StartRecording(ctx context.Context) ComputerUseAPIStartRecordingRequest

	// StartRecordingExecute executes the request
	//  @return Recording
	StartRecordingExecute(r ComputerUseAPIStartRecordingRequest) (*Recording, *http.Response, error)

	/*
		StopComputerUse Stop computer use processes

		Stop all computer use processes and return their status

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ComputerUseAPIStopComputerUseRequest
	*/
	StopComputerUse(ctx context.Context) ComputerUseAPIStopComputerUseRequest

	// StopComputerUseExecute executes the request
	//  @return ComputerUseStopResponse
	StopComputerUseExecute(r ComputerUseAPIStopComputerUseRequest) (*ComputerUseStopResponse, *http.Response, error)

	/*
		StopRecording Stop a recording

		Stop an active screen recording session

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ComputerUseAPIStopRecordingRequest
	*/
	StopRecording(ctx context.Context) ComputerUseAPIStopRecordingRequest

	// StopRecordingExecute executes the request
	//  @return Recording
	StopRecordingExecute(r ComputerUseAPIStopRecordingRequest) (*Recording, *http.Response, error)

	/*
		TakeCompressedRegionScreenshot Take a compressed region screenshot

		Take a compressed screenshot of a specific region of the screen

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ComputerUseAPITakeCompressedRegionScreenshotRequest
	*/
	TakeCompressedRegionScreenshot(ctx context.Context) ComputerUseAPITakeCompressedRegionScreenshotRequest

	// TakeCompressedRegionScreenshotExecute executes the request
	//  @return ScreenshotResponse
	TakeCompressedRegionScreenshotExecute(r ComputerUseAPITakeCompressedRegionScreenshotRequest) (*ScreenshotResponse, *http.Response, error)

	/*
		TakeCompressedScreenshot Take a compressed screenshot

		Take a compressed screenshot of the entire screen

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ComputerUseAPITakeCompressedScreenshotRequest
	*/
	TakeCompressedScreenshot(ctx context.Context) ComputerUseAPITakeCompressedScreenshotRequest

	// TakeCompressedScreenshotExecute executes the request
	//  @return ScreenshotResponse
	TakeCompressedScreenshotExecute(r ComputerUseAPITakeCompressedScreenshotRequest) (*ScreenshotResponse, *http.Response, error)

	/*
		TakeRegionScreenshot Take a region screenshot

		Take a screenshot of a specific region of the screen

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ComputerUseAPITakeRegionScreenshotRequest
	*/
	TakeRegionScreenshot(ctx context.Context) ComputerUseAPITakeRegionScreenshotRequest

	// TakeRegionScreenshotExecute executes the request
	//  @return ScreenshotResponse
	TakeRegionScreenshotExecute(r ComputerUseAPITakeRegionScreenshotRequest) (*ScreenshotResponse, *http.Response, error)

	/*
		TakeScreenshot Take a screenshot

		Take a screenshot of the entire screen

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ComputerUseAPITakeScreenshotRequest
	*/
	TakeScreenshot(ctx context.Context) ComputerUseAPITakeScreenshotRequest

	// TakeScreenshotExecute executes the request
	//  @return ScreenshotResponse
	TakeScreenshotExecute(r ComputerUseAPITakeScreenshotRequest) (*ScreenshotResponse, *http.Response, error)

	/*
		TypeText Type text

		Type text with optional delay between keystrokes

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ComputerUseAPITypeTextRequest
	*/
	TypeText(ctx context.Context) ComputerUseAPITypeTextRequest

	// TypeTextExecute executes the request
	//  @return map[string]interface{}
	TypeTextExecute(r ComputerUseAPITypeTextRequest) (map[string]interface{}, *http.Response, error)
}

// ComputerUseAPIService ComputerUseAPI service
type ComputerUseAPIService service

type ComputerUseAPIClickRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
	request    *MouseClickRequest
}

// Mouse click request
func (r ComputerUseAPIClickRequest) Request(request MouseClickRequest) ComputerUseAPIClickRequest {
	r.request = &request
	return r
}

func (r ComputerUseAPIClickRequest) Execute() (*MouseClickResponse, *http.Response, error) {
	return r.ApiService.ClickExecute(r)
}

/*
Click Click mouse button

Click the mouse button at the specified coordinates

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerUseAPIClickRequest
*/
func (a *ComputerUseAPIService) Click(ctx context.Context) ComputerUseAPIClickRequest {
	return ComputerUseAPIClickRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MouseClickResponse
func (a *ComputerUseAPIService) ClickExecute(r ComputerUseAPIClickRequest) (*MouseClickResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MouseClickResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.Click")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/mouse/click"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPIDeleteRecordingRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
	id         string
}

func (r ComputerUseAPIDeleteRecordingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRecordingExecute(r)
}

/*
DeleteRecording Delete a recording

Delete a recording file by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Recording ID
	@return ComputerUseAPIDeleteRecordingRequest
*/
func (a *ComputerUseAPIService) DeleteRecording(ctx context.Context, id string) ComputerUseAPIDeleteRecordingRequest {
	return ComputerUseAPIDeleteRecordingRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *ComputerUseAPIService) DeleteRecordingExecute(r ComputerUseAPIDeleteRecordingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.DeleteRecording")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/recordings/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ComputerUseAPIDownloadRecordingRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
	id         string
}

func (r ComputerUseAPIDownloadRecordingRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.DownloadRecordingExecute(r)
}

/*
DownloadRecording Download a recording

Download a recording by providing its ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Recording ID
	@return ComputerUseAPIDownloadRecordingRequest
*/
func (a *ComputerUseAPIService) DownloadRecording(ctx context.Context, id string) ComputerUseAPIDownloadRecordingRequest {
	return ComputerUseAPIDownloadRecordingRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *ComputerUseAPIService) DownloadRecordingExecute(r ComputerUseAPIDownloadRecordingRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.DownloadRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/recordings/{id}/download"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPIDragRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
	request    *MouseDragRequest
}

// Mouse drag request
func (r ComputerUseAPIDragRequest) Request(request MouseDragRequest) ComputerUseAPIDragRequest {
	r.request = &request
	return r
}

func (r ComputerUseAPIDragRequest) Execute() (*MouseDragResponse, *http.Response, error) {
	return r.ApiService.DragExecute(r)
}

/*
Drag Drag mouse

Drag the mouse from start to end coordinates

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerUseAPIDragRequest
*/
func (a *ComputerUseAPIService) Drag(ctx context.Context) ComputerUseAPIDragRequest {
	return ComputerUseAPIDragRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MouseDragResponse
func (a *ComputerUseAPIService) DragExecute(r ComputerUseAPIDragRequest) (*MouseDragResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MouseDragResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.Drag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/mouse/drag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPIGetComputerUseStatusRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
}

func (r ComputerUseAPIGetComputerUseStatusRequest) Execute() (*ComputerUseStatusResponse, *http.Response, error) {
	return r.ApiService.GetComputerUseStatusExecute(r)
}

/*
GetComputerUseStatus Get computer use process status

Get the status of all computer use processes

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerUseAPIGetComputerUseStatusRequest
*/
func (a *ComputerUseAPIService) GetComputerUseStatus(ctx context.Context) ComputerUseAPIGetComputerUseStatusRequest {
	return ComputerUseAPIGetComputerUseStatusRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ComputerUseStatusResponse
func (a *ComputerUseAPIService) GetComputerUseStatusExecute(r ComputerUseAPIGetComputerUseStatusRequest) (*ComputerUseStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ComputerUseStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.GetComputerUseStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/process-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPIGetComputerUseSystemStatusRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
}

func (r ComputerUseAPIGetComputerUseSystemStatusRequest) Execute() (*ComputerUseStatusResponse, *http.Response, error) {
	return r.ApiService.GetComputerUseSystemStatusExecute(r)
}

/*
GetComputerUseSystemStatus Get computer use status

Get the current status of the computer use system

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerUseAPIGetComputerUseSystemStatusRequest
*/
func (a *ComputerUseAPIService) GetComputerUseSystemStatus(ctx context.Context) ComputerUseAPIGetComputerUseSystemStatusRequest {
	return ComputerUseAPIGetComputerUseSystemStatusRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ComputerUseStatusResponse
func (a *ComputerUseAPIService) GetComputerUseSystemStatusExecute(r ComputerUseAPIGetComputerUseSystemStatusRequest) (*ComputerUseStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ComputerUseStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.GetComputerUseSystemStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPIGetDisplayInfoRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
}

func (r ComputerUseAPIGetDisplayInfoRequest) Execute() (*DisplayInfoResponse, *http.Response, error) {
	return r.ApiService.GetDisplayInfoExecute(r)
}

/*
GetDisplayInfo Get display information

Get information about all available displays

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerUseAPIGetDisplayInfoRequest
*/
func (a *ComputerUseAPIService) GetDisplayInfo(ctx context.Context) ComputerUseAPIGetDisplayInfoRequest {
	return ComputerUseAPIGetDisplayInfoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DisplayInfoResponse
func (a *ComputerUseAPIService) GetDisplayInfoExecute(r ComputerUseAPIGetDisplayInfoRequest) (*DisplayInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DisplayInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.GetDisplayInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/display/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPIGetMousePositionRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
}

func (r ComputerUseAPIGetMousePositionRequest) Execute() (*MousePositionResponse, *http.Response, error) {
	return r.ApiService.GetMousePositionExecute(r)
}

/*
GetMousePosition Get mouse position

Get the current mouse cursor position

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerUseAPIGetMousePositionRequest
*/
func (a *ComputerUseAPIService) GetMousePosition(ctx context.Context) ComputerUseAPIGetMousePositionRequest {
	return ComputerUseAPIGetMousePositionRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MousePositionResponse
func (a *ComputerUseAPIService) GetMousePositionExecute(r ComputerUseAPIGetMousePositionRequest) (*MousePositionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MousePositionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.GetMousePosition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/mouse/position"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPIGetProcessErrorsRequest struct {
	ctx         context.Context
	ApiService  ComputerUseAPI
	processName string
}

func (r ComputerUseAPIGetProcessErrorsRequest) Execute() (*ProcessErrorsResponse, *http.Response, error) {
	return r.ApiService.GetProcessErrorsExecute(r)
}

/*
GetProcessErrors Get process errors

Get errors for a specific computer use process

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param processName Process name to get errors for
	@return ComputerUseAPIGetProcessErrorsRequest
*/
func (a *ComputerUseAPIService) GetProcessErrors(ctx context.Context, processName string) ComputerUseAPIGetProcessErrorsRequest {
	return ComputerUseAPIGetProcessErrorsRequest{
		ApiService:  a,
		ctx:         ctx,
		processName: processName,
	}
}

// Execute executes the request
//
//	@return ProcessErrorsResponse
func (a *ComputerUseAPIService) GetProcessErrorsExecute(r ComputerUseAPIGetProcessErrorsRequest) (*ProcessErrorsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProcessErrorsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.GetProcessErrors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/process/{processName}/errors"
	localVarPath = strings.Replace(localVarPath, "{"+"processName"+"}", url.PathEscape(parameterValueToString(r.processName, "processName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPIGetProcessLogsRequest struct {
	ctx         context.Context
	ApiService  ComputerUseAPI
	processName string
}

func (r ComputerUseAPIGetProcessLogsRequest) Execute() (*ProcessLogsResponse, *http.Response, error) {
	return r.ApiService.GetProcessLogsExecute(r)
}

/*
GetProcessLogs Get process logs

Get logs for a specific computer use process

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param processName Process name to get logs for
	@return ComputerUseAPIGetProcessLogsRequest
*/
func (a *ComputerUseAPIService) GetProcessLogs(ctx context.Context, processName string) ComputerUseAPIGetProcessLogsRequest {
	return ComputerUseAPIGetProcessLogsRequest{
		ApiService:  a,
		ctx:         ctx,
		processName: processName,
	}
}

// Execute executes the request
//
//	@return ProcessLogsResponse
func (a *ComputerUseAPIService) GetProcessLogsExecute(r ComputerUseAPIGetProcessLogsRequest) (*ProcessLogsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProcessLogsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.GetProcessLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/process/{processName}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"processName"+"}", url.PathEscape(parameterValueToString(r.processName, "processName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPIGetProcessStatusRequest struct {
	ctx         context.Context
	ApiService  ComputerUseAPI
	processName string
}

func (r ComputerUseAPIGetProcessStatusRequest) Execute() (*ProcessStatusResponse, *http.Response, error) {
	return r.ApiService.GetProcessStatusExecute(r)
}

/*
GetProcessStatus Get specific process status

Check if a specific computer use process is running

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param processName Process name to check
	@return ComputerUseAPIGetProcessStatusRequest
*/
func (a *ComputerUseAPIService) GetProcessStatus(ctx context.Context, processName string) ComputerUseAPIGetProcessStatusRequest {
	return ComputerUseAPIGetProcessStatusRequest{
		ApiService:  a,
		ctx:         ctx,
		processName: processName,
	}
}

// Execute executes the request
//
//	@return ProcessStatusResponse
func (a *ComputerUseAPIService) GetProcessStatusExecute(r ComputerUseAPIGetProcessStatusRequest) (*ProcessStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProcessStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.GetProcessStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/process/{processName}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"processName"+"}", url.PathEscape(parameterValueToString(r.processName, "processName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPIGetRecordingRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
	id         string
}

func (r ComputerUseAPIGetRecordingRequest) Execute() (*Recording, *http.Response, error) {
	return r.ApiService.GetRecordingExecute(r)
}

/*
GetRecording Get recording details

Get details of a specific recording by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Recording ID
	@return ComputerUseAPIGetRecordingRequest
*/
func (a *ComputerUseAPIService) GetRecording(ctx context.Context, id string) ComputerUseAPIGetRecordingRequest {
	return ComputerUseAPIGetRecordingRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Recording
func (a *ComputerUseAPIService) GetRecordingExecute(r ComputerUseAPIGetRecordingRequest) (*Recording, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Recording
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.GetRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/recordings/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPIGetWindowsRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
}

func (r ComputerUseAPIGetWindowsRequest) Execute() (*WindowsResponse, *http.Response, error) {
	return r.ApiService.GetWindowsExecute(r)
}

/*
GetWindows Get windows information

Get information about all open windows

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerUseAPIGetWindowsRequest
*/
func (a *ComputerUseAPIService) GetWindows(ctx context.Context) ComputerUseAPIGetWindowsRequest {
	return ComputerUseAPIGetWindowsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WindowsResponse
func (a *ComputerUseAPIService) GetWindowsExecute(r ComputerUseAPIGetWindowsRequest) (*WindowsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WindowsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.GetWindows")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/display/windows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPIListRecordingsRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
}

func (r ComputerUseAPIListRecordingsRequest) Execute() (*ListRecordingsResponse, *http.Response, error) {
	return r.ApiService.ListRecordingsExecute(r)
}

/*
ListRecordings List all recordings

Get a list of all recordings (active and completed)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerUseAPIListRecordingsRequest
*/
func (a *ComputerUseAPIService) ListRecordings(ctx context.Context) ComputerUseAPIListRecordingsRequest {
	return ComputerUseAPIListRecordingsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ListRecordingsResponse
func (a *ComputerUseAPIService) ListRecordingsExecute(r ComputerUseAPIListRecordingsRequest) (*ListRecordingsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListRecordingsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.ListRecordings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/recordings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPIMoveMouseRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
	request    *MouseMoveRequest
}

// Mouse move request
func (r ComputerUseAPIMoveMouseRequest) Request(request MouseMoveRequest) ComputerUseAPIMoveMouseRequest {
	r.request = &request
	return r
}

func (r ComputerUseAPIMoveMouseRequest) Execute() (*MousePositionResponse, *http.Response, error) {
	return r.ApiService.MoveMouseExecute(r)
}

/*
MoveMouse Move mouse cursor

Move the mouse cursor to the specified coordinates

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerUseAPIMoveMouseRequest
*/
func (a *ComputerUseAPIService) MoveMouse(ctx context.Context) ComputerUseAPIMoveMouseRequest {
	return ComputerUseAPIMoveMouseRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MousePositionResponse
func (a *ComputerUseAPIService) MoveMouseExecute(r ComputerUseAPIMoveMouseRequest) (*MousePositionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MousePositionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.MoveMouse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/mouse/move"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPIPressHotkeyRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
	request    *KeyboardHotkeyRequest
}

// Hotkey press request
func (r ComputerUseAPIPressHotkeyRequest) Request(request KeyboardHotkeyRequest) ComputerUseAPIPressHotkeyRequest {
	r.request = &request
	return r
}

func (r ComputerUseAPIPressHotkeyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PressHotkeyExecute(r)
}

/*
PressHotkey Press hotkey

Press a hotkey combination (e.g., ctrl+c, cmd+v)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerUseAPIPressHotkeyRequest
*/
func (a *ComputerUseAPIService) PressHotkey(ctx context.Context) ComputerUseAPIPressHotkeyRequest {
	return ComputerUseAPIPressHotkeyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ComputerUseAPIService) PressHotkeyExecute(r ComputerUseAPIPressHotkeyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.PressHotkey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/keyboard/hotkey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPIPressKeyRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
	request    *KeyboardPressRequest
}

// Key press request
func (r ComputerUseAPIPressKeyRequest) Request(request KeyboardPressRequest) ComputerUseAPIPressKeyRequest {
	r.request = &request
	return r
}

func (r ComputerUseAPIPressKeyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PressKeyExecute(r)
}

/*
PressKey Press key

Press a key with optional modifiers

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerUseAPIPressKeyRequest
*/
func (a *ComputerUseAPIService) PressKey(ctx context.Context) ComputerUseAPIPressKeyRequest {
	return ComputerUseAPIPressKeyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ComputerUseAPIService) PressKeyExecute(r ComputerUseAPIPressKeyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.PressKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/keyboard/key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPIRestartProcessRequest struct {
	ctx         context.Context
	ApiService  ComputerUseAPI
	processName string
}

func (r ComputerUseAPIRestartProcessRequest) Execute() (*ProcessRestartResponse, *http.Response, error) {
	return r.ApiService.RestartProcessExecute(r)
}

/*
RestartProcess Restart specific process

Restart a specific computer use process

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param processName Process name to restart
	@return ComputerUseAPIRestartProcessRequest
*/
func (a *ComputerUseAPIService) RestartProcess(ctx context.Context, processName string) ComputerUseAPIRestartProcessRequest {
	return ComputerUseAPIRestartProcessRequest{
		ApiService:  a,
		ctx:         ctx,
		processName: processName,
	}
}

// Execute executes the request
//
//	@return ProcessRestartResponse
func (a *ComputerUseAPIService) RestartProcessExecute(r ComputerUseAPIRestartProcessRequest) (*ProcessRestartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProcessRestartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.RestartProcess")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/process/{processName}/restart"
	localVarPath = strings.Replace(localVarPath, "{"+"processName"+"}", url.PathEscape(parameterValueToString(r.processName, "processName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPIScrollRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
	request    *MouseScrollRequest
}

// Mouse scroll request
func (r ComputerUseAPIScrollRequest) Request(request MouseScrollRequest) ComputerUseAPIScrollRequest {
	r.request = &request
	return r
}

func (r ComputerUseAPIScrollRequest) Execute() (*ScrollResponse, *http.Response, error) {
	return r.ApiService.ScrollExecute(r)
}

/*
Scroll Scroll mouse wheel

Scroll the mouse wheel at the specified coordinates

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerUseAPIScrollRequest
*/
func (a *ComputerUseAPIService) Scroll(ctx context.Context) ComputerUseAPIScrollRequest {
	return ComputerUseAPIScrollRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ScrollResponse
func (a *ComputerUseAPIService) ScrollExecute(r ComputerUseAPIScrollRequest) (*ScrollResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ScrollResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.Scroll")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/mouse/scroll"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPIStartComputerUseRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
}

func (r ComputerUseAPIStartComputerUseRequest) Execute() (*ComputerUseStartResponse, *http.Response, error) {
	return r.ApiService.StartComputerUseExecute(r)
}

/*
StartComputerUse Start computer use processes

Start all computer use processes and return their status

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerUseAPIStartComputerUseRequest
*/
func (a *ComputerUseAPIService) StartComputerUse(ctx context.Context) ComputerUseAPIStartComputerUseRequest {
	return ComputerUseAPIStartComputerUseRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ComputerUseStartResponse
func (a *ComputerUseAPIService) StartComputerUseExecute(r ComputerUseAPIStartComputerUseRequest) (*ComputerUseStartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ComputerUseStartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.StartComputerUse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/start"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPIStartRecordingRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
	request    *StartRecordingRequest
}

// Recording options
func (r ComputerUseAPIStartRecordingRequest) Request(request StartRecordingRequest) ComputerUseAPIStartRecordingRequest {
	r.request = &request
	return r
}

func (r ComputerUseAPIStartRecordingRequest) Execute() (*Recording, *http.Response, error) {
	return r.ApiService.StartRecordingExecute(r)
}

/*
StartRecording Start a new recording

Start a new screen recording session

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerUseAPIStartRecordingRequest
*/
func (a *ComputerUseAPIService) StartRecording(ctx context.Context) ComputerUseAPIStartRecordingRequest {
	return ComputerUseAPIStartRecordingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Recording
func (a *ComputerUseAPIService) StartRecordingExecute(r ComputerUseAPIStartRecordingRequest) (*Recording, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Recording
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.StartRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/recordings/start"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPIStopComputerUseRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
}

func (r ComputerUseAPIStopComputerUseRequest) Execute() (*ComputerUseStopResponse, *http.Response, error) {
	return r.ApiService.StopComputerUseExecute(r)
}

/*
StopComputerUse Stop computer use processes

Stop all computer use processes and return their status

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerUseAPIStopComputerUseRequest
*/
func (a *ComputerUseAPIService) StopComputerUse(ctx context.Context) ComputerUseAPIStopComputerUseRequest {
	return ComputerUseAPIStopComputerUseRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ComputerUseStopResponse
func (a *ComputerUseAPIService) StopComputerUseExecute(r ComputerUseAPIStopComputerUseRequest) (*ComputerUseStopResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ComputerUseStopResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.StopComputerUse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/stop"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPIStopRecordingRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
	request    *StopRecordingRequest
}

// Recording ID to stop
func (r ComputerUseAPIStopRecordingRequest) Request(request StopRecordingRequest) ComputerUseAPIStopRecordingRequest {
	r.request = &request
	return r
}

func (r ComputerUseAPIStopRecordingRequest) Execute() (*Recording, *http.Response, error) {
	return r.ApiService.StopRecordingExecute(r)
}

/*
StopRecording Stop a recording

Stop an active screen recording session

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerUseAPIStopRecordingRequest
*/
func (a *ComputerUseAPIService) StopRecording(ctx context.Context) ComputerUseAPIStopRecordingRequest {
	return ComputerUseAPIStopRecordingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Recording
func (a *ComputerUseAPIService) StopRecordingExecute(r ComputerUseAPIStopRecordingRequest) (*Recording, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Recording
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.StopRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/recordings/stop"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPITakeCompressedRegionScreenshotRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
	x          *int32
	y          *int32
	width      *int32
	height     *int32
	showCursor *bool
	format     *string
	quality    *int32
	scale      *float32
}

// X coordinate of the region
func (r ComputerUseAPITakeCompressedRegionScreenshotRequest) X(x int32) ComputerUseAPITakeCompressedRegionScreenshotRequest {
	r.x = &x
	return r
}

// Y coordinate of the region
func (r ComputerUseAPITakeCompressedRegionScreenshotRequest) Y(y int32) ComputerUseAPITakeCompressedRegionScreenshotRequest {
	r.y = &y
	return r
}

// Width of the region
func (r ComputerUseAPITakeCompressedRegionScreenshotRequest) Width(width int32) ComputerUseAPITakeCompressedRegionScreenshotRequest {
	r.width = &width
	return r
}

// Height of the region
func (r ComputerUseAPITakeCompressedRegionScreenshotRequest) Height(height int32) ComputerUseAPITakeCompressedRegionScreenshotRequest {
	r.height = &height
	return r
}

// Whether to show cursor in screenshot
func (r ComputerUseAPITakeCompressedRegionScreenshotRequest) ShowCursor(showCursor bool) ComputerUseAPITakeCompressedRegionScreenshotRequest {
	r.showCursor = &showCursor
	return r
}

// Image format (png or jpeg)
func (r ComputerUseAPITakeCompressedRegionScreenshotRequest) Format(format string) ComputerUseAPITakeCompressedRegionScreenshotRequest {
	r.format = &format
	return r
}

// JPEG quality (1-100)
func (r ComputerUseAPITakeCompressedRegionScreenshotRequest) Quality(quality int32) ComputerUseAPITakeCompressedRegionScreenshotRequest {
	r.quality = &quality
	return r
}

// Scale factor (0.1-1.0)
func (r ComputerUseAPITakeCompressedRegionScreenshotRequest) Scale(scale float32) ComputerUseAPITakeCompressedRegionScreenshotRequest {
	r.scale = &scale
	return r
}

func (r ComputerUseAPITakeCompressedRegionScreenshotRequest) Execute() (*ScreenshotResponse, *http.Response, error) {
	return r.ApiService.TakeCompressedRegionScreenshotExecute(r)
}

/*
TakeCompressedRegionScreenshot Take a compressed region screenshot

Take a compressed screenshot of a specific region of the screen

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerUseAPITakeCompressedRegionScreenshotRequest
*/
func (a *ComputerUseAPIService) TakeCompressedRegionScreenshot(ctx context.Context) ComputerUseAPITakeCompressedRegionScreenshotRequest {
	return ComputerUseAPITakeCompressedRegionScreenshotRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ScreenshotResponse
func (a *ComputerUseAPIService) TakeCompressedRegionScreenshotExecute(r ComputerUseAPITakeCompressedRegionScreenshotRequest) (*ScreenshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ScreenshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.TakeCompressedRegionScreenshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/screenshot/region/compressed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.x == nil {
		return localVarReturnValue, nil, reportError("x is required and must be specified")
	}
	if r.y == nil {
		return localVarReturnValue, nil, reportError("y is required and must be specified")
	}
	if r.width == nil {
		return localVarReturnValue, nil, reportError("width is required and must be specified")
	}
	if r.height == nil {
		return localVarReturnValue, nil, reportError("height is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "x", r.x, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "y", r.y, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "", "")
	if r.showCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showCursor", r.showCursor, "", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "", "")
	}
	if r.scale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scale", r.scale, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPITakeCompressedScreenshotRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
	showCursor *bool
	format     *string
	quality    *int32
	scale      *float32
}

// Whether to show cursor in screenshot
func (r ComputerUseAPITakeCompressedScreenshotRequest) ShowCursor(showCursor bool) ComputerUseAPITakeCompressedScreenshotRequest {
	r.showCursor = &showCursor
	return r
}

// Image format (png or jpeg)
func (r ComputerUseAPITakeCompressedScreenshotRequest) Format(format string) ComputerUseAPITakeCompressedScreenshotRequest {
	r.format = &format
	return r
}

// JPEG quality (1-100)
func (r ComputerUseAPITakeCompressedScreenshotRequest) Quality(quality int32) ComputerUseAPITakeCompressedScreenshotRequest {
	r.quality = &quality
	return r
}

// Scale factor (0.1-1.0)
func (r ComputerUseAPITakeCompressedScreenshotRequest) Scale(scale float32) ComputerUseAPITakeCompressedScreenshotRequest {
	r.scale = &scale
	return r
}

func (r ComputerUseAPITakeCompressedScreenshotRequest) Execute() (*ScreenshotResponse, *http.Response, error) {
	return r.ApiService.TakeCompressedScreenshotExecute(r)
}

/*
TakeCompressedScreenshot Take a compressed screenshot

Take a compressed screenshot of the entire screen

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerUseAPITakeCompressedScreenshotRequest
*/
func (a *ComputerUseAPIService) TakeCompressedScreenshot(ctx context.Context) ComputerUseAPITakeCompressedScreenshotRequest {
	return ComputerUseAPITakeCompressedScreenshotRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ScreenshotResponse
func (a *ComputerUseAPIService) TakeCompressedScreenshotExecute(r ComputerUseAPITakeCompressedScreenshotRequest) (*ScreenshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ScreenshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.TakeCompressedScreenshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/screenshot/compressed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.showCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showCursor", r.showCursor, "", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "", "")
	}
	if r.scale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scale", r.scale, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPITakeRegionScreenshotRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
	x          *int32
	y          *int32
	width      *int32
	height     *int32
	showCursor *bool
}

// X coordinate of the region
func (r ComputerUseAPITakeRegionScreenshotRequest) X(x int32) ComputerUseAPITakeRegionScreenshotRequest {
	r.x = &x
	return r
}

// Y coordinate of the region
func (r ComputerUseAPITakeRegionScreenshotRequest) Y(y int32) ComputerUseAPITakeRegionScreenshotRequest {
	r.y = &y
	return r
}

// Width of the region
func (r ComputerUseAPITakeRegionScreenshotRequest) Width(width int32) ComputerUseAPITakeRegionScreenshotRequest {
	r.width = &width
	return r
}

// Height of the region
func (r ComputerUseAPITakeRegionScreenshotRequest) Height(height int32) ComputerUseAPITakeRegionScreenshotRequest {
	r.height = &height
	return r
}

// Whether to show cursor in screenshot
func (r ComputerUseAPITakeRegionScreenshotRequest) ShowCursor(showCursor bool) ComputerUseAPITakeRegionScreenshotRequest {
	r.showCursor = &showCursor
	return r
}

func (r ComputerUseAPITakeRegionScreenshotRequest) Execute() (*ScreenshotResponse, *http.Response, error) {
	return r.ApiService.TakeRegionScreenshotExecute(r)
}

/*
TakeRegionScreenshot Take a region screenshot

Take a screenshot of a specific region of the screen

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerUseAPITakeRegionScreenshotRequest
*/
func (a *ComputerUseAPIService) TakeRegionScreenshot(ctx context.Context) ComputerUseAPITakeRegionScreenshotRequest {
	return ComputerUseAPITakeRegionScreenshotRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ScreenshotResponse
func (a *ComputerUseAPIService) TakeRegionScreenshotExecute(r ComputerUseAPITakeRegionScreenshotRequest) (*ScreenshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ScreenshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.TakeRegionScreenshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/screenshot/region"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.x == nil {
		return localVarReturnValue, nil, reportError("x is required and must be specified")
	}
	if r.y == nil {
		return localVarReturnValue, nil, reportError("y is required and must be specified")
	}
	if r.width == nil {
		return localVarReturnValue, nil, reportError("width is required and must be specified")
	}
	if r.height == nil {
		return localVarReturnValue, nil, reportError("height is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "x", r.x, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "y", r.y, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "", "")
	if r.showCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showCursor", r.showCursor, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPITakeScreenshotRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
	showCursor *bool
}

// Whether to show cursor in screenshot
func (r ComputerUseAPITakeScreenshotRequest) ShowCursor(showCursor bool) ComputerUseAPITakeScreenshotRequest {
	r.showCursor = &showCursor
	return r
}

func (r ComputerUseAPITakeScreenshotRequest) Execute() (*ScreenshotResponse, *http.Response, error) {
	return r.ApiService.TakeScreenshotExecute(r)
}

/*
TakeScreenshot Take a screenshot

Take a screenshot of the entire screen

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerUseAPITakeScreenshotRequest
*/
func (a *ComputerUseAPIService) TakeScreenshot(ctx context.Context) ComputerUseAPITakeScreenshotRequest {
	return ComputerUseAPITakeScreenshotRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ScreenshotResponse
func (a *ComputerUseAPIService) TakeScreenshotExecute(r ComputerUseAPITakeScreenshotRequest) (*ScreenshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ScreenshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.TakeScreenshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/screenshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.showCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showCursor", r.showCursor, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerUseAPITypeTextRequest struct {
	ctx        context.Context
	ApiService ComputerUseAPI
	request    *KeyboardTypeRequest
}

// Text typing request
func (r ComputerUseAPITypeTextRequest) Request(request KeyboardTypeRequest) ComputerUseAPITypeTextRequest {
	r.request = &request
	return r
}

func (r ComputerUseAPITypeTextRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.TypeTextExecute(r)
}

/*
TypeText Type text

Type text with optional delay between keystrokes

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerUseAPITypeTextRequest
*/
func (a *ComputerUseAPIService) TypeText(ctx context.Context) ComputerUseAPITypeTextRequest {
	return ComputerUseAPITypeTextRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ComputerUseAPIService) TypeTextExecute(r ComputerUseAPITypeTextRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerUseAPIService.TypeText")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/computeruse/keyboard/type"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
