/*
Daytona Toolbox API

Daytona Toolbox API

API version: v0.0.0-dev
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package toolbox

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
)


type FileSystemAPI interface {

	/*
	CreateFolder Create a folder

	Create a folder with the specified path and optional permissions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FileSystemAPICreateFolderRequest
	*/
	CreateFolder(ctx context.Context) FileSystemAPICreateFolderRequest

	// CreateFolderExecute executes the request
	CreateFolderExecute(r FileSystemAPICreateFolderRequest) (*http.Response, error)

	/*
	DeleteFile Delete a file or directory

	Delete a file or directory at the specified path

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FileSystemAPIDeleteFileRequest
	*/
	DeleteFile(ctx context.Context) FileSystemAPIDeleteFileRequest

	// DeleteFileExecute executes the request
	DeleteFileExecute(r FileSystemAPIDeleteFileRequest) (*http.Response, error)

	/*
	DownloadFile Download a file

	Download a file by providing its path

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FileSystemAPIDownloadFileRequest
	*/
	DownloadFile(ctx context.Context) FileSystemAPIDownloadFileRequest

	// DownloadFileExecute executes the request
	//  @return *os.File
	DownloadFileExecute(r FileSystemAPIDownloadFileRequest) (*os.File, *http.Response, error)

	/*
	DownloadFiles Download multiple files

	Download multiple files by providing their paths

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FileSystemAPIDownloadFilesRequest
	*/
	DownloadFiles(ctx context.Context) FileSystemAPIDownloadFilesRequest

	// DownloadFilesExecute executes the request
	//  @return map[string]map[string]interface{}
	DownloadFilesExecute(r FileSystemAPIDownloadFilesRequest) (map[string]map[string]interface{}, *http.Response, error)

	/*
	FindInFiles Find text in files

	Search for text pattern within files in a directory

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FileSystemAPIFindInFilesRequest
	*/
	FindInFiles(ctx context.Context) FileSystemAPIFindInFilesRequest

	// FindInFilesExecute executes the request
	//  @return []Match
	FindInFilesExecute(r FileSystemAPIFindInFilesRequest) ([]Match, *http.Response, error)

	/*
	GetFileInfo Get file information

	Get detailed information about a file or directory

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FileSystemAPIGetFileInfoRequest
	*/
	GetFileInfo(ctx context.Context) FileSystemAPIGetFileInfoRequest

	// GetFileInfoExecute executes the request
	//  @return FileInfo
	GetFileInfoExecute(r FileSystemAPIGetFileInfoRequest) (*FileInfo, *http.Response, error)

	/*
	ListFiles List files and directories

	List files and directories in the specified path

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FileSystemAPIListFilesRequest
	*/
	ListFiles(ctx context.Context) FileSystemAPIListFilesRequest

	// ListFilesExecute executes the request
	//  @return []FileInfo
	ListFilesExecute(r FileSystemAPIListFilesRequest) ([]FileInfo, *http.Response, error)

	/*
	MoveFile Move or rename file/directory

	Move or rename a file or directory from source to destination

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FileSystemAPIMoveFileRequest
	*/
	MoveFile(ctx context.Context) FileSystemAPIMoveFileRequest

	// MoveFileExecute executes the request
	MoveFileExecute(r FileSystemAPIMoveFileRequest) (*http.Response, error)

	/*
	ReplaceInFiles Replace text in files

	Replace text pattern with new value in multiple files

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FileSystemAPIReplaceInFilesRequest
	*/
	ReplaceInFiles(ctx context.Context) FileSystemAPIReplaceInFilesRequest

	// ReplaceInFilesExecute executes the request
	//  @return []ReplaceResult
	ReplaceInFilesExecute(r FileSystemAPIReplaceInFilesRequest) ([]ReplaceResult, *http.Response, error)

	/*
	SearchFiles Search files by pattern

	Search for files matching a specific pattern in a directory

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FileSystemAPISearchFilesRequest
	*/
	SearchFiles(ctx context.Context) FileSystemAPISearchFilesRequest

	// SearchFilesExecute executes the request
	//  @return SearchFilesResponse
	SearchFilesExecute(r FileSystemAPISearchFilesRequest) (*SearchFilesResponse, *http.Response, error)

	/*
	SetFilePermissions Set file permissions

	Set file permissions, ownership, and group for a file or directory

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FileSystemAPISetFilePermissionsRequest
	*/
	SetFilePermissions(ctx context.Context) FileSystemAPISetFilePermissionsRequest

	// SetFilePermissionsExecute executes the request
	SetFilePermissionsExecute(r FileSystemAPISetFilePermissionsRequest) (*http.Response, error)

	/*
	UploadFile Upload a file

	Upload a file to the specified path

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FileSystemAPIUploadFileRequest
	*/
	UploadFile(ctx context.Context) FileSystemAPIUploadFileRequest

	// UploadFileExecute executes the request
	//  @return map[string]map[string]interface{}
	UploadFileExecute(r FileSystemAPIUploadFileRequest) (map[string]map[string]interface{}, *http.Response, error)

	/*
	UploadFiles Upload multiple files

	Upload multiple files with their destination paths

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FileSystemAPIUploadFilesRequest
	*/
	UploadFiles(ctx context.Context) FileSystemAPIUploadFilesRequest

	// UploadFilesExecute executes the request
	UploadFilesExecute(r FileSystemAPIUploadFilesRequest) (*http.Response, error)
}

// FileSystemAPIService FileSystemAPI service
type FileSystemAPIService service

type FileSystemAPICreateFolderRequest struct {
	ctx context.Context
	ApiService FileSystemAPI
	path *string
	mode *string
}

// Folder path to create
func (r FileSystemAPICreateFolderRequest) Path(path string) FileSystemAPICreateFolderRequest {
	r.path = &path
	return r
}

// Octal permission mode (default: 0755)
func (r FileSystemAPICreateFolderRequest) Mode(mode string) FileSystemAPICreateFolderRequest {
	r.mode = &mode
	return r
}

func (r FileSystemAPICreateFolderRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateFolderExecute(r)
}

/*
CreateFolder Create a folder

Create a folder with the specified path and optional permissions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FileSystemAPICreateFolderRequest
*/
func (a *FileSystemAPIService) CreateFolder(ctx context.Context) FileSystemAPICreateFolderRequest {
	return FileSystemAPICreateFolderRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FileSystemAPIService) CreateFolderExecute(r FileSystemAPICreateFolderRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FileSystemAPIService.CreateFolder")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/folder"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return nil, reportError("path is required and must be specified")
	}
	if r.mode == nil {
		return nil, reportError("mode is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FileSystemAPIDeleteFileRequest struct {
	ctx context.Context
	ApiService FileSystemAPI
	path *string
	recursive *bool
}

// File or directory path to delete
func (r FileSystemAPIDeleteFileRequest) Path(path string) FileSystemAPIDeleteFileRequest {
	r.path = &path
	return r
}

// Enable recursive deletion for directories
func (r FileSystemAPIDeleteFileRequest) Recursive(recursive bool) FileSystemAPIDeleteFileRequest {
	r.recursive = &recursive
	return r
}

func (r FileSystemAPIDeleteFileRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFileExecute(r)
}

/*
DeleteFile Delete a file or directory

Delete a file or directory at the specified path

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FileSystemAPIDeleteFileRequest
*/
func (a *FileSystemAPIService) DeleteFile(ctx context.Context) FileSystemAPIDeleteFileRequest {
	return FileSystemAPIDeleteFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FileSystemAPIService) DeleteFileExecute(r FileSystemAPIDeleteFileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FileSystemAPIService.DeleteFile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "", "")
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recursive", r.recursive, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FileSystemAPIDownloadFileRequest struct {
	ctx context.Context
	ApiService FileSystemAPI
	path *string
}

// File path to download
func (r FileSystemAPIDownloadFileRequest) Path(path string) FileSystemAPIDownloadFileRequest {
	r.path = &path
	return r
}

func (r FileSystemAPIDownloadFileRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.DownloadFileExecute(r)
}

/*
DownloadFile Download a file

Download a file by providing its path

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FileSystemAPIDownloadFileRequest
*/
func (a *FileSystemAPIService) DownloadFile(ctx context.Context) FileSystemAPIDownloadFileRequest {
	return FileSystemAPIDownloadFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *FileSystemAPIService) DownloadFileExecute(r FileSystemAPIDownloadFileRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FileSystemAPIService.DownloadFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FileSystemAPIDownloadFilesRequest struct {
	ctx context.Context
	ApiService FileSystemAPI
	downloadFiles *FilesDownloadRequest
}

// Paths of files to download
func (r FileSystemAPIDownloadFilesRequest) DownloadFiles(downloadFiles FilesDownloadRequest) FileSystemAPIDownloadFilesRequest {
	r.downloadFiles = &downloadFiles
	return r
}

func (r FileSystemAPIDownloadFilesRequest) Execute() (map[string]map[string]interface{}, *http.Response, error) {
	return r.ApiService.DownloadFilesExecute(r)
}

/*
DownloadFiles Download multiple files

Download multiple files by providing their paths

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FileSystemAPIDownloadFilesRequest
*/
func (a *FileSystemAPIService) DownloadFiles(ctx context.Context) FileSystemAPIDownloadFilesRequest {
	return FileSystemAPIDownloadFilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]map[string]interface{}
func (a *FileSystemAPIService) DownloadFilesExecute(r FileSystemAPIDownloadFilesRequest) (map[string]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FileSystemAPIService.DownloadFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/bulk-download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.downloadFiles == nil {
		return localVarReturnValue, nil, reportError("downloadFiles is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"multipart/form-data"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.downloadFiles
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FileSystemAPIFindInFilesRequest struct {
	ctx context.Context
	ApiService FileSystemAPI
	path *string
	pattern *string
}

// Directory path to search in
func (r FileSystemAPIFindInFilesRequest) Path(path string) FileSystemAPIFindInFilesRequest {
	r.path = &path
	return r
}

// Text pattern to search for
func (r FileSystemAPIFindInFilesRequest) Pattern(pattern string) FileSystemAPIFindInFilesRequest {
	r.pattern = &pattern
	return r
}

func (r FileSystemAPIFindInFilesRequest) Execute() ([]Match, *http.Response, error) {
	return r.ApiService.FindInFilesExecute(r)
}

/*
FindInFiles Find text in files

Search for text pattern within files in a directory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FileSystemAPIFindInFilesRequest
*/
func (a *FileSystemAPIService) FindInFiles(ctx context.Context) FileSystemAPIFindInFilesRequest {
	return FileSystemAPIFindInFilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Match
func (a *FileSystemAPIService) FindInFilesExecute(r FileSystemAPIFindInFilesRequest) ([]Match, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Match
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FileSystemAPIService.FindInFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/find"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}
	if r.pattern == nil {
		return localVarReturnValue, nil, reportError("pattern is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pattern", r.pattern, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FileSystemAPIGetFileInfoRequest struct {
	ctx context.Context
	ApiService FileSystemAPI
	path *string
}

// File or directory path
func (r FileSystemAPIGetFileInfoRequest) Path(path string) FileSystemAPIGetFileInfoRequest {
	r.path = &path
	return r
}

func (r FileSystemAPIGetFileInfoRequest) Execute() (*FileInfo, *http.Response, error) {
	return r.ApiService.GetFileInfoExecute(r)
}

/*
GetFileInfo Get file information

Get detailed information about a file or directory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FileSystemAPIGetFileInfoRequest
*/
func (a *FileSystemAPIService) GetFileInfo(ctx context.Context) FileSystemAPIGetFileInfoRequest {
	return FileSystemAPIGetFileInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FileInfo
func (a *FileSystemAPIService) GetFileInfoExecute(r FileSystemAPIGetFileInfoRequest) (*FileInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FileSystemAPIService.GetFileInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FileSystemAPIListFilesRequest struct {
	ctx context.Context
	ApiService FileSystemAPI
	path *string
}

// Directory path to list (defaults to working directory)
func (r FileSystemAPIListFilesRequest) Path(path string) FileSystemAPIListFilesRequest {
	r.path = &path
	return r
}

func (r FileSystemAPIListFilesRequest) Execute() ([]FileInfo, *http.Response, error) {
	return r.ApiService.ListFilesExecute(r)
}

/*
ListFiles List files and directories

List files and directories in the specified path

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FileSystemAPIListFilesRequest
*/
func (a *FileSystemAPIService) ListFiles(ctx context.Context) FileSystemAPIListFilesRequest {
	return FileSystemAPIListFilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []FileInfo
func (a *FileSystemAPIService) ListFilesExecute(r FileSystemAPIListFilesRequest) ([]FileInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FileInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FileSystemAPIService.ListFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FileSystemAPIMoveFileRequest struct {
	ctx context.Context
	ApiService FileSystemAPI
	source *string
	destination *string
}

// Source file or directory path
func (r FileSystemAPIMoveFileRequest) Source(source string) FileSystemAPIMoveFileRequest {
	r.source = &source
	return r
}

// Destination file or directory path
func (r FileSystemAPIMoveFileRequest) Destination(destination string) FileSystemAPIMoveFileRequest {
	r.destination = &destination
	return r
}

func (r FileSystemAPIMoveFileRequest) Execute() (*http.Response, error) {
	return r.ApiService.MoveFileExecute(r)
}

/*
MoveFile Move or rename file/directory

Move or rename a file or directory from source to destination

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FileSystemAPIMoveFileRequest
*/
func (a *FileSystemAPIService) MoveFile(ctx context.Context) FileSystemAPIMoveFileRequest {
	return FileSystemAPIMoveFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FileSystemAPIService) MoveFileExecute(r FileSystemAPIMoveFileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FileSystemAPIService.MoveFile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/move"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.source == nil {
		return nil, reportError("source is required and must be specified")
	}
	if r.destination == nil {
		return nil, reportError("destination is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "destination", r.destination, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FileSystemAPIReplaceInFilesRequest struct {
	ctx context.Context
	ApiService FileSystemAPI
	request *ReplaceRequest
}

// Replace request
func (r FileSystemAPIReplaceInFilesRequest) Request(request ReplaceRequest) FileSystemAPIReplaceInFilesRequest {
	r.request = &request
	return r
}

func (r FileSystemAPIReplaceInFilesRequest) Execute() ([]ReplaceResult, *http.Response, error) {
	return r.ApiService.ReplaceInFilesExecute(r)
}

/*
ReplaceInFiles Replace text in files

Replace text pattern with new value in multiple files

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FileSystemAPIReplaceInFilesRequest
*/
func (a *FileSystemAPIService) ReplaceInFiles(ctx context.Context) FileSystemAPIReplaceInFilesRequest {
	return FileSystemAPIReplaceInFilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ReplaceResult
func (a *FileSystemAPIService) ReplaceInFilesExecute(r FileSystemAPIReplaceInFilesRequest) ([]ReplaceResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ReplaceResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FileSystemAPIService.ReplaceInFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/replace"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FileSystemAPISearchFilesRequest struct {
	ctx context.Context
	ApiService FileSystemAPI
	path *string
	pattern *string
}

// Directory path to search in
func (r FileSystemAPISearchFilesRequest) Path(path string) FileSystemAPISearchFilesRequest {
	r.path = &path
	return r
}

// File pattern to match (e.g., *.txt, *.go)
func (r FileSystemAPISearchFilesRequest) Pattern(pattern string) FileSystemAPISearchFilesRequest {
	r.pattern = &pattern
	return r
}

func (r FileSystemAPISearchFilesRequest) Execute() (*SearchFilesResponse, *http.Response, error) {
	return r.ApiService.SearchFilesExecute(r)
}

/*
SearchFiles Search files by pattern

Search for files matching a specific pattern in a directory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FileSystemAPISearchFilesRequest
*/
func (a *FileSystemAPIService) SearchFiles(ctx context.Context) FileSystemAPISearchFilesRequest {
	return FileSystemAPISearchFilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchFilesResponse
func (a *FileSystemAPIService) SearchFilesExecute(r FileSystemAPISearchFilesRequest) (*SearchFilesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchFilesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FileSystemAPIService.SearchFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}
	if r.pattern == nil {
		return localVarReturnValue, nil, reportError("pattern is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pattern", r.pattern, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FileSystemAPISetFilePermissionsRequest struct {
	ctx context.Context
	ApiService FileSystemAPI
	path *string
	owner *string
	group *string
	mode *string
}

// File or directory path
func (r FileSystemAPISetFilePermissionsRequest) Path(path string) FileSystemAPISetFilePermissionsRequest {
	r.path = &path
	return r
}

// Owner (username or UID)
func (r FileSystemAPISetFilePermissionsRequest) Owner(owner string) FileSystemAPISetFilePermissionsRequest {
	r.owner = &owner
	return r
}

// Group (group name or GID)
func (r FileSystemAPISetFilePermissionsRequest) Group(group string) FileSystemAPISetFilePermissionsRequest {
	r.group = &group
	return r
}

// File mode in octal format (e.g., 0755)
func (r FileSystemAPISetFilePermissionsRequest) Mode(mode string) FileSystemAPISetFilePermissionsRequest {
	r.mode = &mode
	return r
}

func (r FileSystemAPISetFilePermissionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetFilePermissionsExecute(r)
}

/*
SetFilePermissions Set file permissions

Set file permissions, ownership, and group for a file or directory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FileSystemAPISetFilePermissionsRequest
*/
func (a *FileSystemAPIService) SetFilePermissions(ctx context.Context) FileSystemAPISetFilePermissionsRequest {
	return FileSystemAPISetFilePermissionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FileSystemAPIService) SetFilePermissionsExecute(r FileSystemAPISetFilePermissionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FileSystemAPIService.SetFilePermissions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/permissions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "", "")
	if r.owner != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "owner", r.owner, "", "")
	}
	if r.group != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group", r.group, "", "")
	}
	if r.mode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FileSystemAPIUploadFileRequest struct {
	ctx context.Context
	ApiService FileSystemAPI
	path *string
	file *os.File
}

// Destination path for the uploaded file
func (r FileSystemAPIUploadFileRequest) Path(path string) FileSystemAPIUploadFileRequest {
	r.path = &path
	return r
}

// File to upload
func (r FileSystemAPIUploadFileRequest) File(file *os.File) FileSystemAPIUploadFileRequest {
	r.file = file
	return r
}

func (r FileSystemAPIUploadFileRequest) Execute() (map[string]map[string]interface{}, *http.Response, error) {
	return r.ApiService.UploadFileExecute(r)
}

/*
UploadFile Upload a file

Upload a file to the specified path

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FileSystemAPIUploadFileRequest
*/
func (a *FileSystemAPIService) UploadFile(ctx context.Context) FileSystemAPIUploadFileRequest {
	return FileSystemAPIUploadFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]map[string]interface{}
func (a *FileSystemAPIService) UploadFileExecute(r FileSystemAPIUploadFileRequest) (map[string]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FileSystemAPIService.UploadFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/upload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FileSystemAPIUploadFilesRequest struct {
	ctx context.Context
	ApiService FileSystemAPI
}

func (r FileSystemAPIUploadFilesRequest) Execute() (*http.Response, error) {
	return r.ApiService.UploadFilesExecute(r)
}

/*
UploadFiles Upload multiple files

Upload multiple files with their destination paths

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FileSystemAPIUploadFilesRequest
*/
func (a *FileSystemAPIService) UploadFiles(ctx context.Context) FileSystemAPIUploadFilesRequest {
	return FileSystemAPIUploadFilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FileSystemAPIService) UploadFilesExecute(r FileSystemAPIUploadFilesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FileSystemAPIService.UploadFiles")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/bulk-upload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
