/* tslint:disable */
/* eslint-disable */
/**
 * Daytona Daemon API
 * Daytona Daemon API
 *
 * The version of the OpenAPI document: v0.0.0-dev
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from '../configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from '../common'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base'
// @ts-ignore
import type { FileInfo } from '../models'
// @ts-ignore
import type { FilesDownloadRequest } from '../models'
// @ts-ignore
import type { Match } from '../models'
// @ts-ignore
import type { ReplaceRequest } from '../models'
// @ts-ignore
import type { ReplaceResult } from '../models'
// @ts-ignore
import type { SearchFilesResponse } from '../models'
/**
 * FileSystemApi - axios parameter creator
 * @export
 */
export const FileSystemApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create a folder with the specified path and optional permissions
     * @summary Create a folder
     * @param {string} path Folder path to create
     * @param {string} mode Octal permission mode (default: 0755)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFolder: async (path: string, mode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('createFolder', 'path', path)
      // verify required parameter 'mode' is not null or undefined
      assertParamExists('createFolder', 'mode', mode)
      const localVarPath = `/files/folder`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (mode !== undefined) {
        localVarQueryParameter['mode'] = mode
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete a file or directory at the specified path
     * @summary Delete a file or directory
     * @param {string} path File or directory path to delete
     * @param {boolean} [recursive] Enable recursive deletion for directories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile: async (
      path: string,
      recursive?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('deleteFile', 'path', path)
      const localVarPath = `/files`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (recursive !== undefined) {
        localVarQueryParameter['recursive'] = recursive
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Download a file by providing its path
     * @summary Download a file
     * @param {string} path File path to download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile: async (path: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('downloadFile', 'path', path)
      const localVarPath = `/files/download`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Download multiple files by providing their paths
     * @summary Download multiple files
     * @param {FilesDownloadRequest} downloadFiles Paths of files to download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFiles: async (
      downloadFiles: FilesDownloadRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'downloadFiles' is not null or undefined
      assertParamExists('downloadFiles', 'downloadFiles', downloadFiles)
      const localVarPath = `/files/bulk-download`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(downloadFiles, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Search for text pattern within files in a directory
     * @summary Find text in files
     * @param {string} path Directory path to search in
     * @param {string} pattern Text pattern to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findInFiles: async (path: string, pattern: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('findInFiles', 'path', path)
      // verify required parameter 'pattern' is not null or undefined
      assertParamExists('findInFiles', 'pattern', pattern)
      const localVarPath = `/files/find`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (pattern !== undefined) {
        localVarQueryParameter['pattern'] = pattern
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get detailed information about a file or directory
     * @summary Get file information
     * @param {string} path File or directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileInfo: async (path: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('getFileInfo', 'path', path)
      const localVarPath = `/files/info`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List files and directories in the specified path
     * @summary List files and directories
     * @param {string} [path] Directory path to list (defaults to working directory)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFiles: async (path?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/files`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Move or rename a file or directory from source to destination
     * @summary Move or rename file/directory
     * @param {string} source Source file or directory path
     * @param {string} destination Destination file or directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moveFile: async (
      source: string,
      destination: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'source' is not null or undefined
      assertParamExists('moveFile', 'source', source)
      // verify required parameter 'destination' is not null or undefined
      assertParamExists('moveFile', 'destination', destination)
      const localVarPath = `/files/move`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (source !== undefined) {
        localVarQueryParameter['source'] = source
      }

      if (destination !== undefined) {
        localVarQueryParameter['destination'] = destination
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Replace text pattern with new value in multiple files
     * @summary Replace text in files
     * @param {ReplaceRequest} request Replace request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceInFiles: async (request: ReplaceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'request' is not null or undefined
      assertParamExists('replaceInFiles', 'request', request)
      const localVarPath = `/files/replace`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Search for files matching a specific pattern in a directory
     * @summary Search files by pattern
     * @param {string} path Directory path to search in
     * @param {string} pattern File pattern to match (e.g., *.txt, *.go)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchFiles: async (path: string, pattern: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('searchFiles', 'path', path)
      // verify required parameter 'pattern' is not null or undefined
      assertParamExists('searchFiles', 'pattern', pattern)
      const localVarPath = `/files/search`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (pattern !== undefined) {
        localVarQueryParameter['pattern'] = pattern
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Set file permissions, ownership, and group for a file or directory
     * @summary Set file permissions
     * @param {string} path File or directory path
     * @param {string} [owner] Owner (username or UID)
     * @param {string} [group] Group (group name or GID)
     * @param {string} [mode] File mode in octal format (e.g., 0755)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFilePermissions: async (
      path: string,
      owner?: string,
      group?: string,
      mode?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('setFilePermissions', 'path', path)
      const localVarPath = `/files/permissions`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (owner !== undefined) {
        localVarQueryParameter['owner'] = owner
      }

      if (group !== undefined) {
        localVarQueryParameter['group'] = group
      }

      if (mode !== undefined) {
        localVarQueryParameter['mode'] = mode
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Upload a file to the specified path
     * @summary Upload a file
     * @param {string} path Destination path for the uploaded file
     * @param {File} file File to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile: async (path: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('uploadFile', 'path', path)
      // verify required parameter 'file' is not null or undefined
      assertParamExists('uploadFile', 'file', file)
      const localVarPath = `/files/upload`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)()

      if (path !== undefined) {
        localVarQueryParameter['path'] = path
      }

      if (file !== undefined) {
        localVarFormParams.append('file', file as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Upload multiple files with their destination paths
     * @summary Upload multiple files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFiles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/files/bulk-upload`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * FileSystemApi - functional programming interface
 * @export
 */
export const FileSystemApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FileSystemApiAxiosParamCreator(configuration)
  return {
    /**
     * Create a folder with the specified path and optional permissions
     * @summary Create a folder
     * @param {string} path Folder path to create
     * @param {string} mode Octal permission mode (default: 0755)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFolder(
      path: string,
      mode: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createFolder(path, mode, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FileSystemApi.createFolder']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Delete a file or directory at the specified path
     * @summary Delete a file or directory
     * @param {string} path File or directory path to delete
     * @param {boolean} [recursive] Enable recursive deletion for directories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFile(
      path: string,
      recursive?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(path, recursive, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FileSystemApi.deleteFile']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Download a file by providing its path
     * @summary Download a file
     * @param {string} path File path to download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadFile(
      path: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(path, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FileSystemApi.downloadFile']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Download multiple files by providing their paths
     * @summary Download multiple files
     * @param {FilesDownloadRequest} downloadFiles Paths of files to download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadFiles(
      downloadFiles: FilesDownloadRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object }>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFiles(downloadFiles, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FileSystemApi.downloadFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Search for text pattern within files in a directory
     * @summary Find text in files
     * @param {string} path Directory path to search in
     * @param {string} pattern Text pattern to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findInFiles(
      path: string,
      pattern: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Match>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findInFiles(path, pattern, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FileSystemApi.findInFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get detailed information about a file or directory
     * @summary Get file information
     * @param {string} path File or directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFileInfo(
      path: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFileInfo(path, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FileSystemApi.getFileInfo']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * List files and directories in the specified path
     * @summary List files and directories
     * @param {string} [path] Directory path to list (defaults to working directory)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listFiles(
      path?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileInfo>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listFiles(path, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FileSystemApi.listFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Move or rename a file or directory from source to destination
     * @summary Move or rename file/directory
     * @param {string} source Source file or directory path
     * @param {string} destination Destination file or directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async moveFile(
      source: string,
      destination: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.moveFile(source, destination, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FileSystemApi.moveFile']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Replace text pattern with new value in multiple files
     * @summary Replace text in files
     * @param {ReplaceRequest} request Replace request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async replaceInFiles(
      request: ReplaceRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReplaceResult>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.replaceInFiles(request, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FileSystemApi.replaceInFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Search for files matching a specific pattern in a directory
     * @summary Search files by pattern
     * @param {string} path Directory path to search in
     * @param {string} pattern File pattern to match (e.g., *.txt, *.go)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchFiles(
      path: string,
      pattern: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchFilesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchFiles(path, pattern, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FileSystemApi.searchFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Set file permissions, ownership, and group for a file or directory
     * @summary Set file permissions
     * @param {string} path File or directory path
     * @param {string} [owner] Owner (username or UID)
     * @param {string} [group] Group (group name or GID)
     * @param {string} [mode] File mode in octal format (e.g., 0755)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setFilePermissions(
      path: string,
      owner?: string,
      group?: string,
      mode?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setFilePermissions(path, owner, group, mode, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FileSystemApi.setFilePermissions']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Upload a file to the specified path
     * @summary Upload a file
     * @param {string} path Destination path for the uploaded file
     * @param {File} file File to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadFile(
      path: string,
      file: File,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object }>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(path, file, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FileSystemApi.uploadFile']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Upload multiple files with their destination paths
     * @summary Upload multiple files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadFiles(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFiles(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FileSystemApi.uploadFiles']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * FileSystemApi - factory interface
 * @export
 */
export const FileSystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = FileSystemApiFp(configuration)
  return {
    /**
     * Create a folder with the specified path and optional permissions
     * @summary Create a folder
     * @param {string} path Folder path to create
     * @param {string} mode Octal permission mode (default: 0755)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFolder(path: string, mode: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.createFolder(path, mode, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete a file or directory at the specified path
     * @summary Delete a file or directory
     * @param {string} path File or directory path to delete
     * @param {boolean} [recursive] Enable recursive deletion for directories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(path: string, recursive?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.deleteFile(path, recursive, options).then((request) => request(axios, basePath))
    },
    /**
     * Download a file by providing its path
     * @summary Download a file
     * @param {string} path File path to download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile(path: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
      return localVarFp.downloadFile(path, options).then((request) => request(axios, basePath))
    },
    /**
     * Download multiple files by providing their paths
     * @summary Download multiple files
     * @param {FilesDownloadRequest} downloadFiles Paths of files to download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFiles(
      downloadFiles: FilesDownloadRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<{ [key: string]: object }> {
      return localVarFp.downloadFiles(downloadFiles, options).then((request) => request(axios, basePath))
    },
    /**
     * Search for text pattern within files in a directory
     * @summary Find text in files
     * @param {string} path Directory path to search in
     * @param {string} pattern Text pattern to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findInFiles(path: string, pattern: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Match>> {
      return localVarFp.findInFiles(path, pattern, options).then((request) => request(axios, basePath))
    },
    /**
     * Get detailed information about a file or directory
     * @summary Get file information
     * @param {string} path File or directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileInfo(path: string, options?: RawAxiosRequestConfig): AxiosPromise<FileInfo> {
      return localVarFp.getFileInfo(path, options).then((request) => request(axios, basePath))
    },
    /**
     * List files and directories in the specified path
     * @summary List files and directories
     * @param {string} [path] Directory path to list (defaults to working directory)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFiles(path?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<FileInfo>> {
      return localVarFp.listFiles(path, options).then((request) => request(axios, basePath))
    },
    /**
     * Move or rename a file or directory from source to destination
     * @summary Move or rename file/directory
     * @param {string} source Source file or directory path
     * @param {string} destination Destination file or directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moveFile(source: string, destination: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.moveFile(source, destination, options).then((request) => request(axios, basePath))
    },
    /**
     * Replace text pattern with new value in multiple files
     * @summary Replace text in files
     * @param {ReplaceRequest} request Replace request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceInFiles(request: ReplaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ReplaceResult>> {
      return localVarFp.replaceInFiles(request, options).then((request) => request(axios, basePath))
    },
    /**
     * Search for files matching a specific pattern in a directory
     * @summary Search files by pattern
     * @param {string} path Directory path to search in
     * @param {string} pattern File pattern to match (e.g., *.txt, *.go)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchFiles(path: string, pattern: string, options?: RawAxiosRequestConfig): AxiosPromise<SearchFilesResponse> {
      return localVarFp.searchFiles(path, pattern, options).then((request) => request(axios, basePath))
    },
    /**
     * Set file permissions, ownership, and group for a file or directory
     * @summary Set file permissions
     * @param {string} path File or directory path
     * @param {string} [owner] Owner (username or UID)
     * @param {string} [group] Group (group name or GID)
     * @param {string} [mode] File mode in octal format (e.g., 0755)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFilePermissions(
      path: string,
      owner?: string,
      group?: string,
      mode?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .setFilePermissions(path, owner, group, mode, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Upload a file to the specified path
     * @summary Upload a file
     * @param {string} path Destination path for the uploaded file
     * @param {File} file File to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile(path: string, file: File, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object }> {
      return localVarFp.uploadFile(path, file, options).then((request) => request(axios, basePath))
    },
    /**
     * Upload multiple files with their destination paths
     * @summary Upload multiple files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFiles(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.uploadFiles(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * FileSystemApi - object-oriented interface
 * @export
 * @class FileSystemApi
 * @extends {BaseAPI}
 */
export class FileSystemApi extends BaseAPI {
  /**
   * Create a folder with the specified path and optional permissions
   * @summary Create a folder
   * @param {string} path Folder path to create
   * @param {string} mode Octal permission mode (default: 0755)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileSystemApi
   */
  public createFolder(path: string, mode: string, options?: RawAxiosRequestConfig) {
    return FileSystemApiFp(this.configuration)
      .createFolder(path, mode, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete a file or directory at the specified path
   * @summary Delete a file or directory
   * @param {string} path File or directory path to delete
   * @param {boolean} [recursive] Enable recursive deletion for directories
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileSystemApi
   */
  public deleteFile(path: string, recursive?: boolean, options?: RawAxiosRequestConfig) {
    return FileSystemApiFp(this.configuration)
      .deleteFile(path, recursive, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Download a file by providing its path
   * @summary Download a file
   * @param {string} path File path to download
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileSystemApi
   */
  public downloadFile(path: string, options?: RawAxiosRequestConfig) {
    return FileSystemApiFp(this.configuration)
      .downloadFile(path, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Download multiple files by providing their paths
   * @summary Download multiple files
   * @param {FilesDownloadRequest} downloadFiles Paths of files to download
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileSystemApi
   */
  public downloadFiles(downloadFiles: FilesDownloadRequest, options?: RawAxiosRequestConfig) {
    return FileSystemApiFp(this.configuration)
      .downloadFiles(downloadFiles, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Search for text pattern within files in a directory
   * @summary Find text in files
   * @param {string} path Directory path to search in
   * @param {string} pattern Text pattern to search for
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileSystemApi
   */
  public findInFiles(path: string, pattern: string, options?: RawAxiosRequestConfig) {
    return FileSystemApiFp(this.configuration)
      .findInFiles(path, pattern, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get detailed information about a file or directory
   * @summary Get file information
   * @param {string} path File or directory path
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileSystemApi
   */
  public getFileInfo(path: string, options?: RawAxiosRequestConfig) {
    return FileSystemApiFp(this.configuration)
      .getFileInfo(path, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List files and directories in the specified path
   * @summary List files and directories
   * @param {string} [path] Directory path to list (defaults to working directory)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileSystemApi
   */
  public listFiles(path?: string, options?: RawAxiosRequestConfig) {
    return FileSystemApiFp(this.configuration)
      .listFiles(path, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Move or rename a file or directory from source to destination
   * @summary Move or rename file/directory
   * @param {string} source Source file or directory path
   * @param {string} destination Destination file or directory path
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileSystemApi
   */
  public moveFile(source: string, destination: string, options?: RawAxiosRequestConfig) {
    return FileSystemApiFp(this.configuration)
      .moveFile(source, destination, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Replace text pattern with new value in multiple files
   * @summary Replace text in files
   * @param {ReplaceRequest} request Replace request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileSystemApi
   */
  public replaceInFiles(request: ReplaceRequest, options?: RawAxiosRequestConfig) {
    return FileSystemApiFp(this.configuration)
      .replaceInFiles(request, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Search for files matching a specific pattern in a directory
   * @summary Search files by pattern
   * @param {string} path Directory path to search in
   * @param {string} pattern File pattern to match (e.g., *.txt, *.go)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileSystemApi
   */
  public searchFiles(path: string, pattern: string, options?: RawAxiosRequestConfig) {
    return FileSystemApiFp(this.configuration)
      .searchFiles(path, pattern, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Set file permissions, ownership, and group for a file or directory
   * @summary Set file permissions
   * @param {string} path File or directory path
   * @param {string} [owner] Owner (username or UID)
   * @param {string} [group] Group (group name or GID)
   * @param {string} [mode] File mode in octal format (e.g., 0755)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileSystemApi
   */
  public setFilePermissions(
    path: string,
    owner?: string,
    group?: string,
    mode?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return FileSystemApiFp(this.configuration)
      .setFilePermissions(path, owner, group, mode, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Upload a file to the specified path
   * @summary Upload a file
   * @param {string} path Destination path for the uploaded file
   * @param {File} file File to upload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileSystemApi
   */
  public uploadFile(path: string, file: File, options?: RawAxiosRequestConfig) {
    return FileSystemApiFp(this.configuration)
      .uploadFile(path, file, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Upload multiple files with their destination paths
   * @summary Upload multiple files
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileSystemApi
   */
  public uploadFiles(options?: RawAxiosRequestConfig) {
    return FileSystemApiFp(this.configuration)
      .uploadFiles(options)
      .then((request) => request(this.axios, this.basePath))
  }
}
