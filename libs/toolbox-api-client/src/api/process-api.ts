/* tslint:disable */
/* eslint-disable */
/**
 * Daytona Toolbox API
 * Daytona Toolbox API
 *
 * The version of the OpenAPI document: v0.0.0-dev
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { Command } from '../models';
// @ts-ignore
import type { CreateSessionRequest } from '../models';
// @ts-ignore
import type { ExecuteRequest } from '../models';
// @ts-ignore
import type { ExecuteResponse } from '../models';
// @ts-ignore
import type { PtyCreateRequest } from '../models';
// @ts-ignore
import type { PtyCreateResponse } from '../models';
// @ts-ignore
import type { PtyListResponse } from '../models';
// @ts-ignore
import type { PtyResizeRequest } from '../models';
// @ts-ignore
import type { PtySessionInfo } from '../models';
// @ts-ignore
import type { Session } from '../models';
// @ts-ignore
import type { SessionExecuteRequest } from '../models';
// @ts-ignore
import type { SessionExecuteResponse } from '../models';
// @ts-ignore
import type { SessionSendInputRequest } from '../models';
/**
 * ProcessApi - axios parameter creator
 * @export
 */
export const ProcessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Establish a WebSocket connection to interact with a pseudo-terminal session
         * @summary Connect to PTY session via WebSocket
         * @param {string} sessionId PTY session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectPtySession: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('connectPtySession', 'sessionId', sessionId)
            const localVarPath = `/process/pty/{sessionId}/connect`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new pseudo-terminal session with specified configuration
         * @summary Create a new PTY session
         * @param {PtyCreateRequest} request PTY session creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPtySession: async (request: PtyCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createPtySession', 'request', request)
            const localVarPath = `/process/pty`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new shell session for command execution
         * @summary Create a new session
         * @param {CreateSessionRequest} request Session creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession: async (request: CreateSessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createSession', 'request', request)
            const localVarPath = `/process/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a pseudo-terminal session and terminate its process
         * @summary Delete a PTY session
         * @param {string} sessionId PTY session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePtySession: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('deletePtySession', 'sessionId', sessionId)
            const localVarPath = `/process/pty/{sessionId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing shell session
         * @summary Delete a session
         * @param {string} sessionId Session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('deleteSession', 'sessionId', sessionId)
            const localVarPath = `/process/session/{sessionId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute a shell command and return the output and exit code
         * @summary Execute a command
         * @param {ExecuteRequest} request Command execution request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeCommand: async (request: ExecuteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('executeCommand', 'request', request)
            const localVarPath = `/process/execute`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a specific pseudo-terminal session
         * @summary Get PTY session information
         * @param {string} sessionId PTY session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPtySession: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getPtySession', 'sessionId', sessionId)
            const localVarPath = `/process/pty/{sessionId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a specific session including its commands
         * @summary Get session details
         * @param {string} sessionId Session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getSession', 'sessionId', sessionId)
            const localVarPath = `/process/session/{sessionId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a specific command within a session
         * @summary Get session command details
         * @param {string} sessionId Session ID
         * @param {string} commandId Command ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionCommand: async (sessionId: string, commandId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getSessionCommand', 'sessionId', sessionId)
            // verify required parameter 'commandId' is not null or undefined
            assertParamExists('getSessionCommand', 'commandId', commandId)
            const localVarPath = `/process/session/{sessionId}/command/{commandId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"commandId"}}`, encodeURIComponent(String(commandId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get logs for a specific command within a session. Supports both HTTP and WebSocket streaming.
         * @summary Get session command logs
         * @param {string} sessionId Session ID
         * @param {string} commandId Command ID
         * @param {boolean} [follow] Follow logs in real-time (WebSocket only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionCommandLogs: async (sessionId: string, commandId: string, follow?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getSessionCommandLogs', 'sessionId', sessionId)
            // verify required parameter 'commandId' is not null or undefined
            assertParamExists('getSessionCommandLogs', 'commandId', commandId)
            const localVarPath = `/process/session/{sessionId}/command/{commandId}/logs`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"commandId"}}`, encodeURIComponent(String(commandId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (follow !== undefined) {
                localVarQueryParameter['follow'] = follow;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all active pseudo-terminal sessions
         * @summary List all PTY sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPtySessions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/process/pty`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all active shell sessions
         * @summary List all sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSessions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/process/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resize the terminal dimensions of a pseudo-terminal session
         * @summary Resize a PTY session
         * @param {string} sessionId PTY session ID
         * @param {PtyResizeRequest} request Resize request with new dimensions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resizePtySession: async (sessionId: string, request: PtyResizeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('resizePtySession', 'sessionId', sessionId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('resizePtySession', 'request', request)
            const localVarPath = `/process/pty/{sessionId}/resize`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send input data to a running command in a session for interactive execution
         * @summary Send input to command
         * @param {string} sessionId Session ID
         * @param {string} commandId Command ID
         * @param {SessionSendInputRequest} request Input send request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInput: async (sessionId: string, commandId: string, request: SessionSendInputRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('sendInput', 'sessionId', sessionId)
            // verify required parameter 'commandId' is not null or undefined
            assertParamExists('sendInput', 'commandId', commandId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('sendInput', 'request', request)
            const localVarPath = `/process/session/{sessionId}/command/{commandId}/input`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"commandId"}}`, encodeURIComponent(String(commandId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute a command within an existing shell session
         * @summary Execute command in session
         * @param {string} sessionId Session ID
         * @param {SessionExecuteRequest} request Command execution request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionExecuteCommand: async (sessionId: string, request: SessionExecuteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('sessionExecuteCommand', 'sessionId', sessionId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('sessionExecuteCommand', 'request', request)
            const localVarPath = `/process/session/{sessionId}/exec`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessApi - functional programming interface
 * @export
 */
export const ProcessApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProcessApiAxiosParamCreator(configuration)
    return {
        /**
         * Establish a WebSocket connection to interact with a pseudo-terminal session
         * @summary Connect to PTY session via WebSocket
         * @param {string} sessionId PTY session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectPtySession(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectPtySession(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProcessApi.connectPtySession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new pseudo-terminal session with specified configuration
         * @summary Create a new PTY session
         * @param {PtyCreateRequest} request PTY session creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPtySession(request: PtyCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PtyCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPtySession(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProcessApi.createPtySession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new shell session for command execution
         * @summary Create a new session
         * @param {CreateSessionRequest} request Session creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSession(request: CreateSessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSession(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProcessApi.createSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a pseudo-terminal session and terminate its process
         * @summary Delete a PTY session
         * @param {string} sessionId PTY session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePtySession(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePtySession(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProcessApi.deletePtySession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing shell session
         * @summary Delete a session
         * @param {string} sessionId Session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSession(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSession(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProcessApi.deleteSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Execute a shell command and return the output and exit code
         * @summary Execute a command
         * @param {ExecuteRequest} request Command execution request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeCommand(request: ExecuteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeCommand(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProcessApi.executeCommand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get detailed information about a specific pseudo-terminal session
         * @summary Get PTY session information
         * @param {string} sessionId PTY session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPtySession(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PtySessionInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPtySession(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProcessApi.getPtySession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get details of a specific session including its commands
         * @summary Get session details
         * @param {string} sessionId Session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSession(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSession(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProcessApi.getSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get details of a specific command within a session
         * @summary Get session command details
         * @param {string} sessionId Session ID
         * @param {string} commandId Command ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionCommand(sessionId: string, commandId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Command>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionCommand(sessionId, commandId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProcessApi.getSessionCommand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get logs for a specific command within a session. Supports both HTTP and WebSocket streaming.
         * @summary Get session command logs
         * @param {string} sessionId Session ID
         * @param {string} commandId Command ID
         * @param {boolean} [follow] Follow logs in real-time (WebSocket only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionCommandLogs(sessionId: string, commandId: string, follow?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionCommandLogs(sessionId, commandId, follow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProcessApi.getSessionCommandLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all active pseudo-terminal sessions
         * @summary List all PTY sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPtySessions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PtyListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPtySessions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProcessApi.listPtySessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all active shell sessions
         * @summary List all sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSessions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Session>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSessions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProcessApi.listSessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resize the terminal dimensions of a pseudo-terminal session
         * @summary Resize a PTY session
         * @param {string} sessionId PTY session ID
         * @param {PtyResizeRequest} request Resize request with new dimensions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resizePtySession(sessionId: string, request: PtyResizeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PtySessionInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resizePtySession(sessionId, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProcessApi.resizePtySession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send input data to a running command in a session for interactive execution
         * @summary Send input to command
         * @param {string} sessionId Session ID
         * @param {string} commandId Command ID
         * @param {SessionSendInputRequest} request Input send request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendInput(sessionId: string, commandId: string, request: SessionSendInputRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendInput(sessionId, commandId, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProcessApi.sendInput']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Execute a command within an existing shell session
         * @summary Execute command in session
         * @param {string} sessionId Session ID
         * @param {SessionExecuteRequest} request Command execution request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionExecuteCommand(sessionId: string, request: SessionExecuteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionExecuteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionExecuteCommand(sessionId, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProcessApi.sessionExecuteCommand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProcessApi - factory interface
 * @export
 */
export const ProcessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProcessApiFp(configuration)
    return {
        /**
         * Establish a WebSocket connection to interact with a pseudo-terminal session
         * @summary Connect to PTY session via WebSocket
         * @param {string} sessionId PTY session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectPtySession(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.connectPtySession(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new pseudo-terminal session with specified configuration
         * @summary Create a new PTY session
         * @param {PtyCreateRequest} request PTY session creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPtySession(request: PtyCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<PtyCreateResponse> {
            return localVarFp.createPtySession(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new shell session for command execution
         * @summary Create a new session
         * @param {CreateSessionRequest} request Session creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession(request: CreateSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createSession(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a pseudo-terminal session and terminate its process
         * @summary Delete a PTY session
         * @param {string} sessionId PTY session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePtySession(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.deletePtySession(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing shell session
         * @summary Delete a session
         * @param {string} sessionId Session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSession(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Execute a shell command and return the output and exit code
         * @summary Execute a command
         * @param {ExecuteRequest} request Command execution request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeCommand(request: ExecuteRequest, options?: RawAxiosRequestConfig): AxiosPromise<ExecuteResponse> {
            return localVarFp.executeCommand(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get detailed information about a specific pseudo-terminal session
         * @summary Get PTY session information
         * @param {string} sessionId PTY session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPtySession(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<PtySessionInfo> {
            return localVarFp.getPtySession(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a specific session including its commands
         * @summary Get session details
         * @param {string} sessionId Session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Session> {
            return localVarFp.getSession(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a specific command within a session
         * @summary Get session command details
         * @param {string} sessionId Session ID
         * @param {string} commandId Command ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionCommand(sessionId: string, commandId: string, options?: RawAxiosRequestConfig): AxiosPromise<Command> {
            return localVarFp.getSessionCommand(sessionId, commandId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get logs for a specific command within a session. Supports both HTTP and WebSocket streaming.
         * @summary Get session command logs
         * @param {string} sessionId Session ID
         * @param {string} commandId Command ID
         * @param {boolean} [follow] Follow logs in real-time (WebSocket only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionCommandLogs(sessionId: string, commandId: string, follow?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getSessionCommandLogs(sessionId, commandId, follow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all active pseudo-terminal sessions
         * @summary List all PTY sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPtySessions(options?: RawAxiosRequestConfig): AxiosPromise<PtyListResponse> {
            return localVarFp.listPtySessions(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all active shell sessions
         * @summary List all sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSessions(options?: RawAxiosRequestConfig): AxiosPromise<Array<Session>> {
            return localVarFp.listSessions(options).then((request) => request(axios, basePath));
        },
        /**
         * Resize the terminal dimensions of a pseudo-terminal session
         * @summary Resize a PTY session
         * @param {string} sessionId PTY session ID
         * @param {PtyResizeRequest} request Resize request with new dimensions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resizePtySession(sessionId: string, request: PtyResizeRequest, options?: RawAxiosRequestConfig): AxiosPromise<PtySessionInfo> {
            return localVarFp.resizePtySession(sessionId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Send input data to a running command in a session for interactive execution
         * @summary Send input to command
         * @param {string} sessionId Session ID
         * @param {string} commandId Command ID
         * @param {SessionSendInputRequest} request Input send request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInput(sessionId: string, commandId: string, request: SessionSendInputRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendInput(sessionId, commandId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Execute a command within an existing shell session
         * @summary Execute command in session
         * @param {string} sessionId Session ID
         * @param {SessionExecuteRequest} request Command execution request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionExecuteCommand(sessionId: string, request: SessionExecuteRequest, options?: RawAxiosRequestConfig): AxiosPromise<SessionExecuteResponse> {
            return localVarFp.sessionExecuteCommand(sessionId, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProcessApi - object-oriented interface
 * @export
 * @class ProcessApi
 * @extends {BaseAPI}
 */
export class ProcessApi extends BaseAPI {
    /**
     * Establish a WebSocket connection to interact with a pseudo-terminal session
     * @summary Connect to PTY session via WebSocket
     * @param {string} sessionId PTY session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessApi
     */
    public connectPtySession(sessionId: string, options?: RawAxiosRequestConfig) {
        return ProcessApiFp(this.configuration).connectPtySession(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new pseudo-terminal session with specified configuration
     * @summary Create a new PTY session
     * @param {PtyCreateRequest} request PTY session creation request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessApi
     */
    public createPtySession(request: PtyCreateRequest, options?: RawAxiosRequestConfig) {
        return ProcessApiFp(this.configuration).createPtySession(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new shell session for command execution
     * @summary Create a new session
     * @param {CreateSessionRequest} request Session creation request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessApi
     */
    public createSession(request: CreateSessionRequest, options?: RawAxiosRequestConfig) {
        return ProcessApiFp(this.configuration).createSession(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a pseudo-terminal session and terminate its process
     * @summary Delete a PTY session
     * @param {string} sessionId PTY session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessApi
     */
    public deletePtySession(sessionId: string, options?: RawAxiosRequestConfig) {
        return ProcessApiFp(this.configuration).deletePtySession(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing shell session
     * @summary Delete a session
     * @param {string} sessionId Session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessApi
     */
    public deleteSession(sessionId: string, options?: RawAxiosRequestConfig) {
        return ProcessApiFp(this.configuration).deleteSession(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Execute a shell command and return the output and exit code
     * @summary Execute a command
     * @param {ExecuteRequest} request Command execution request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessApi
     */
    public executeCommand(request: ExecuteRequest, options?: RawAxiosRequestConfig) {
        return ProcessApiFp(this.configuration).executeCommand(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get detailed information about a specific pseudo-terminal session
     * @summary Get PTY session information
     * @param {string} sessionId PTY session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessApi
     */
    public getPtySession(sessionId: string, options?: RawAxiosRequestConfig) {
        return ProcessApiFp(this.configuration).getPtySession(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a specific session including its commands
     * @summary Get session details
     * @param {string} sessionId Session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessApi
     */
    public getSession(sessionId: string, options?: RawAxiosRequestConfig) {
        return ProcessApiFp(this.configuration).getSession(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a specific command within a session
     * @summary Get session command details
     * @param {string} sessionId Session ID
     * @param {string} commandId Command ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessApi
     */
    public getSessionCommand(sessionId: string, commandId: string, options?: RawAxiosRequestConfig) {
        return ProcessApiFp(this.configuration).getSessionCommand(sessionId, commandId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get logs for a specific command within a session. Supports both HTTP and WebSocket streaming.
     * @summary Get session command logs
     * @param {string} sessionId Session ID
     * @param {string} commandId Command ID
     * @param {boolean} [follow] Follow logs in real-time (WebSocket only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessApi
     */
    public getSessionCommandLogs(sessionId: string, commandId: string, follow?: boolean, options?: RawAxiosRequestConfig) {
        return ProcessApiFp(this.configuration).getSessionCommandLogs(sessionId, commandId, follow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all active pseudo-terminal sessions
     * @summary List all PTY sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessApi
     */
    public listPtySessions(options?: RawAxiosRequestConfig) {
        return ProcessApiFp(this.configuration).listPtySessions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all active shell sessions
     * @summary List all sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessApi
     */
    public listSessions(options?: RawAxiosRequestConfig) {
        return ProcessApiFp(this.configuration).listSessions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resize the terminal dimensions of a pseudo-terminal session
     * @summary Resize a PTY session
     * @param {string} sessionId PTY session ID
     * @param {PtyResizeRequest} request Resize request with new dimensions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessApi
     */
    public resizePtySession(sessionId: string, request: PtyResizeRequest, options?: RawAxiosRequestConfig) {
        return ProcessApiFp(this.configuration).resizePtySession(sessionId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send input data to a running command in a session for interactive execution
     * @summary Send input to command
     * @param {string} sessionId Session ID
     * @param {string} commandId Command ID
     * @param {SessionSendInputRequest} request Input send request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessApi
     */
    public sendInput(sessionId: string, commandId: string, request: SessionSendInputRequest, options?: RawAxiosRequestConfig) {
        return ProcessApiFp(this.configuration).sendInput(sessionId, commandId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Execute a command within an existing shell session
     * @summary Execute command in session
     * @param {string} sessionId Session ID
     * @param {SessionExecuteRequest} request Command execution request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessApi
     */
    public sessionExecuteCommand(sessionId: string, request: SessionExecuteRequest, options?: RawAxiosRequestConfig) {
        return ProcessApiFp(this.configuration).sessionExecuteCommand(sessionId, request, options).then((request) => request(this.axios, this.basePath));
    }
}

